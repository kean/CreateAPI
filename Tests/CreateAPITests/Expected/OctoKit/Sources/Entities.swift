// Generated by Create API
// https://github.com/CreateAPI/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// GitHub app
///
/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
public struct Integration: Codable {
    /// Unique identifier of the GitHub app
    ///
    /// Example: 37
    public var id: Int
    /// The slug name of the GitHub app
    ///
    /// Example: "probot-owners"
    public var slug: String?
    /// Example: "MDExOkludGVncmF0aW9uMQ=="
    public var nodeID: String
    /// Simple User
    public var owner: SimpleUser?
    /// The name of the GitHub app
    ///
    /// Example: "Probot Owners"
    public var name: String
    /// Example: "The description of the app."
    public var description: String?
    /// Example: "https://example.com"
    public var externalURL: URL
    /// Example: "https://github.com/apps/super-ci"
    public var htmlURL: URL
    /// Example: "2017-07-08T16:18:44-04:00"
    public var createdAt: Date
    /// Example: "2017-07-08T16:18:44-04:00"
    public var updatedAt: Date
    /// The set of permissions for the GitHub app
    ///
    /// Example:
    ///
    /// {
    ///   "deployments" : "write",
    ///   "issues" : "read"
    /// }
    public var permissions: [String: String]
    /// The list of events for the GitHub app
    ///
    /// Example: ["label", "deployment"]
    public var events: [String]
    /// The number of installations associated with the GitHub app
    public var installationsCount: Int?
    /// Example: "Iv1.25b5d1e65ffc4022"
    public var clientID: String?
    /// Example: "1d4b2097ac622ba702d19de498f005747a8b21d3"
    public var clientSecret: String?
    /// Example: "6fba8f2fc8a7e8f2cca5577eddd82ca7586b3b6b"
    public var webhookSecret: String?
    /// Example: "-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEArYxrNYD/iT5CZVpRJu4rBKmmze3PVmT/gCo2ATUvDvZTPTey\nxcGJ3vvrJXazKk06pN05TN29o98jrYz4cengG3YGsXPNEpKsIrEl8NhbnxapEnM9\nJCMRe0P5JcPsfZlX6hmiT7136GRWiGOUba2X9+HKh8QJVLG5rM007TBER9/z9mWm\nrJuNh+m5l320oBQY/Qq3A7wzdEfZw8qm/mIN0FCeoXH1L6B8xXWaAYBwhTEh6SSn\nZHlO1Xu1JWDmAvBCi0RO5aRSKM8q9QEkvvHP4yweAtK3N8+aAbZ7ovaDhyGz8r6r\nzhU1b8Uo0Z2ysf503WqzQgIajr7Fry7/kUwpgQIDAQABAoIBADwJp80Ko1xHPZDy\nfcCKBDfIuPvkmSW6KumbsLMaQv1aGdHDwwTGv3t0ixSay8CGlxMRtRDyZPib6SvQ\n6OH/lpfpbMdW2ErkksgtoIKBVrDilfrcAvrNZu7NxRNbhCSvN8q0s4ICecjbbVQh\nnueSdlA6vGXbW58BHMq68uRbHkP+k+mM9U0mDJ1HMch67wlg5GbayVRt63H7R2+r\nVxcna7B80J/lCEjIYZznawgiTvp3MSanTglqAYi+m1EcSsP14bJIB9vgaxS79kTu\noiSo93leJbBvuGo8QEiUqTwMw4tDksmkLsoqNKQ1q9P7LZ9DGcujtPy4EZsamSJT\ny8OJt0ECgYEA2lxOxJsQk2kI325JgKFjo92mQeUObIvPfSNWUIZQDTjniOI6Gv63\nGLWVFrZcvQBWjMEQraJA9xjPbblV8PtfO87MiJGLWCHFxmPz2dzoedN+2Coxom8m\nV95CLz8QUShuao6u/RYcvUaZEoYs5bHcTmy5sBK80JyEmafJPtCQVxMCgYEAy3ar\nZr3yv4xRPEPMat4rseswmuMooSaK3SKub19WFI5IAtB/e7qR1Rj9JhOGcZz+OQrl\nT78O2OFYlgOIkJPvRMrPpK5V9lslc7tz1FSh3BZMRGq5jSyD7ETSOQ0c8T2O/s7v\nbeEPbVbDe4mwvM24XByH0GnWveVxaDl51ABD65sCgYB3ZAspUkOA5egVCh8kNpnd\nSd6SnuQBE3ySRlT2WEnCwP9Ph6oPgn+oAfiPX4xbRqkL8q/k0BdHQ4h+zNwhk7+h\nWtPYRAP1Xxnc/F+jGjb+DVaIaKGU18MWPg7f+FI6nampl3Q0KvfxwX0GdNhtio8T\nTj1E+SnFwh56SRQuxSh2gwKBgHKjlIO5NtNSflsUYFM+hyQiPiqnHzddfhSG+/3o\nm5nNaSmczJesUYreH5San7/YEy2UxAugvP7aSY2MxB+iGsiJ9WD2kZzTUlDZJ7RV\nUzWsoqBR+eZfVJ2FUWWvy8TpSG6trh4dFxImNtKejCR1TREpSiTV3Zb1dmahK9GV\nrK9NAoGAbBxRLoC01xfxCTgt5BDiBcFVh4fp5yYKwavJPLzHSpuDOrrI9jDn1oKN\nonq5sDU1i391zfQvdrbX4Ova48BN+B7p63FocP/MK5tyyBoT8zQEk2+vWDOw7H/Z\nu5dTCPxTIsoIwUw1I+7yIxqJzLPFgR2gVBwY1ra/8iAqCj+zeBw=\n-----END RSA PRIVATE KEY-----\n"
    public var pem: String?

    public init(id: Int, slug: String? = nil, nodeID: String, owner: SimpleUser? = nil, name: String, description: String? = nil, externalURL: URL, htmlURL: URL, createdAt: Date, updatedAt: Date, permissions: [String: String], events: [String], installationsCount: Int? = nil, clientID: String? = nil, clientSecret: String? = nil, webhookSecret: String? = nil, pem: String? = nil) {
        self.id = id
        self.slug = slug
        self.nodeID = nodeID
        self.owner = owner
        self.name = name
        self.description = description
        self.externalURL = externalURL
        self.htmlURL = htmlURL
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.permissions = permissions
        self.events = events
        self.installationsCount = installationsCount
        self.clientID = clientID
        self.clientSecret = clientSecret
        self.webhookSecret = webhookSecret
        self.pem = pem
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.slug = try values.decodeIfPresent(String.self, forKey: "slug")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.name = try values.decode(String.self, forKey: "name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.externalURL = try values.decode(URL.self, forKey: "external_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.permissions = try values.decode([String: String].self, forKey: "permissions")
        self.events = try values.decode([String].self, forKey: "events")
        self.installationsCount = try values.decodeIfPresent(Int.self, forKey: "installations_count")
        self.clientID = try values.decodeIfPresent(String.self, forKey: "client_id")
        self.clientSecret = try values.decodeIfPresent(String.self, forKey: "client_secret")
        self.webhookSecret = try values.decodeIfPresent(String.self, forKey: "webhook_secret")
        self.pem = try values.decodeIfPresent(String.self, forKey: "pem")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(slug, forKey: "slug")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(externalURL, forKey: "external_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(permissions, forKey: "permissions")
        try values.encode(events, forKey: "events")
        try values.encodeIfPresent(installationsCount, forKey: "installations_count")
        try values.encodeIfPresent(clientID, forKey: "client_id")
        try values.encodeIfPresent(clientSecret, forKey: "client_secret")
        try values.encodeIfPresent(webhookSecret, forKey: "webhook_secret")
        try values.encodeIfPresent(pem, forKey: "pem")
    }
}

public struct BasicError: Codable {
    public var message: String?
    public var documentationURL: String?
    public var url: String?
    public var status: String?

    public init(message: String? = nil, documentationURL: String? = nil, url: String? = nil, status: String? = nil) {
        self.message = message
        self.documentationURL = documentationURL
        self.url = url
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.documentationURL = try values.decodeIfPresent(String.self, forKey: "documentation_url")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(documentationURL, forKey: "documentation_url")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(status, forKey: "status")
    }
}

public struct ValidationErrorSimple: Codable {
    public var message: String
    public var documentationURL: String
    public var errors: [String]?

    public init(message: String, documentationURL: String, errors: [String]? = nil) {
        self.message = message
        self.documentationURL = documentationURL
        self.errors = errors
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.message = try values.decode(String.self, forKey: "message")
        self.documentationURL = try values.decode(String.self, forKey: "documentation_url")
        self.errors = try values.decodeIfPresent([String].self, forKey: "errors")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(message, forKey: "message")
        try values.encode(documentationURL, forKey: "documentation_url")
        try values.encodeIfPresent(errors, forKey: "errors")
    }
}

public enum WebhookConfigInsecureSSL: Codable, Hashable {
    case string(String)
    case double(Double)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(String.self) {
            self = .string(value)
        } else if let value = try? container.decode(Double.self) {
            self = .double(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let value): try container.encode(value)
        case .double(let value): try container.encode(value)
        }
    }
}

/// Webhook Configuration
///
/// Configuration object of the webhook
public struct WebhookConfig: Codable {
    /// The URL to which the payloads will be delivered.
    ///
    /// Example: "https://example.com/webhook"
    public var url: URL?
    /// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
    ///
    /// Example: "json"
    public var contentType: String?
    /// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
    ///
    /// Example: "********"
    public var secret: String?
    public var insecureSSL: WebhookConfigInsecureSSL?

    public init(url: URL? = nil, contentType: String? = nil, secret: String? = nil, insecureSSL: WebhookConfigInsecureSSL? = nil) {
        self.url = url
        self.contentType = contentType
        self.secret = secret
        self.insecureSSL = insecureSSL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.contentType = try values.decodeIfPresent(String.self, forKey: "content_type")
        self.secret = try values.decodeIfPresent(String.self, forKey: "secret")
        self.insecureSSL = try values.decodeIfPresent(WebhookConfigInsecureSSL.self, forKey: "insecure_ssl")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(contentType, forKey: "content_type")
        try values.encodeIfPresent(secret, forKey: "secret")
        try values.encodeIfPresent(insecureSSL, forKey: "insecure_ssl")
    }
}

/// Simple webhook delivery
///
/// Delivery made by a webhook, without request and response information.
public struct HookDeliveryItem: Codable {
    /// Unique identifier of the webhook delivery.
    ///
    /// Example: 42
    public var id: Int
    /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
    ///
    /// Example: "58474f00-b361-11eb-836d-0e4f3503ccbe"
    public var guid: String
    /// Time when the webhook delivery occurred.
    ///
    /// Example: "2021-05-12T20:33:44Z"
    public var deliveredAt: Date
    /// Whether the webhook delivery is a redelivery.
    ///
    /// Example: false
    public var isRedelivery: Bool
    /// Time spent delivering.
    ///
    /// Example: 0.03
    public var duration: Double
    /// Describes the response returned after attempting the delivery.
    ///
    /// Example: "failed to connect"
    public var status: String
    /// Status code received when delivery was made.
    ///
    /// Example: 502
    public var statusCode: Int
    /// The event that triggered the delivery.
    ///
    /// Example: "issues"
    public var event: String
    /// The type of activity for the event that triggered the delivery.
    ///
    /// Example: "opened"
    public var action: String?
    /// The id of the GitHub App installation associated with this event.
    ///
    /// Example: 123
    public var installationID: Int?
    /// The id of the repository associated with this event.
    ///
    /// Example: 123
    public var repositoryID: Int?

    public init(id: Int, guid: String, deliveredAt: Date, isRedelivery: Bool, duration: Double, status: String, statusCode: Int, event: String, action: String? = nil, installationID: Int? = nil, repositoryID: Int? = nil) {
        self.id = id
        self.guid = guid
        self.deliveredAt = deliveredAt
        self.isRedelivery = isRedelivery
        self.duration = duration
        self.status = status
        self.statusCode = statusCode
        self.event = event
        self.action = action
        self.installationID = installationID
        self.repositoryID = repositoryID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.guid = try values.decode(String.self, forKey: "guid")
        self.deliveredAt = try values.decode(Date.self, forKey: "delivered_at")
        self.isRedelivery = try values.decode(Bool.self, forKey: "redelivery")
        self.duration = try values.decode(Double.self, forKey: "duration")
        self.status = try values.decode(String.self, forKey: "status")
        self.statusCode = try values.decode(Int.self, forKey: "status_code")
        self.event = try values.decode(String.self, forKey: "event")
        self.action = try values.decodeIfPresent(String.self, forKey: "action")
        self.installationID = try values.decodeIfPresent(Int.self, forKey: "installation_id")
        self.repositoryID = try values.decodeIfPresent(Int.self, forKey: "repository_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(guid, forKey: "guid")
        try values.encode(deliveredAt, forKey: "delivered_at")
        try values.encode(isRedelivery, forKey: "redelivery")
        try values.encode(duration, forKey: "duration")
        try values.encode(status, forKey: "status")
        try values.encode(statusCode, forKey: "status_code")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(action, forKey: "action")
        try values.encodeIfPresent(installationID, forKey: "installation_id")
        try values.encodeIfPresent(repositoryID, forKey: "repository_id")
    }
}

public struct ScimError: Codable {
    public var message: String?
    public var documentationURL: String?
    public var detail: String?
    public var status: Int?
    public var scimType: String?
    public var schemas: [String]?

    public init(message: String? = nil, documentationURL: String? = nil, detail: String? = nil, status: Int? = nil, scimType: String? = nil, schemas: [String]? = nil) {
        self.message = message
        self.documentationURL = documentationURL
        self.detail = detail
        self.status = status
        self.scimType = scimType
        self.schemas = schemas
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.documentationURL = try values.decodeIfPresent(String.self, forKey: "documentation_url")
        self.detail = try values.decodeIfPresent(String.self, forKey: "detail")
        self.status = try values.decodeIfPresent(Int.self, forKey: "status")
        self.scimType = try values.decodeIfPresent(String.self, forKey: "scimType")
        self.schemas = try values.decodeIfPresent([String].self, forKey: "schemas")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(documentationURL, forKey: "documentation_url")
        try values.encodeIfPresent(detail, forKey: "detail")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(scimType, forKey: "scimType")
        try values.encodeIfPresent(schemas, forKey: "schemas")
    }
}

public struct ValidationError: Codable {
    public var message: String
    public var documentationURL: String
    public var errors: [Error]?

    public struct Error: Codable {
        public var resource: String?
        public var field: String?
        public var message: String?
        public var code: String
        public var index: Int?
        public var value: Value?

        public enum Value: Codable {
            case string(String)
            case int(Int)
            case strings([String])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(String.self) {
                    self = .string(value)
                } else if let value = try? container.decode(Int.self) {
                    self = .int(value)
                } else if let value = try? container.decode([String].self) {
                    self = .strings(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .string(let value): try container.encode(value)
                case .int(let value): try container.encode(value)
                case .strings(let value): try container.encode(value)
                }
            }
        }

        public init(resource: String? = nil, field: String? = nil, message: String? = nil, code: String, index: Int? = nil, value: Value? = nil) {
            self.resource = resource
            self.field = field
            self.message = message
            self.code = code
            self.index = index
            self.value = value
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.resource = try values.decodeIfPresent(String.self, forKey: "resource")
            self.field = try values.decodeIfPresent(String.self, forKey: "field")
            self.message = try values.decodeIfPresent(String.self, forKey: "message")
            self.code = try values.decode(String.self, forKey: "code")
            self.index = try values.decodeIfPresent(Int.self, forKey: "index")
            self.value = try values.decodeIfPresent(Value.self, forKey: "value")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(resource, forKey: "resource")
            try values.encodeIfPresent(field, forKey: "field")
            try values.encodeIfPresent(message, forKey: "message")
            try values.encode(code, forKey: "code")
            try values.encodeIfPresent(index, forKey: "index")
            try values.encodeIfPresent(value, forKey: "value")
        }
    }

    public init(message: String, documentationURL: String, errors: [Error]? = nil) {
        self.message = message
        self.documentationURL = documentationURL
        self.errors = errors
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.message = try values.decode(String.self, forKey: "message")
        self.documentationURL = try values.decode(String.self, forKey: "documentation_url")
        self.errors = try values.decodeIfPresent([Error].self, forKey: "errors")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(message, forKey: "message")
        try values.encode(documentationURL, forKey: "documentation_url")
        try values.encodeIfPresent(errors, forKey: "errors")
    }
}

/// Webhook delivery
///
/// Delivery made by a webhook.
public struct HookDelivery: Codable {
    /// Unique identifier of the delivery.
    ///
    /// Example: 42
    public var id: Int
    /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
    ///
    /// Example: "58474f00-b361-11eb-836d-0e4f3503ccbe"
    public var guid: String
    /// Time when the delivery was delivered.
    ///
    /// Example: "2021-05-12T20:33:44Z"
    public var deliveredAt: Date
    /// Whether the delivery is a redelivery.
    ///
    /// Example: false
    public var isRedelivery: Bool
    /// Time spent delivering.
    ///
    /// Example: 0.03
    public var duration: Double
    /// Description of the status of the attempted delivery
    ///
    /// Example: "failed to connect"
    public var status: String
    /// Status code received when delivery was made.
    ///
    /// Example: 502
    public var statusCode: Int
    /// The event that triggered the delivery.
    ///
    /// Example: "issues"
    public var event: String
    /// The type of activity for the event that triggered the delivery.
    ///
    /// Example: "opened"
    public var action: String?
    /// The id of the GitHub App installation associated with this event.
    ///
    /// Example: 123
    public var installationID: Int?
    /// The id of the repository associated with this event.
    ///
    /// Example: 123
    public var repositoryID: Int?
    /// The URL target of the delivery.
    ///
    /// Example: "https://www.example.com"
    public var url: String?
    public var request: Request
    public var response: Response

    public struct Request: Codable {
        /// The request headers sent with the webhook delivery.
        public var headers: [String: AnyJSON]?
        /// The webhook payload.
        public var payload: [String: AnyJSON]?

        public init(headers: [String: AnyJSON]? = nil, payload: [String: AnyJSON]? = nil) {
            self.headers = headers
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.headers = try values.decodeIfPresent([String: AnyJSON].self, forKey: "headers")
            self.payload = try values.decodeIfPresent([String: AnyJSON].self, forKey: "payload")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(headers, forKey: "headers")
            try values.encodeIfPresent(payload, forKey: "payload")
        }
    }

    public struct Response: Codable {
        /// The response headers received when the delivery was made.
        public var headers: [String: AnyJSON]?
        /// The response payload received.
        public var payload: String?

        public init(headers: [String: AnyJSON]? = nil, payload: String? = nil) {
            self.headers = headers
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.headers = try values.decodeIfPresent([String: AnyJSON].self, forKey: "headers")
            self.payload = try values.decodeIfPresent(String.self, forKey: "payload")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(headers, forKey: "headers")
            try values.encodeIfPresent(payload, forKey: "payload")
        }
    }

    public init(id: Int, guid: String, deliveredAt: Date, isRedelivery: Bool, duration: Double, status: String, statusCode: Int, event: String, action: String? = nil, installationID: Int? = nil, repositoryID: Int? = nil, url: String? = nil, request: Request, response: Response) {
        self.id = id
        self.guid = guid
        self.deliveredAt = deliveredAt
        self.isRedelivery = isRedelivery
        self.duration = duration
        self.status = status
        self.statusCode = statusCode
        self.event = event
        self.action = action
        self.installationID = installationID
        self.repositoryID = repositoryID
        self.url = url
        self.request = request
        self.response = response
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.guid = try values.decode(String.self, forKey: "guid")
        self.deliveredAt = try values.decode(Date.self, forKey: "delivered_at")
        self.isRedelivery = try values.decode(Bool.self, forKey: "redelivery")
        self.duration = try values.decode(Double.self, forKey: "duration")
        self.status = try values.decode(String.self, forKey: "status")
        self.statusCode = try values.decode(Int.self, forKey: "status_code")
        self.event = try values.decode(String.self, forKey: "event")
        self.action = try values.decodeIfPresent(String.self, forKey: "action")
        self.installationID = try values.decodeIfPresent(Int.self, forKey: "installation_id")
        self.repositoryID = try values.decodeIfPresent(Int.self, forKey: "repository_id")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.request = try values.decode(Request.self, forKey: "request")
        self.response = try values.decode(Response.self, forKey: "response")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(guid, forKey: "guid")
        try values.encode(deliveredAt, forKey: "delivered_at")
        try values.encode(isRedelivery, forKey: "redelivery")
        try values.encode(duration, forKey: "duration")
        try values.encode(status, forKey: "status")
        try values.encode(statusCode, forKey: "status_code")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(action, forKey: "action")
        try values.encodeIfPresent(installationID, forKey: "installation_id")
        try values.encodeIfPresent(repositoryID, forKey: "repository_id")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encode(request, forKey: "request")
        try values.encode(response, forKey: "response")
    }
}

public struct SimpleUser: Codable {
    public var name: String?
    public var email: String?
    /// Example: "octocat"
    public var login: String
    public var id: Int
    /// Example: "MDQ6VXNlcjE="
    public var nodeID: String
    /// Example: "https://github.com/images/error/octocat_happy.gif"
    public var avatarURL: URL
    /// Example: "41d064eb2195891e12d0413f63227ea7"
    public var gravatarID: String?
    /// Example: "https://api.github.com/users/octocat"
    public var url: URL
    /// Example: "https://github.com/octocat"
    public var htmlURL: URL
    /// Example: "https://api.github.com/users/octocat/followers"
    public var followersURL: URL
    /// Example: "https://api.github.com/users/octocat/following{/other_user}"
    public var followingURL: String
    /// Example: "https://api.github.com/users/octocat/gists{/gist_id}"
    public var gistsURL: String
    /// Example: "https://api.github.com/users/octocat/starred{/owner}{/repo}"
    public var starredURL: String
    /// Example: "https://api.github.com/users/octocat/subscriptions"
    public var subscriptionsURL: URL
    /// Example: "https://api.github.com/users/octocat/orgs"
    public var organizationsURL: URL
    /// Example: "https://api.github.com/users/octocat/repos"
    public var reposURL: URL
    /// Example: "https://api.github.com/users/octocat/events{/privacy}"
    public var eventsURL: String
    /// Example: "https://api.github.com/users/octocat/received_events"
    public var receivedEventsURL: URL
    /// Example: "User"
    public var type: String
    public var isSiteAdmin: Bool
    /// Example: "2020-07-09T00:17:55Z"
    public var starredAt: String?

    public init(name: String? = nil, email: String? = nil, login: String, id: Int, nodeID: String, avatarURL: URL, gravatarID: String? = nil, url: URL, htmlURL: URL, followersURL: URL, followingURL: String, gistsURL: String, starredURL: String, subscriptionsURL: URL, organizationsURL: URL, reposURL: URL, eventsURL: String, receivedEventsURL: URL, type: String, isSiteAdmin: Bool, starredAt: String? = nil) {
        self.name = name
        self.email = email
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.isSiteAdmin = isSiteAdmin
        self.starredAt = starredAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.followersURL = try values.decode(URL.self, forKey: "followers_url")
        self.followingURL = try values.decode(String.self, forKey: "following_url")
        self.gistsURL = try values.decode(String.self, forKey: "gists_url")
        self.starredURL = try values.decode(String.self, forKey: "starred_url")
        self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(String.self, forKey: "events_url")
        self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
        self.starredAt = try values.decodeIfPresent(String.self, forKey: "starred_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(followersURL, forKey: "followers_url")
        try values.encode(followingURL, forKey: "following_url")
        try values.encode(gistsURL, forKey: "gists_url")
        try values.encode(starredURL, forKey: "starred_url")
        try values.encode(subscriptionsURL, forKey: "subscriptions_url")
        try values.encode(organizationsURL, forKey: "organizations_url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encode(isSiteAdmin, forKey: "site_admin")
        try values.encodeIfPresent(starredAt, forKey: "starred_at")
    }
}

/// An enterprise account
public struct Enterprise: Codable {
    /// A short description of the enterprise.
    public var description: String?
    /// Example: "https://github.com/enterprises/octo-business"
    public var htmlURL: URL
    /// The enterprise's website URL.
    public var websiteURL: URL?
    /// Unique identifier of the enterprise
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEwOlJlcG9zaXRvcnkxMjk2MjY5"
    public var nodeID: String
    /// The name of the enterprise.
    ///
    /// Example: "Octo Business"
    public var name: String
    /// The slug url identifier for the enterprise.
    ///
    /// Example: "octo-business"
    public var slug: String
    /// Example: "2019-01-26T19:01:12Z"
    public var createdAt: Date?
    /// Example: "2019-01-26T19:14:43Z"
    public var updatedAt: Date?
    public var avatarURL: URL

    public init(description: String? = nil, htmlURL: URL, websiteURL: URL? = nil, id: Int, nodeID: String, name: String, slug: String, createdAt: Date? = nil, updatedAt: Date? = nil, avatarURL: URL) {
        self.description = description
        self.htmlURL = htmlURL
        self.websiteURL = websiteURL
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.slug = slug
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.avatarURL = avatarURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.websiteURL = try values.decodeIfPresent(URL.self, forKey: "website_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.slug = try values.decode(String.self, forKey: "slug")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(websiteURL, forKey: "website_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(slug, forKey: "slug")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(avatarURL, forKey: "avatar_url")
    }
}

/// The permissions granted to the user-to-server access token.
///
/// Example:
///
/// {
///   "contents" : "read",
///   "deployments" : "write",
///   "issues" : "read",
///   "single_file" : "read"
/// }
public struct AppPermissions: Codable {
    /// The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`.
    public var actions: Actions?
    /// The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`.
    public var administration: Administration?
    /// The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`.
    public var checks: Checks?
    /// The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`.
    public var contents: Contents?
    /// The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`.
    public var deployments: Deployments?
    /// The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`.
    public var environments: Environments?
    /// The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`.
    public var issues: Issues?
    /// The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`.
    public var metadata: Metadata?
    /// The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`.
    public var packages: Packages?
    /// The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`.
    public var pages: Pages?
    /// The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`.
    public var pullRequests: PullRequests?
    /// The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`.
    public var repositoryHooks: RepositoryHooks?
    /// The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.
    public var repositoryProjects: RepositoryProjects?
    /// The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`.
    public var secretScanningAlerts: SecretScanningAlerts?
    /// The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`.
    public var secrets: Secrets?
    /// The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`.
    public var securityEvents: SecurityEvents?
    /// The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`.
    public var singleFile: SingleFile?
    /// The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`.
    public var statuses: Statuses?
    /// The level of permission to grant the access token to manage Dependabot alerts. Can be one of: `read` or `write`.
    public var vulnerabilityAlerts: VulnerabilityAlerts?
    /// The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`.
    public var workflows: Workflows?
    /// The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`.
    public var members: Members?
    /// The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`.
    public var organizationAdministration: OrganizationAdministration?
    /// The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`.
    public var organizationHooks: OrganizationHooks?
    /// The level of permission to grant the access token for viewing an organization's plan. Can be one of: `read`.
    public var organizationPlan: OrganizationPlan?
    /// The level of permission to grant the access token to manage organization projects and projects beta (where available). Can be one of: `read`, `write`, or `admin`.
    public var organizationProjects: OrganizationProjects?
    /// The level of permission to grant the access token for organization packages published to GitHub Packages. Can be one of: `read` or `write`.
    public var organizationPackages: OrganizationPackages?
    /// The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`.
    public var organizationSecrets: OrganizationSecrets?
    /// The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`.
    public var organizationSelfHostedRunners: OrganizationSelfHostedRunners?
    /// The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`.
    public var organizationUserBlocking: OrganizationUserBlocking?
    /// The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`.
    public var teamDiscussions: TeamDiscussions?

    /// The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`.
    public enum Actions: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`.
    public enum Administration: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`.
    public enum Checks: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`.
    public enum Contents: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`.
    public enum Deployments: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`.
    public enum Environments: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`.
    public enum Issues: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`.
    public enum Metadata: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`.
    public enum Packages: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`.
    public enum Pages: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`.
    public enum PullRequests: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`.
    public enum RepositoryHooks: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`.
    public enum RepositoryProjects: String, Codable, CaseIterable {
        case read
        case write
        case admin
    }

    /// The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`.
    public enum SecretScanningAlerts: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`.
    public enum Secrets: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`.
    public enum SecurityEvents: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`.
    public enum SingleFile: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`.
    public enum Statuses: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage Dependabot alerts. Can be one of: `read` or `write`.
    public enum VulnerabilityAlerts: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`.
    public enum Workflows: String, Codable, CaseIterable {
        case write
    }

    /// The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`.
    public enum Members: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`.
    public enum OrganizationAdministration: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`.
    public enum OrganizationHooks: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token for viewing an organization's plan. Can be one of: `read`.
    public enum OrganizationPlan: String, Codable, CaseIterable {
        case read
    }

    /// The level of permission to grant the access token to manage organization projects and projects beta (where available). Can be one of: `read`, `write`, or `admin`.
    public enum OrganizationProjects: String, Codable, CaseIterable {
        case read
        case write
        case admin
    }

    /// The level of permission to grant the access token for organization packages published to GitHub Packages. Can be one of: `read` or `write`.
    public enum OrganizationPackages: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`.
    public enum OrganizationSecrets: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`.
    public enum OrganizationSelfHostedRunners: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`.
    public enum OrganizationUserBlocking: String, Codable, CaseIterable {
        case read
        case write
    }

    /// The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`.
    public enum TeamDiscussions: String, Codable, CaseIterable {
        case read
        case write
    }

    public init(actions: Actions? = nil, administration: Administration? = nil, checks: Checks? = nil, contents: Contents? = nil, deployments: Deployments? = nil, environments: Environments? = nil, issues: Issues? = nil, metadata: Metadata? = nil, packages: Packages? = nil, pages: Pages? = nil, pullRequests: PullRequests? = nil, repositoryHooks: RepositoryHooks? = nil, repositoryProjects: RepositoryProjects? = nil, secretScanningAlerts: SecretScanningAlerts? = nil, secrets: Secrets? = nil, securityEvents: SecurityEvents? = nil, singleFile: SingleFile? = nil, statuses: Statuses? = nil, vulnerabilityAlerts: VulnerabilityAlerts? = nil, workflows: Workflows? = nil, members: Members? = nil, organizationAdministration: OrganizationAdministration? = nil, organizationHooks: OrganizationHooks? = nil, organizationPlan: OrganizationPlan? = nil, organizationProjects: OrganizationProjects? = nil, organizationPackages: OrganizationPackages? = nil, organizationSecrets: OrganizationSecrets? = nil, organizationSelfHostedRunners: OrganizationSelfHostedRunners? = nil, organizationUserBlocking: OrganizationUserBlocking? = nil, teamDiscussions: TeamDiscussions? = nil) {
        self.actions = actions
        self.administration = administration
        self.checks = checks
        self.contents = contents
        self.deployments = deployments
        self.environments = environments
        self.issues = issues
        self.metadata = metadata
        self.packages = packages
        self.pages = pages
        self.pullRequests = pullRequests
        self.repositoryHooks = repositoryHooks
        self.repositoryProjects = repositoryProjects
        self.secretScanningAlerts = secretScanningAlerts
        self.secrets = secrets
        self.securityEvents = securityEvents
        self.singleFile = singleFile
        self.statuses = statuses
        self.vulnerabilityAlerts = vulnerabilityAlerts
        self.workflows = workflows
        self.members = members
        self.organizationAdministration = organizationAdministration
        self.organizationHooks = organizationHooks
        self.organizationPlan = organizationPlan
        self.organizationProjects = organizationProjects
        self.organizationPackages = organizationPackages
        self.organizationSecrets = organizationSecrets
        self.organizationSelfHostedRunners = organizationSelfHostedRunners
        self.organizationUserBlocking = organizationUserBlocking
        self.teamDiscussions = teamDiscussions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.actions = try values.decodeIfPresent(Actions.self, forKey: "actions")
        self.administration = try values.decodeIfPresent(Administration.self, forKey: "administration")
        self.checks = try values.decodeIfPresent(Checks.self, forKey: "checks")
        self.contents = try values.decodeIfPresent(Contents.self, forKey: "contents")
        self.deployments = try values.decodeIfPresent(Deployments.self, forKey: "deployments")
        self.environments = try values.decodeIfPresent(Environments.self, forKey: "environments")
        self.issues = try values.decodeIfPresent(Issues.self, forKey: "issues")
        self.metadata = try values.decodeIfPresent(Metadata.self, forKey: "metadata")
        self.packages = try values.decodeIfPresent(Packages.self, forKey: "packages")
        self.pages = try values.decodeIfPresent(Pages.self, forKey: "pages")
        self.pullRequests = try values.decodeIfPresent(PullRequests.self, forKey: "pull_requests")
        self.repositoryHooks = try values.decodeIfPresent(RepositoryHooks.self, forKey: "repository_hooks")
        self.repositoryProjects = try values.decodeIfPresent(RepositoryProjects.self, forKey: "repository_projects")
        self.secretScanningAlerts = try values.decodeIfPresent(SecretScanningAlerts.self, forKey: "secret_scanning_alerts")
        self.secrets = try values.decodeIfPresent(Secrets.self, forKey: "secrets")
        self.securityEvents = try values.decodeIfPresent(SecurityEvents.self, forKey: "security_events")
        self.singleFile = try values.decodeIfPresent(SingleFile.self, forKey: "single_file")
        self.statuses = try values.decodeIfPresent(Statuses.self, forKey: "statuses")
        self.vulnerabilityAlerts = try values.decodeIfPresent(VulnerabilityAlerts.self, forKey: "vulnerability_alerts")
        self.workflows = try values.decodeIfPresent(Workflows.self, forKey: "workflows")
        self.members = try values.decodeIfPresent(Members.self, forKey: "members")
        self.organizationAdministration = try values.decodeIfPresent(OrganizationAdministration.self, forKey: "organization_administration")
        self.organizationHooks = try values.decodeIfPresent(OrganizationHooks.self, forKey: "organization_hooks")
        self.organizationPlan = try values.decodeIfPresent(OrganizationPlan.self, forKey: "organization_plan")
        self.organizationProjects = try values.decodeIfPresent(OrganizationProjects.self, forKey: "organization_projects")
        self.organizationPackages = try values.decodeIfPresent(OrganizationPackages.self, forKey: "organization_packages")
        self.organizationSecrets = try values.decodeIfPresent(OrganizationSecrets.self, forKey: "organization_secrets")
        self.organizationSelfHostedRunners = try values.decodeIfPresent(OrganizationSelfHostedRunners.self, forKey: "organization_self_hosted_runners")
        self.organizationUserBlocking = try values.decodeIfPresent(OrganizationUserBlocking.self, forKey: "organization_user_blocking")
        self.teamDiscussions = try values.decodeIfPresent(TeamDiscussions.self, forKey: "team_discussions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(actions, forKey: "actions")
        try values.encodeIfPresent(administration, forKey: "administration")
        try values.encodeIfPresent(checks, forKey: "checks")
        try values.encodeIfPresent(contents, forKey: "contents")
        try values.encodeIfPresent(deployments, forKey: "deployments")
        try values.encodeIfPresent(environments, forKey: "environments")
        try values.encodeIfPresent(issues, forKey: "issues")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(packages, forKey: "packages")
        try values.encodeIfPresent(pages, forKey: "pages")
        try values.encodeIfPresent(pullRequests, forKey: "pull_requests")
        try values.encodeIfPresent(repositoryHooks, forKey: "repository_hooks")
        try values.encodeIfPresent(repositoryProjects, forKey: "repository_projects")
        try values.encodeIfPresent(secretScanningAlerts, forKey: "secret_scanning_alerts")
        try values.encodeIfPresent(secrets, forKey: "secrets")
        try values.encodeIfPresent(securityEvents, forKey: "security_events")
        try values.encodeIfPresent(singleFile, forKey: "single_file")
        try values.encodeIfPresent(statuses, forKey: "statuses")
        try values.encodeIfPresent(vulnerabilityAlerts, forKey: "vulnerability_alerts")
        try values.encodeIfPresent(workflows, forKey: "workflows")
        try values.encodeIfPresent(members, forKey: "members")
        try values.encodeIfPresent(organizationAdministration, forKey: "organization_administration")
        try values.encodeIfPresent(organizationHooks, forKey: "organization_hooks")
        try values.encodeIfPresent(organizationPlan, forKey: "organization_plan")
        try values.encodeIfPresent(organizationProjects, forKey: "organization_projects")
        try values.encodeIfPresent(organizationPackages, forKey: "organization_packages")
        try values.encodeIfPresent(organizationSecrets, forKey: "organization_secrets")
        try values.encodeIfPresent(organizationSelfHostedRunners, forKey: "organization_self_hosted_runners")
        try values.encodeIfPresent(organizationUserBlocking, forKey: "organization_user_blocking")
        try values.encodeIfPresent(teamDiscussions, forKey: "team_discussions")
    }
}

public struct Installation: Codable {
    /// The ID of the installation.
    public var id: Int
    public var account: Account?
    /// Describe whether all repositories have been selected or there's a selection involved
    public var repositorySelection: RepositorySelection
    /// Example: "https://api.github.com/installations/1/access_tokens"
    public var accessTokensURL: URL
    /// Example: "https://api.github.com/installation/repositories"
    public var repositoriesURL: URL
    /// Example: "https://github.com/organizations/github/settings/installations/1"
    public var htmlURL: URL
    public var appID: Int
    /// The ID of the user or organization this token is being scoped to.
    public var targetID: Int
    /// Example: "Organization"
    public var targetType: String
    /// App Permissions
    ///
    /// The permissions granted to the user-to-server access token.
    ///
    /// Example:
    ///
    /// {
    ///   "contents" : "read",
    ///   "deployments" : "write",
    ///   "issues" : "read",
    ///   "single_file" : "read"
    /// }
    public var permissions: AppPermissions
    public var events: [String]
    public var createdAt: Date
    public var updatedAt: Date
    /// Example: "config.yaml"
    public var singleFileName: String?
    /// Example: true
    public var hasMultipleSingleFiles: Bool?
    /// Example: ["config.yml", ".github/issue_TEMPLATE.md"]
    public var singleFilePaths: [String]?
    /// Example: "github-actions"
    public var appSlug: String
    /// Simple User
    public var suspendedBy: SimpleUser?
    public var suspendedAt: Date?
    /// Example: "test_13f1e99741e3e004@d7e1eb0bc0a1ba12.com"
    public var contactEmail: String?

    public struct Account: Codable {
        public var simpleUser: SimpleUser?
        /// An enterprise account
        public var enterprise: Enterprise?

        public init(simpleUser: SimpleUser? = nil, enterprise: Enterprise? = nil) {
            self.simpleUser = simpleUser
            self.enterprise = enterprise
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.simpleUser = try? container.decode(SimpleUser.self)
            self.enterprise = try? container.decode(Enterprise.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = simpleUser { try container.encode(value) }
            if let value = enterprise { try container.encode(value) }
        }
    }

    /// Describe whether all repositories have been selected or there's a selection involved
    public enum RepositorySelection: String, Codable, CaseIterable {
        case all
        case selected
    }

    public init(id: Int, account: Account? = nil, repositorySelection: RepositorySelection, accessTokensURL: URL, repositoriesURL: URL, htmlURL: URL, appID: Int, targetID: Int, targetType: String, permissions: AppPermissions, events: [String], createdAt: Date, updatedAt: Date, singleFileName: String? = nil, hasMultipleSingleFiles: Bool? = nil, singleFilePaths: [String]? = nil, appSlug: String, suspendedBy: SimpleUser? = nil, suspendedAt: Date? = nil, contactEmail: String? = nil) {
        self.id = id
        self.account = account
        self.repositorySelection = repositorySelection
        self.accessTokensURL = accessTokensURL
        self.repositoriesURL = repositoriesURL
        self.htmlURL = htmlURL
        self.appID = appID
        self.targetID = targetID
        self.targetType = targetType
        self.permissions = permissions
        self.events = events
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.singleFileName = singleFileName
        self.hasMultipleSingleFiles = hasMultipleSingleFiles
        self.singleFilePaths = singleFilePaths
        self.appSlug = appSlug
        self.suspendedBy = suspendedBy
        self.suspendedAt = suspendedAt
        self.contactEmail = contactEmail
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.account = try values.decodeIfPresent(Account.self, forKey: "account")
        self.repositorySelection = try values.decode(RepositorySelection.self, forKey: "repository_selection")
        self.accessTokensURL = try values.decode(URL.self, forKey: "access_tokens_url")
        self.repositoriesURL = try values.decode(URL.self, forKey: "repositories_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.appID = try values.decode(Int.self, forKey: "app_id")
        self.targetID = try values.decode(Int.self, forKey: "target_id")
        self.targetType = try values.decode(String.self, forKey: "target_type")
        self.permissions = try values.decode(AppPermissions.self, forKey: "permissions")
        self.events = try values.decode([String].self, forKey: "events")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.singleFileName = try values.decodeIfPresent(String.self, forKey: "single_file_name")
        self.hasMultipleSingleFiles = try values.decodeIfPresent(Bool.self, forKey: "has_multiple_single_files")
        self.singleFilePaths = try values.decodeIfPresent([String].self, forKey: "single_file_paths")
        self.appSlug = try values.decode(String.self, forKey: "app_slug")
        self.suspendedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "suspended_by")
        self.suspendedAt = try values.decodeIfPresent(Date.self, forKey: "suspended_at")
        self.contactEmail = try values.decodeIfPresent(String.self, forKey: "contact_email")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(account, forKey: "account")
        try values.encode(repositorySelection, forKey: "repository_selection")
        try values.encode(accessTokensURL, forKey: "access_tokens_url")
        try values.encode(repositoriesURL, forKey: "repositories_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(appID, forKey: "app_id")
        try values.encode(targetID, forKey: "target_id")
        try values.encode(targetType, forKey: "target_type")
        try values.encode(permissions, forKey: "permissions")
        try values.encode(events, forKey: "events")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(singleFileName, forKey: "single_file_name")
        try values.encodeIfPresent(hasMultipleSingleFiles, forKey: "has_multiple_single_files")
        try values.encodeIfPresent(singleFilePaths, forKey: "single_file_paths")
        try values.encode(appSlug, forKey: "app_slug")
        try values.encodeIfPresent(suspendedBy, forKey: "suspended_by")
        try values.encodeIfPresent(suspendedAt, forKey: "suspended_at")
        try values.encodeIfPresent(contactEmail, forKey: "contact_email")
    }
}

/// A git repository
public struct Repository: Codable {
    /// Unique identifier of the repository
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEwOlJlcG9zaXRvcnkxMjk2MjY5"
    public var nodeID: String
    /// The name of the repository.
    ///
    /// Example: "Team Environment"
    public var name: String
    /// Example: "octocat/Hello-World"
    public var fullName: String
    /// License Simple
    public var license: LicenseSimple?
    /// Simple User
    public var organization: SimpleUser?
    public var forks: Int
    public var permissions: Permissions?
    /// Simple User
    public var owner: SimpleUser
    /// Whether the repository is private or public.
    public var isPrivate: Bool
    /// Example: "https://github.com/octocat/Hello-World"
    public var htmlURL: URL
    /// Example: "This your first repo!"
    public var description: String?
    public var isFork: Bool
    /// Example: "https://api.github.com/repos/octocat/Hello-World"
    public var url: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"
    public var archiveURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/assignees{/user}"
    public var assigneesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"
    public var blobsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/branches{/branch}"
    public var branchesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"
    public var collaboratorsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/comments{/number}"
    public var commentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/commits{/sha}"
    public var commitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"
    public var compareURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contents/{+path}"
    public var contentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contributors"
    public var contributorsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/deployments"
    public var deploymentsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/downloads"
    public var downloadsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/events"
    public var eventsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/forks"
    public var forksURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"
    public var gitCommitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"
    public var gitRefsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"
    public var gitTagsURL: String
    /// Example: "git:github.com/octocat/Hello-World.git"
    public var gitURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"
    public var issueCommentURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"
    public var issueEventsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues{/number}"
    public var issuesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"
    public var keysURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/labels{/name}"
    public var labelsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/languages"
    public var languagesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/merges"
    public var mergesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/milestones{/number}"
    public var milestonesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"
    public var notificationsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/pulls{/number}"
    public var pullsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/releases{/id}"
    public var releasesURL: String
    /// Example: "git@github.com:octocat/Hello-World.git"
    public var sshURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/stargazers"
    public var stargazersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"
    public var statusesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscribers"
    public var subscribersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscription"
    public var subscriptionURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/tags"
    public var tagsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/teams"
    public var teamsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"
    public var treesURL: String
    /// Example: "https://github.com/octocat/Hello-World.git"
    public var cloneURL: String
    /// Example: "git:git.example.com/octocat/Hello-World"
    public var mirrorURL: URL?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/hooks"
    public var hooksURL: URL
    /// Example: "https://svn.github.com/octocat/Hello-World"
    public var svnURL: URL
    /// Example: "https://github.com"
    public var homepage: URL?
    public var language: String?
    public var forksCount: Int
    /// Example: 80
    public var stargazersCount: Int
    /// Example: 80
    public var watchersCount: Int
    /// Example: 108
    public var size: Int
    /// The default branch of the repository.
    ///
    /// Example: "master"
    public var defaultBranch: String
    public var openIssuesCount: Int
    /// Whether this repository acts as a template that can be used to generate new repositories.
    ///
    /// Example: true
    public var isTemplate: Bool
    public var topics: [String]?
    /// Whether issues are enabled.
    ///
    /// Example: true
    public var hasIssues: Bool
    /// Whether projects are enabled.
    ///
    /// Example: true
    public var hasProjects: Bool
    /// Whether the wiki is enabled.
    ///
    /// Example: true
    public var hasWiki: Bool
    public var hasPages: Bool
    /// Whether downloads are enabled.
    ///
    /// Example: true
    public var hasDownloads: Bool
    /// Whether the repository is archived.
    public var isArchived: Bool
    /// Returns whether or not this repository disabled.
    public var isDisabled: Bool
    /// The repository visibility: public, private, or internal.
    public var visibility: String?
    /// Example: "2011-01-26T19:06:43Z"
    public var pushedAt: Date?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date?
    /// Example: "2011-01-26T19:14:43Z"
    public var updatedAt: Date?
    /// Whether to allow rebase merges for pull requests.
    ///
    /// Example: true
    public var allowRebaseMerge: Bool
    public var templateRepository: TemplateRepository?
    public var tempCloneToken: String?
    /// Whether to allow squash merges for pull requests.
    ///
    /// Example: true
    public var allowSquashMerge: Bool
    /// Whether to allow Auto-merge to be used on pull requests.
    ///
    /// Example: false
    public var allowAutoMerge: Bool
    /// Whether to delete head branches when pull requests are merged
    ///
    /// Example: false
    public var deleteBranchOnMerge: Bool
    /// Whether to allow merge commits for pull requests.
    ///
    /// Example: true
    public var allowMergeCommit: Bool
    /// Whether to allow forking this repo
    public var allowForking: Bool?
    public var subscribersCount: Int?
    public var networkCount: Int?
    public var openIssues: Int
    public var watchers: Int
    public var masterBranch: String?
    /// Example: "2020-07-09T00:17:42Z"
    public var starredAt: String?

    public struct Permissions: Codable {
        public var isAdmin: Bool
        public var isPull: Bool
        public var isTriage: Bool?
        public var isPush: Bool
        public var isMaintain: Bool?

        public init(isAdmin: Bool, isPull: Bool, isTriage: Bool? = nil, isPush: Bool, isMaintain: Bool? = nil) {
            self.isAdmin = isAdmin
            self.isPull = isPull
            self.isTriage = isTriage
            self.isPush = isPush
            self.isMaintain = isMaintain
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
            self.isPull = try values.decode(Bool.self, forKey: "pull")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isAdmin, forKey: "admin")
            try values.encode(isPull, forKey: "pull")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encode(isPush, forKey: "push")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
        }
    }

    public struct TemplateRepository: Codable {
        public var id: Int?
        public var nodeID: String?
        public var name: String?
        public var fullName: String?
        public var owner: Owner?
        public var isPrivate: Bool?
        public var htmlURL: String?
        public var description: String?
        public var isFork: Bool?
        public var url: String?
        public var archiveURL: String?
        public var assigneesURL: String?
        public var blobsURL: String?
        public var branchesURL: String?
        public var collaboratorsURL: String?
        public var commentsURL: String?
        public var commitsURL: String?
        public var compareURL: String?
        public var contentsURL: String?
        public var contributorsURL: String?
        public var deploymentsURL: String?
        public var downloadsURL: String?
        public var eventsURL: String?
        public var forksURL: String?
        public var gitCommitsURL: String?
        public var gitRefsURL: String?
        public var gitTagsURL: String?
        public var gitURL: String?
        public var issueCommentURL: String?
        public var issueEventsURL: String?
        public var issuesURL: String?
        public var keysURL: String?
        public var labelsURL: String?
        public var languagesURL: String?
        public var mergesURL: String?
        public var milestonesURL: String?
        public var notificationsURL: String?
        public var pullsURL: String?
        public var releasesURL: String?
        public var sshURL: String?
        public var stargazersURL: String?
        public var statusesURL: String?
        public var subscribersURL: String?
        public var subscriptionURL: String?
        public var tagsURL: String?
        public var teamsURL: String?
        public var treesURL: String?
        public var cloneURL: String?
        public var mirrorURL: String?
        public var hooksURL: String?
        public var svnURL: String?
        public var homepage: String?
        public var language: String?
        public var forksCount: Int?
        public var stargazersCount: Int?
        public var watchersCount: Int?
        public var size: Int?
        public var defaultBranch: String?
        public var openIssuesCount: Int?
        public var isTemplate: Bool?
        public var topics: [String]?
        public var hasIssues: Bool?
        public var hasProjects: Bool?
        public var hasWiki: Bool?
        public var hasPages: Bool?
        public var hasDownloads: Bool?
        public var isArchived: Bool?
        public var isDisabled: Bool?
        public var visibility: String?
        public var pushedAt: String?
        public var createdAt: String?
        public var updatedAt: String?
        public var permissions: Permissions?
        public var allowRebaseMerge: Bool?
        public var tempCloneToken: String?
        public var allowSquashMerge: Bool?
        public var allowAutoMerge: Bool?
        public var deleteBranchOnMerge: Bool?
        public var allowUpdateBranch: Bool?
        public var allowMergeCommit: Bool?
        public var subscribersCount: Int?
        public var networkCount: Int?

        public struct Owner: Codable {
            public var login: String?
            public var id: Int?
            public var nodeID: String?
            public var avatarURL: String?
            public var gravatarID: String?
            public var url: String?
            public var htmlURL: String?
            public var followersURL: String?
            public var followingURL: String?
            public var gistsURL: String?
            public var starredURL: String?
            public var subscriptionsURL: String?
            public var organizationsURL: String?
            public var reposURL: String?
            public var eventsURL: String?
            public var receivedEventsURL: String?
            public var type: String?
            public var isSiteAdmin: Bool?

            public init(login: String? = nil, id: Int? = nil, nodeID: String? = nil, avatarURL: String? = nil, gravatarID: String? = nil, url: String? = nil, htmlURL: String? = nil, followersURL: String? = nil, followingURL: String? = nil, gistsURL: String? = nil, starredURL: String? = nil, subscriptionsURL: String? = nil, organizationsURL: String? = nil, reposURL: String? = nil, eventsURL: String? = nil, receivedEventsURL: String? = nil, type: String? = nil, isSiteAdmin: Bool? = nil) {
                self.login = login
                self.id = id
                self.nodeID = nodeID
                self.avatarURL = avatarURL
                self.gravatarID = gravatarID
                self.url = url
                self.htmlURL = htmlURL
                self.followersURL = followersURL
                self.followingURL = followingURL
                self.gistsURL = gistsURL
                self.starredURL = starredURL
                self.subscriptionsURL = subscriptionsURL
                self.organizationsURL = organizationsURL
                self.reposURL = reposURL
                self.eventsURL = eventsURL
                self.receivedEventsURL = receivedEventsURL
                self.type = type
                self.isSiteAdmin = isSiteAdmin
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.login = try values.decodeIfPresent(String.self, forKey: "login")
                self.id = try values.decodeIfPresent(Int.self, forKey: "id")
                self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
                self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
                self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
                self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
                self.followersURL = try values.decodeIfPresent(String.self, forKey: "followers_url")
                self.followingURL = try values.decodeIfPresent(String.self, forKey: "following_url")
                self.gistsURL = try values.decodeIfPresent(String.self, forKey: "gists_url")
                self.starredURL = try values.decodeIfPresent(String.self, forKey: "starred_url")
                self.subscriptionsURL = try values.decodeIfPresent(String.self, forKey: "subscriptions_url")
                self.organizationsURL = try values.decodeIfPresent(String.self, forKey: "organizations_url")
                self.reposURL = try values.decodeIfPresent(String.self, forKey: "repos_url")
                self.eventsURL = try values.decodeIfPresent(String.self, forKey: "events_url")
                self.receivedEventsURL = try values.decodeIfPresent(String.self, forKey: "received_events_url")
                self.type = try values.decodeIfPresent(String.self, forKey: "type")
                self.isSiteAdmin = try values.decodeIfPresent(Bool.self, forKey: "site_admin")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(login, forKey: "login")
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(nodeID, forKey: "node_id")
                try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
                try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                try values.encodeIfPresent(url, forKey: "url")
                try values.encodeIfPresent(htmlURL, forKey: "html_url")
                try values.encodeIfPresent(followersURL, forKey: "followers_url")
                try values.encodeIfPresent(followingURL, forKey: "following_url")
                try values.encodeIfPresent(gistsURL, forKey: "gists_url")
                try values.encodeIfPresent(starredURL, forKey: "starred_url")
                try values.encodeIfPresent(subscriptionsURL, forKey: "subscriptions_url")
                try values.encodeIfPresent(organizationsURL, forKey: "organizations_url")
                try values.encodeIfPresent(reposURL, forKey: "repos_url")
                try values.encodeIfPresent(eventsURL, forKey: "events_url")
                try values.encodeIfPresent(receivedEventsURL, forKey: "received_events_url")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(isSiteAdmin, forKey: "site_admin")
            }
        }

        public struct Permissions: Codable {
            public var isAdmin: Bool?
            public var isMaintain: Bool?
            public var isPush: Bool?
            public var isTriage: Bool?
            public var isPull: Bool?

            public init(isAdmin: Bool? = nil, isMaintain: Bool? = nil, isPush: Bool? = nil, isTriage: Bool? = nil, isPull: Bool? = nil) {
                self.isAdmin = isAdmin
                self.isMaintain = isMaintain
                self.isPush = isPush
                self.isTriage = isTriage
                self.isPull = isPull
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isAdmin = try values.decodeIfPresent(Bool.self, forKey: "admin")
                self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
                self.isPush = try values.decodeIfPresent(Bool.self, forKey: "push")
                self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
                self.isPull = try values.decodeIfPresent(Bool.self, forKey: "pull")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(isAdmin, forKey: "admin")
                try values.encodeIfPresent(isMaintain, forKey: "maintain")
                try values.encodeIfPresent(isPush, forKey: "push")
                try values.encodeIfPresent(isTriage, forKey: "triage")
                try values.encodeIfPresent(isPull, forKey: "pull")
            }
        }

        public init(id: Int? = nil, nodeID: String? = nil, name: String? = nil, fullName: String? = nil, owner: Owner? = nil, isPrivate: Bool? = nil, htmlURL: String? = nil, description: String? = nil, isFork: Bool? = nil, url: String? = nil, archiveURL: String? = nil, assigneesURL: String? = nil, blobsURL: String? = nil, branchesURL: String? = nil, collaboratorsURL: String? = nil, commentsURL: String? = nil, commitsURL: String? = nil, compareURL: String? = nil, contentsURL: String? = nil, contributorsURL: String? = nil, deploymentsURL: String? = nil, downloadsURL: String? = nil, eventsURL: String? = nil, forksURL: String? = nil, gitCommitsURL: String? = nil, gitRefsURL: String? = nil, gitTagsURL: String? = nil, gitURL: String? = nil, issueCommentURL: String? = nil, issueEventsURL: String? = nil, issuesURL: String? = nil, keysURL: String? = nil, labelsURL: String? = nil, languagesURL: String? = nil, mergesURL: String? = nil, milestonesURL: String? = nil, notificationsURL: String? = nil, pullsURL: String? = nil, releasesURL: String? = nil, sshURL: String? = nil, stargazersURL: String? = nil, statusesURL: String? = nil, subscribersURL: String? = nil, subscriptionURL: String? = nil, tagsURL: String? = nil, teamsURL: String? = nil, treesURL: String? = nil, cloneURL: String? = nil, mirrorURL: String? = nil, hooksURL: String? = nil, svnURL: String? = nil, homepage: String? = nil, language: String? = nil, forksCount: Int? = nil, stargazersCount: Int? = nil, watchersCount: Int? = nil, size: Int? = nil, defaultBranch: String? = nil, openIssuesCount: Int? = nil, isTemplate: Bool? = nil, topics: [String]? = nil, hasIssues: Bool? = nil, hasProjects: Bool? = nil, hasWiki: Bool? = nil, hasPages: Bool? = nil, hasDownloads: Bool? = nil, isArchived: Bool? = nil, isDisabled: Bool? = nil, visibility: String? = nil, pushedAt: String? = nil, createdAt: String? = nil, updatedAt: String? = nil, permissions: Permissions? = nil, allowRebaseMerge: Bool? = nil, tempCloneToken: String? = nil, allowSquashMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, allowUpdateBranch: Bool? = nil, allowMergeCommit: Bool? = nil, subscribersCount: Int? = nil, networkCount: Int? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.name = name
            self.fullName = fullName
            self.owner = owner
            self.isPrivate = isPrivate
            self.htmlURL = htmlURL
            self.description = description
            self.isFork = isFork
            self.url = url
            self.archiveURL = archiveURL
            self.assigneesURL = assigneesURL
            self.blobsURL = blobsURL
            self.branchesURL = branchesURL
            self.collaboratorsURL = collaboratorsURL
            self.commentsURL = commentsURL
            self.commitsURL = commitsURL
            self.compareURL = compareURL
            self.contentsURL = contentsURL
            self.contributorsURL = contributorsURL
            self.deploymentsURL = deploymentsURL
            self.downloadsURL = downloadsURL
            self.eventsURL = eventsURL
            self.forksURL = forksURL
            self.gitCommitsURL = gitCommitsURL
            self.gitRefsURL = gitRefsURL
            self.gitTagsURL = gitTagsURL
            self.gitURL = gitURL
            self.issueCommentURL = issueCommentURL
            self.issueEventsURL = issueEventsURL
            self.issuesURL = issuesURL
            self.keysURL = keysURL
            self.labelsURL = labelsURL
            self.languagesURL = languagesURL
            self.mergesURL = mergesURL
            self.milestonesURL = milestonesURL
            self.notificationsURL = notificationsURL
            self.pullsURL = pullsURL
            self.releasesURL = releasesURL
            self.sshURL = sshURL
            self.stargazersURL = stargazersURL
            self.statusesURL = statusesURL
            self.subscribersURL = subscribersURL
            self.subscriptionURL = subscriptionURL
            self.tagsURL = tagsURL
            self.teamsURL = teamsURL
            self.treesURL = treesURL
            self.cloneURL = cloneURL
            self.mirrorURL = mirrorURL
            self.hooksURL = hooksURL
            self.svnURL = svnURL
            self.homepage = homepage
            self.language = language
            self.forksCount = forksCount
            self.stargazersCount = stargazersCount
            self.watchersCount = watchersCount
            self.size = size
            self.defaultBranch = defaultBranch
            self.openIssuesCount = openIssuesCount
            self.isTemplate = isTemplate
            self.topics = topics
            self.hasIssues = hasIssues
            self.hasProjects = hasProjects
            self.hasWiki = hasWiki
            self.hasPages = hasPages
            self.hasDownloads = hasDownloads
            self.isArchived = isArchived
            self.isDisabled = isDisabled
            self.visibility = visibility
            self.pushedAt = pushedAt
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.permissions = permissions
            self.allowRebaseMerge = allowRebaseMerge
            self.tempCloneToken = tempCloneToken
            self.allowSquashMerge = allowSquashMerge
            self.allowAutoMerge = allowAutoMerge
            self.deleteBranchOnMerge = deleteBranchOnMerge
            self.allowUpdateBranch = allowUpdateBranch
            self.allowMergeCommit = allowMergeCommit
            self.subscribersCount = subscribersCount
            self.networkCount = networkCount
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.fullName = try values.decodeIfPresent(String.self, forKey: "full_name")
            self.owner = try values.decodeIfPresent(Owner.self, forKey: "owner")
            self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "private")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.isFork = try values.decodeIfPresent(Bool.self, forKey: "fork")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.archiveURL = try values.decodeIfPresent(String.self, forKey: "archive_url")
            self.assigneesURL = try values.decodeIfPresent(String.self, forKey: "assignees_url")
            self.blobsURL = try values.decodeIfPresent(String.self, forKey: "blobs_url")
            self.branchesURL = try values.decodeIfPresent(String.self, forKey: "branches_url")
            self.collaboratorsURL = try values.decodeIfPresent(String.self, forKey: "collaborators_url")
            self.commentsURL = try values.decodeIfPresent(String.self, forKey: "comments_url")
            self.commitsURL = try values.decodeIfPresent(String.self, forKey: "commits_url")
            self.compareURL = try values.decodeIfPresent(String.self, forKey: "compare_url")
            self.contentsURL = try values.decodeIfPresent(String.self, forKey: "contents_url")
            self.contributorsURL = try values.decodeIfPresent(String.self, forKey: "contributors_url")
            self.deploymentsURL = try values.decodeIfPresent(String.self, forKey: "deployments_url")
            self.downloadsURL = try values.decodeIfPresent(String.self, forKey: "downloads_url")
            self.eventsURL = try values.decodeIfPresent(String.self, forKey: "events_url")
            self.forksURL = try values.decodeIfPresent(String.self, forKey: "forks_url")
            self.gitCommitsURL = try values.decodeIfPresent(String.self, forKey: "git_commits_url")
            self.gitRefsURL = try values.decodeIfPresent(String.self, forKey: "git_refs_url")
            self.gitTagsURL = try values.decodeIfPresent(String.self, forKey: "git_tags_url")
            self.gitURL = try values.decodeIfPresent(String.self, forKey: "git_url")
            self.issueCommentURL = try values.decodeIfPresent(String.self, forKey: "issue_comment_url")
            self.issueEventsURL = try values.decodeIfPresent(String.self, forKey: "issue_events_url")
            self.issuesURL = try values.decodeIfPresent(String.self, forKey: "issues_url")
            self.keysURL = try values.decodeIfPresent(String.self, forKey: "keys_url")
            self.labelsURL = try values.decodeIfPresent(String.self, forKey: "labels_url")
            self.languagesURL = try values.decodeIfPresent(String.self, forKey: "languages_url")
            self.mergesURL = try values.decodeIfPresent(String.self, forKey: "merges_url")
            self.milestonesURL = try values.decodeIfPresent(String.self, forKey: "milestones_url")
            self.notificationsURL = try values.decodeIfPresent(String.self, forKey: "notifications_url")
            self.pullsURL = try values.decodeIfPresent(String.self, forKey: "pulls_url")
            self.releasesURL = try values.decodeIfPresent(String.self, forKey: "releases_url")
            self.sshURL = try values.decodeIfPresent(String.self, forKey: "ssh_url")
            self.stargazersURL = try values.decodeIfPresent(String.self, forKey: "stargazers_url")
            self.statusesURL = try values.decodeIfPresent(String.self, forKey: "statuses_url")
            self.subscribersURL = try values.decodeIfPresent(String.self, forKey: "subscribers_url")
            self.subscriptionURL = try values.decodeIfPresent(String.self, forKey: "subscription_url")
            self.tagsURL = try values.decodeIfPresent(String.self, forKey: "tags_url")
            self.teamsURL = try values.decodeIfPresent(String.self, forKey: "teams_url")
            self.treesURL = try values.decodeIfPresent(String.self, forKey: "trees_url")
            self.cloneURL = try values.decodeIfPresent(String.self, forKey: "clone_url")
            self.mirrorURL = try values.decodeIfPresent(String.self, forKey: "mirror_url")
            self.hooksURL = try values.decodeIfPresent(String.self, forKey: "hooks_url")
            self.svnURL = try values.decodeIfPresent(String.self, forKey: "svn_url")
            self.homepage = try values.decodeIfPresent(String.self, forKey: "homepage")
            self.language = try values.decodeIfPresent(String.self, forKey: "language")
            self.forksCount = try values.decodeIfPresent(Int.self, forKey: "forks_count")
            self.stargazersCount = try values.decodeIfPresent(Int.self, forKey: "stargazers_count")
            self.watchersCount = try values.decodeIfPresent(Int.self, forKey: "watchers_count")
            self.size = try values.decodeIfPresent(Int.self, forKey: "size")
            self.defaultBranch = try values.decodeIfPresent(String.self, forKey: "default_branch")
            self.openIssuesCount = try values.decodeIfPresent(Int.self, forKey: "open_issues_count")
            self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
            self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
            self.hasIssues = try values.decodeIfPresent(Bool.self, forKey: "has_issues")
            self.hasProjects = try values.decodeIfPresent(Bool.self, forKey: "has_projects")
            self.hasWiki = try values.decodeIfPresent(Bool.self, forKey: "has_wiki")
            self.hasPages = try values.decodeIfPresent(Bool.self, forKey: "has_pages")
            self.hasDownloads = try values.decodeIfPresent(Bool.self, forKey: "has_downloads")
            self.isArchived = try values.decodeIfPresent(Bool.self, forKey: "archived")
            self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "disabled")
            self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
            self.pushedAt = try values.decodeIfPresent(String.self, forKey: "pushed_at")
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
            self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge")
            self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
            self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge")
            self.allowAutoMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_auto_merge")
            self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge")
            self.allowUpdateBranch = try values.decodeIfPresent(Bool.self, forKey: "allow_update_branch")
            self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit")
            self.subscribersCount = try values.decodeIfPresent(Int.self, forKey: "subscribers_count")
            self.networkCount = try values.decodeIfPresent(Int.self, forKey: "network_count")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(fullName, forKey: "full_name")
            try values.encodeIfPresent(owner, forKey: "owner")
            try values.encodeIfPresent(isPrivate, forKey: "private")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(isFork, forKey: "fork")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(archiveURL, forKey: "archive_url")
            try values.encodeIfPresent(assigneesURL, forKey: "assignees_url")
            try values.encodeIfPresent(blobsURL, forKey: "blobs_url")
            try values.encodeIfPresent(branchesURL, forKey: "branches_url")
            try values.encodeIfPresent(collaboratorsURL, forKey: "collaborators_url")
            try values.encodeIfPresent(commentsURL, forKey: "comments_url")
            try values.encodeIfPresent(commitsURL, forKey: "commits_url")
            try values.encodeIfPresent(compareURL, forKey: "compare_url")
            try values.encodeIfPresent(contentsURL, forKey: "contents_url")
            try values.encodeIfPresent(contributorsURL, forKey: "contributors_url")
            try values.encodeIfPresent(deploymentsURL, forKey: "deployments_url")
            try values.encodeIfPresent(downloadsURL, forKey: "downloads_url")
            try values.encodeIfPresent(eventsURL, forKey: "events_url")
            try values.encodeIfPresent(forksURL, forKey: "forks_url")
            try values.encodeIfPresent(gitCommitsURL, forKey: "git_commits_url")
            try values.encodeIfPresent(gitRefsURL, forKey: "git_refs_url")
            try values.encodeIfPresent(gitTagsURL, forKey: "git_tags_url")
            try values.encodeIfPresent(gitURL, forKey: "git_url")
            try values.encodeIfPresent(issueCommentURL, forKey: "issue_comment_url")
            try values.encodeIfPresent(issueEventsURL, forKey: "issue_events_url")
            try values.encodeIfPresent(issuesURL, forKey: "issues_url")
            try values.encodeIfPresent(keysURL, forKey: "keys_url")
            try values.encodeIfPresent(labelsURL, forKey: "labels_url")
            try values.encodeIfPresent(languagesURL, forKey: "languages_url")
            try values.encodeIfPresent(mergesURL, forKey: "merges_url")
            try values.encodeIfPresent(milestonesURL, forKey: "milestones_url")
            try values.encodeIfPresent(notificationsURL, forKey: "notifications_url")
            try values.encodeIfPresent(pullsURL, forKey: "pulls_url")
            try values.encodeIfPresent(releasesURL, forKey: "releases_url")
            try values.encodeIfPresent(sshURL, forKey: "ssh_url")
            try values.encodeIfPresent(stargazersURL, forKey: "stargazers_url")
            try values.encodeIfPresent(statusesURL, forKey: "statuses_url")
            try values.encodeIfPresent(subscribersURL, forKey: "subscribers_url")
            try values.encodeIfPresent(subscriptionURL, forKey: "subscription_url")
            try values.encodeIfPresent(tagsURL, forKey: "tags_url")
            try values.encodeIfPresent(teamsURL, forKey: "teams_url")
            try values.encodeIfPresent(treesURL, forKey: "trees_url")
            try values.encodeIfPresent(cloneURL, forKey: "clone_url")
            try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
            try values.encodeIfPresent(hooksURL, forKey: "hooks_url")
            try values.encodeIfPresent(svnURL, forKey: "svn_url")
            try values.encodeIfPresent(homepage, forKey: "homepage")
            try values.encodeIfPresent(language, forKey: "language")
            try values.encodeIfPresent(forksCount, forKey: "forks_count")
            try values.encodeIfPresent(stargazersCount, forKey: "stargazers_count")
            try values.encodeIfPresent(watchersCount, forKey: "watchers_count")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(defaultBranch, forKey: "default_branch")
            try values.encodeIfPresent(openIssuesCount, forKey: "open_issues_count")
            try values.encodeIfPresent(isTemplate, forKey: "is_template")
            try values.encodeIfPresent(topics, forKey: "topics")
            try values.encodeIfPresent(hasIssues, forKey: "has_issues")
            try values.encodeIfPresent(hasProjects, forKey: "has_projects")
            try values.encodeIfPresent(hasWiki, forKey: "has_wiki")
            try values.encodeIfPresent(hasPages, forKey: "has_pages")
            try values.encodeIfPresent(hasDownloads, forKey: "has_downloads")
            try values.encodeIfPresent(isArchived, forKey: "archived")
            try values.encodeIfPresent(isDisabled, forKey: "disabled")
            try values.encodeIfPresent(visibility, forKey: "visibility")
            try values.encodeIfPresent(pushedAt, forKey: "pushed_at")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
            try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
            try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
            try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
            try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
            try values.encodeIfPresent(allowUpdateBranch, forKey: "allow_update_branch")
            try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
            try values.encodeIfPresent(subscribersCount, forKey: "subscribers_count")
            try values.encodeIfPresent(networkCount, forKey: "network_count")
        }
    }

    public init(id: Int, nodeID: String, name: String, fullName: String, license: LicenseSimple? = nil, organization: SimpleUser? = nil, forks: Int, permissions: Permissions? = nil, owner: SimpleUser, isPrivate: Bool, htmlURL: URL, description: String? = nil, isFork: Bool, url: URL, archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, downloadsURL: URL, eventsURL: URL, forksURL: URL, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, gitURL: String, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, notificationsURL: String, pullsURL: String, releasesURL: String, sshURL: String, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, cloneURL: String, mirrorURL: URL? = nil, hooksURL: URL, svnURL: URL, homepage: URL? = nil, language: String? = nil, forksCount: Int, stargazersCount: Int, watchersCount: Int, size: Int, defaultBranch: String, openIssuesCount: Int, isTemplate: Bool? = nil, topics: [String]? = nil, hasIssues: Bool, hasProjects: Bool, hasWiki: Bool, hasPages: Bool, hasDownloads: Bool, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, pushedAt: Date? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, allowRebaseMerge: Bool? = nil, templateRepository: TemplateRepository? = nil, tempCloneToken: String? = nil, allowSquashMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowForking: Bool? = nil, subscribersCount: Int? = nil, networkCount: Int? = nil, openIssues: Int, watchers: Int, masterBranch: String? = nil, starredAt: String? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.fullName = fullName
        self.license = license
        self.organization = organization
        self.forks = forks
        self.permissions = permissions
        self.owner = owner
        self.isPrivate = isPrivate
        self.htmlURL = htmlURL
        self.description = description
        self.isFork = isFork
        self.url = url
        self.archiveURL = archiveURL
        self.assigneesURL = assigneesURL
        self.blobsURL = blobsURL
        self.branchesURL = branchesURL
        self.collaboratorsURL = collaboratorsURL
        self.commentsURL = commentsURL
        self.commitsURL = commitsURL
        self.compareURL = compareURL
        self.contentsURL = contentsURL
        self.contributorsURL = contributorsURL
        self.deploymentsURL = deploymentsURL
        self.downloadsURL = downloadsURL
        self.eventsURL = eventsURL
        self.forksURL = forksURL
        self.gitCommitsURL = gitCommitsURL
        self.gitRefsURL = gitRefsURL
        self.gitTagsURL = gitTagsURL
        self.gitURL = gitURL
        self.issueCommentURL = issueCommentURL
        self.issueEventsURL = issueEventsURL
        self.issuesURL = issuesURL
        self.keysURL = keysURL
        self.labelsURL = labelsURL
        self.languagesURL = languagesURL
        self.mergesURL = mergesURL
        self.milestonesURL = milestonesURL
        self.notificationsURL = notificationsURL
        self.pullsURL = pullsURL
        self.releasesURL = releasesURL
        self.sshURL = sshURL
        self.stargazersURL = stargazersURL
        self.statusesURL = statusesURL
        self.subscribersURL = subscribersURL
        self.subscriptionURL = subscriptionURL
        self.tagsURL = tagsURL
        self.teamsURL = teamsURL
        self.treesURL = treesURL
        self.cloneURL = cloneURL
        self.mirrorURL = mirrorURL
        self.hooksURL = hooksURL
        self.svnURL = svnURL
        self.homepage = homepage
        self.language = language
        self.forksCount = forksCount
        self.stargazersCount = stargazersCount
        self.watchersCount = watchersCount
        self.size = size
        self.defaultBranch = defaultBranch
        self.openIssuesCount = openIssuesCount
        self.isTemplate = isTemplate ?? false
        self.topics = topics
        self.hasIssues = hasIssues
        self.hasProjects = hasProjects
        self.hasWiki = hasWiki
        self.hasPages = hasPages
        self.hasDownloads = hasDownloads
        self.isArchived = isArchived
        self.isDisabled = isDisabled
        self.visibility = visibility
        self.pushedAt = pushedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.allowRebaseMerge = allowRebaseMerge ?? true
        self.templateRepository = templateRepository
        self.tempCloneToken = tempCloneToken
        self.allowSquashMerge = allowSquashMerge ?? true
        self.allowAutoMerge = allowAutoMerge ?? false
        self.deleteBranchOnMerge = deleteBranchOnMerge ?? false
        self.allowMergeCommit = allowMergeCommit ?? true
        self.allowForking = allowForking
        self.subscribersCount = subscribersCount
        self.networkCount = networkCount
        self.openIssues = openIssues
        self.watchers = watchers
        self.masterBranch = masterBranch
        self.starredAt = starredAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.fullName = try values.decode(String.self, forKey: "full_name")
        self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
        self.organization = try values.decodeIfPresent(SimpleUser.self, forKey: "organization")
        self.forks = try values.decode(Int.self, forKey: "forks")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.owner = try values.decode(SimpleUser.self, forKey: "owner")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isFork = try values.decode(Bool.self, forKey: "fork")
        self.url = try values.decode(URL.self, forKey: "url")
        self.archiveURL = try values.decode(String.self, forKey: "archive_url")
        self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
        self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
        self.branchesURL = try values.decode(String.self, forKey: "branches_url")
        self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
        self.commentsURL = try values.decode(String.self, forKey: "comments_url")
        self.commitsURL = try values.decode(String.self, forKey: "commits_url")
        self.compareURL = try values.decode(String.self, forKey: "compare_url")
        self.contentsURL = try values.decode(String.self, forKey: "contents_url")
        self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
        self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
        self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
        self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
        self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
        self.gitURL = try values.decode(String.self, forKey: "git_url")
        self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
        self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.keysURL = try values.decode(String.self, forKey: "keys_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
        self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
        self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
        self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
        self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
        self.releasesURL = try values.decode(String.self, forKey: "releases_url")
        self.sshURL = try values.decode(String.self, forKey: "ssh_url")
        self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
        self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
        self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
        self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
        self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.treesURL = try values.decode(String.self, forKey: "trees_url")
        self.cloneURL = try values.decode(String.self, forKey: "clone_url")
        self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
        self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
        self.svnURL = try values.decode(URL.self, forKey: "svn_url")
        self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.forksCount = try values.decode(Int.self, forKey: "forks_count")
        self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
        self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
        self.size = try values.decode(Int.self, forKey: "size")
        self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
        self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
        self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template") ?? false
        self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
        self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
        self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
        self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
        self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
        self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
        self.isArchived = try values.decode(Bool.self, forKey: "archived")
        self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
        self.pushedAt = try values.decodeIfPresent(Date.self, forKey: "pushed_at")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge") ?? true
        self.templateRepository = try values.decodeIfPresent(TemplateRepository.self, forKey: "template_repository")
        self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
        self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge") ?? true
        self.allowAutoMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_auto_merge") ?? false
        self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge") ?? false
        self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit") ?? true
        self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
        self.subscribersCount = try values.decodeIfPresent(Int.self, forKey: "subscribers_count")
        self.networkCount = try values.decodeIfPresent(Int.self, forKey: "network_count")
        self.openIssues = try values.decode(Int.self, forKey: "open_issues")
        self.watchers = try values.decode(Int.self, forKey: "watchers")
        self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
        self.starredAt = try values.decodeIfPresent(String.self, forKey: "starred_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(fullName, forKey: "full_name")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(organization, forKey: "organization")
        try values.encode(forks, forKey: "forks")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encode(owner, forKey: "owner")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isFork, forKey: "fork")
        try values.encode(url, forKey: "url")
        try values.encode(archiveURL, forKey: "archive_url")
        try values.encode(assigneesURL, forKey: "assignees_url")
        try values.encode(blobsURL, forKey: "blobs_url")
        try values.encode(branchesURL, forKey: "branches_url")
        try values.encode(collaboratorsURL, forKey: "collaborators_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(compareURL, forKey: "compare_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encode(contributorsURL, forKey: "contributors_url")
        try values.encode(deploymentsURL, forKey: "deployments_url")
        try values.encode(downloadsURL, forKey: "downloads_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(gitCommitsURL, forKey: "git_commits_url")
        try values.encode(gitRefsURL, forKey: "git_refs_url")
        try values.encode(gitTagsURL, forKey: "git_tags_url")
        try values.encode(gitURL, forKey: "git_url")
        try values.encode(issueCommentURL, forKey: "issue_comment_url")
        try values.encode(issueEventsURL, forKey: "issue_events_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(keysURL, forKey: "keys_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(languagesURL, forKey: "languages_url")
        try values.encode(mergesURL, forKey: "merges_url")
        try values.encode(milestonesURL, forKey: "milestones_url")
        try values.encode(notificationsURL, forKey: "notifications_url")
        try values.encode(pullsURL, forKey: "pulls_url")
        try values.encode(releasesURL, forKey: "releases_url")
        try values.encode(sshURL, forKey: "ssh_url")
        try values.encode(stargazersURL, forKey: "stargazers_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(subscribersURL, forKey: "subscribers_url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
        try values.encode(tagsURL, forKey: "tags_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(treesURL, forKey: "trees_url")
        try values.encode(cloneURL, forKey: "clone_url")
        try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(svnURL, forKey: "svn_url")
        try values.encodeIfPresent(homepage, forKey: "homepage")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encode(forksCount, forKey: "forks_count")
        try values.encode(stargazersCount, forKey: "stargazers_count")
        try values.encode(watchersCount, forKey: "watchers_count")
        try values.encode(size, forKey: "size")
        try values.encode(defaultBranch, forKey: "default_branch")
        try values.encode(openIssuesCount, forKey: "open_issues_count")
        try values.encodeIfPresent(isTemplate, forKey: "is_template")
        try values.encodeIfPresent(topics, forKey: "topics")
        try values.encode(hasIssues, forKey: "has_issues")
        try values.encode(hasProjects, forKey: "has_projects")
        try values.encode(hasWiki, forKey: "has_wiki")
        try values.encode(hasPages, forKey: "has_pages")
        try values.encode(hasDownloads, forKey: "has_downloads")
        try values.encode(isArchived, forKey: "archived")
        try values.encode(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(visibility, forKey: "visibility")
        try values.encodeIfPresent(pushedAt, forKey: "pushed_at")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
        try values.encodeIfPresent(templateRepository, forKey: "template_repository")
        try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
        try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
        try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
        try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
        try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
        try values.encodeIfPresent(allowForking, forKey: "allow_forking")
        try values.encodeIfPresent(subscribersCount, forKey: "subscribers_count")
        try values.encodeIfPresent(networkCount, forKey: "network_count")
        try values.encode(openIssues, forKey: "open_issues")
        try values.encode(watchers, forKey: "watchers")
        try values.encodeIfPresent(masterBranch, forKey: "master_branch")
        try values.encodeIfPresent(starredAt, forKey: "starred_at")
    }
}

/// Authentication token for a GitHub App installed on a user or org.
public struct InstallationToken: Codable {
    public var token: String
    public var expiresAt: String
    /// App Permissions
    ///
    /// The permissions granted to the user-to-server access token.
    ///
    /// Example:
    ///
    /// {
    ///   "contents" : "read",
    ///   "deployments" : "write",
    ///   "issues" : "read",
    ///   "single_file" : "read"
    /// }
    public var permissions: AppPermissions?
    public var repositorySelection: RepositorySelection?
    public var repositories: [Repository]?
    /// Example: "README.md"
    public var singleFile: String?
    /// Example: true
    public var hasMultipleSingleFiles: Bool?
    /// Example: ["config.yml", ".github/issue_TEMPLATE.md"]
    public var singleFilePaths: [String]?

    public enum RepositorySelection: String, Codable, CaseIterable {
        case all
        case selected
    }

    public init(token: String, expiresAt: String, permissions: AppPermissions? = nil, repositorySelection: RepositorySelection? = nil, repositories: [Repository]? = nil, singleFile: String? = nil, hasMultipleSingleFiles: Bool? = nil, singleFilePaths: [String]? = nil) {
        self.token = token
        self.expiresAt = expiresAt
        self.permissions = permissions
        self.repositorySelection = repositorySelection
        self.repositories = repositories
        self.singleFile = singleFile
        self.hasMultipleSingleFiles = hasMultipleSingleFiles
        self.singleFilePaths = singleFilePaths
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.token = try values.decode(String.self, forKey: "token")
        self.expiresAt = try values.decode(String.self, forKey: "expires_at")
        self.permissions = try values.decodeIfPresent(AppPermissions.self, forKey: "permissions")
        self.repositorySelection = try values.decodeIfPresent(RepositorySelection.self, forKey: "repository_selection")
        self.repositories = try values.decodeIfPresent([Repository].self, forKey: "repositories")
        self.singleFile = try values.decodeIfPresent(String.self, forKey: "single_file")
        self.hasMultipleSingleFiles = try values.decodeIfPresent(Bool.self, forKey: "has_multiple_single_files")
        self.singleFilePaths = try values.decodeIfPresent([String].self, forKey: "single_file_paths")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(token, forKey: "token")
        try values.encode(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(repositorySelection, forKey: "repository_selection")
        try values.encodeIfPresent(repositories, forKey: "repositories")
        try values.encodeIfPresent(singleFile, forKey: "single_file")
        try values.encodeIfPresent(hasMultipleSingleFiles, forKey: "has_multiple_single_files")
        try values.encodeIfPresent(singleFilePaths, forKey: "single_file_paths")
    }
}

/// The authorization associated with an OAuth Access.
public struct ApplicationGrant: Codable {
    public var id: Int
    /// Example: "https://api.github.com/applications/grants/1"
    public var url: URL
    public var app: App
    /// Example: "2011-09-06T17:26:27Z"
    public var createdAt: Date
    /// Example: "2011-09-06T20:39:23Z"
    public var updatedAt: Date
    /// Example: ["public_repo"]
    public var scopes: [String]
    /// Simple User
    public var user: SimpleUser?

    public struct App: Codable {
        public var clientID: String
        public var name: String
        public var url: URL

        public init(clientID: String, name: String, url: URL) {
            self.clientID = clientID
            self.name = name
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clientID = try values.decode(String.self, forKey: "client_id")
            self.name = try values.decode(String.self, forKey: "name")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clientID, forKey: "client_id")
            try values.encode(name, forKey: "name")
            try values.encode(url, forKey: "url")
        }
    }

    public init(id: Int, url: URL, app: App, createdAt: Date, updatedAt: Date, scopes: [String], user: SimpleUser? = nil) {
        self.id = id
        self.url = url
        self.app = app
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.scopes = scopes
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.app = try values.decode(App.self, forKey: "app")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.scopes = try values.decode([String].self, forKey: "scopes")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(url, forKey: "url")
        try values.encode(app, forKey: "app")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(scopes, forKey: "scopes")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct ScopedInstallation: Codable {
    /// App Permissions
    ///
    /// The permissions granted to the user-to-server access token.
    ///
    /// Example:
    ///
    /// {
    ///   "contents" : "read",
    ///   "deployments" : "write",
    ///   "issues" : "read",
    ///   "single_file" : "read"
    /// }
    public var permissions: AppPermissions
    /// Describe whether all repositories have been selected or there's a selection involved
    public var repositorySelection: RepositorySelection
    /// Example: "config.yaml"
    public var singleFileName: String?
    /// Example: true
    public var hasMultipleSingleFiles: Bool?
    /// Example: ["config.yml", ".github/issue_TEMPLATE.md"]
    public var singleFilePaths: [String]?
    /// Example: "https://api.github.com/users/octocat/repos"
    public var repositoriesURL: URL
    /// Simple User
    public var account: SimpleUser

    /// Describe whether all repositories have been selected or there's a selection involved
    public enum RepositorySelection: String, Codable, CaseIterable {
        case all
        case selected
    }

    public init(permissions: AppPermissions, repositorySelection: RepositorySelection, singleFileName: String? = nil, hasMultipleSingleFiles: Bool? = nil, singleFilePaths: [String]? = nil, repositoriesURL: URL, account: SimpleUser) {
        self.permissions = permissions
        self.repositorySelection = repositorySelection
        self.singleFileName = singleFileName
        self.hasMultipleSingleFiles = hasMultipleSingleFiles
        self.singleFilePaths = singleFilePaths
        self.repositoriesURL = repositoriesURL
        self.account = account
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.permissions = try values.decode(AppPermissions.self, forKey: "permissions")
        self.repositorySelection = try values.decode(RepositorySelection.self, forKey: "repository_selection")
        self.singleFileName = try values.decodeIfPresent(String.self, forKey: "single_file_name")
        self.hasMultipleSingleFiles = try values.decodeIfPresent(Bool.self, forKey: "has_multiple_single_files")
        self.singleFilePaths = try values.decodeIfPresent([String].self, forKey: "single_file_paths")
        self.repositoriesURL = try values.decode(URL.self, forKey: "repositories_url")
        self.account = try values.decode(SimpleUser.self, forKey: "account")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(permissions, forKey: "permissions")
        try values.encode(repositorySelection, forKey: "repository_selection")
        try values.encodeIfPresent(singleFileName, forKey: "single_file_name")
        try values.encodeIfPresent(hasMultipleSingleFiles, forKey: "has_multiple_single_files")
        try values.encodeIfPresent(singleFilePaths, forKey: "single_file_paths")
        try values.encode(repositoriesURL, forKey: "repositories_url")
        try values.encode(account, forKey: "account")
    }
}

/// The authorization for an OAuth app, GitHub App, or a Personal Access Token.
public struct Authorization: Codable {
    public var id: Int
    public var url: URL
    /// A list of scopes that this authorization is in.
    public var scopes: [String]?
    public var token: String
    public var tokenLastEight: String?
    public var hashedToken: String?
    public var app: App
    public var note: String?
    public var noteURL: URL?
    public var updatedAt: Date
    public var createdAt: Date
    public var fingerprint: String?
    /// Simple User
    public var user: SimpleUser?
    /// Scoped Installation
    public var installation: ScopedInstallation?
    public var expiresAt: Date?

    public struct App: Codable {
        public var clientID: String
        public var name: String
        public var url: URL

        public init(clientID: String, name: String, url: URL) {
            self.clientID = clientID
            self.name = name
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clientID = try values.decode(String.self, forKey: "client_id")
            self.name = try values.decode(String.self, forKey: "name")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clientID, forKey: "client_id")
            try values.encode(name, forKey: "name")
            try values.encode(url, forKey: "url")
        }
    }

    public init(id: Int, url: URL, scopes: [String]? = nil, token: String, tokenLastEight: String? = nil, hashedToken: String? = nil, app: App, note: String? = nil, noteURL: URL? = nil, updatedAt: Date, createdAt: Date, fingerprint: String? = nil, user: SimpleUser? = nil, installation: ScopedInstallation? = nil, expiresAt: Date? = nil) {
        self.id = id
        self.url = url
        self.scopes = scopes
        self.token = token
        self.tokenLastEight = tokenLastEight
        self.hashedToken = hashedToken
        self.app = app
        self.note = note
        self.noteURL = noteURL
        self.updatedAt = updatedAt
        self.createdAt = createdAt
        self.fingerprint = fingerprint
        self.user = user
        self.installation = installation
        self.expiresAt = expiresAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.scopes = try values.decodeIfPresent([String].self, forKey: "scopes")
        self.token = try values.decode(String.self, forKey: "token")
        self.tokenLastEight = try values.decodeIfPresent(String.self, forKey: "token_last_eight")
        self.hashedToken = try values.decodeIfPresent(String.self, forKey: "hashed_token")
        self.app = try values.decode(App.self, forKey: "app")
        self.note = try values.decodeIfPresent(String.self, forKey: "note")
        self.noteURL = try values.decodeIfPresent(URL.self, forKey: "note_url")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.fingerprint = try values.decodeIfPresent(String.self, forKey: "fingerprint")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.installation = try values.decodeIfPresent(ScopedInstallation.self, forKey: "installation")
        self.expiresAt = try values.decodeIfPresent(Date.self, forKey: "expires_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(scopes, forKey: "scopes")
        try values.encode(token, forKey: "token")
        try values.encodeIfPresent(tokenLastEight, forKey: "token_last_eight")
        try values.encodeIfPresent(hashedToken, forKey: "hashed_token")
        try values.encode(app, forKey: "app")
        try values.encodeIfPresent(note, forKey: "note")
        try values.encodeIfPresent(noteURL, forKey: "note_url")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(fingerprint, forKey: "fingerprint")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(installation, forKey: "installation")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
    }
}

public struct CodeOfConduct: Codable {
    /// Example: "contributor_covenant"
    public var key: String
    /// Example: "Contributor Covenant"
    public var name: String
    /// Example: "https://api.github.com/codes_of_conduct/contributor_covenant"
    public var url: URL
    /// Example:
    ///
    /// "# Contributor Covenant Code of Conduct
    /// 
    /// ## Our Pledge
    /// 
    /// In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.
    /// 
    /// ## Our Standards
    /// 
    /// Examples of behavior that contributes to creating a positive environment include:
    /// 
    /// * Using welcoming and inclusive language
    /// * Being respectful of differing viewpoints and experiences
    /// * Gracefully accepting constructive criticism
    /// * Focusing on what is best for the community
    /// * Showing empathy towards other community members
    /// 
    /// Examples of unacceptable behavior by participants include:
    /// 
    /// * The use of sexualized language or imagery and unwelcome sexual attention or advances
    /// * Trolling, insulting/derogatory comments, and personal or political attacks
    /// * Public or private harassment
    /// * Publishing others' private information, such as a physical or electronic address, without explicit permission
    /// * Other conduct which could reasonably be considered inappropriate in a professional setting
    /// 
    /// ## Our Responsibilities
    /// 
    /// Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response
    ///                   to any instances of unacceptable behavior.
    /// 
    /// Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.
    /// 
    /// ## Scope
    /// 
    /// This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address,
    ///                   posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.
    /// 
    /// ## Enforcement
    /// 
    /// Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [EMAIL]. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.
    /// 
    /// Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.
    /// 
    /// ## Attribution
    /// 
    /// This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]
    /// 
    /// [homepage]: http://contributor-covenant.org
    /// [version]: http://contributor-covenant.org/version/1/4/
    /// "
    public var body: String?
    public var htmlURL: URL?

    public init(key: String, name: String, url: URL, body: String? = nil, htmlURL: URL? = nil) {
        self.key = key
        self.name = name
        self.url = url
        self.body = body
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.key = try values.decode(String.self, forKey: "key")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decode(URL.self, forKey: "url")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(key, forKey: "key")
        try values.encode(name, forKey: "name")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
    }
}

/// The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
public enum EnabledOrganizations: String, Codable, CaseIterable {
    case all
    case `none`
    case selected
}

/// The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
public enum AllowedActions: String, Codable, CaseIterable {
    case all
    case localOnly = "local_only"
    case selected
}

public struct ActionsEnterprisePermissions: Codable {
    /// The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
    public var enabledOrganizations: EnabledOrganizations
    /// The API URL to use to get or set the selected organizations that are allowed to run GitHub Actions, when `enabled_organizations` is set to `selected`.
    public var selectedOrganizationsURL: String?
    /// The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
    public var allowedActions: AllowedActions?
    /// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
    public var selectedActionsURL: String?

    public init(enabledOrganizations: EnabledOrganizations, selectedOrganizationsURL: String? = nil, allowedActions: AllowedActions? = nil, selectedActionsURL: String? = nil) {
        self.enabledOrganizations = enabledOrganizations
        self.selectedOrganizationsURL = selectedOrganizationsURL
        self.allowedActions = allowedActions
        self.selectedActionsURL = selectedActionsURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.enabledOrganizations = try values.decode(EnabledOrganizations.self, forKey: "enabled_organizations")
        self.selectedOrganizationsURL = try values.decodeIfPresent(String.self, forKey: "selected_organizations_url")
        self.allowedActions = try values.decodeIfPresent(AllowedActions.self, forKey: "allowed_actions")
        self.selectedActionsURL = try values.decodeIfPresent(String.self, forKey: "selected_actions_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(enabledOrganizations, forKey: "enabled_organizations")
        try values.encodeIfPresent(selectedOrganizationsURL, forKey: "selected_organizations_url")
        try values.encodeIfPresent(allowedActions, forKey: "allowed_actions")
        try values.encodeIfPresent(selectedActionsURL, forKey: "selected_actions_url")
    }
}

public struct OrganizationSimple: Codable {
    /// Example: "github"
    public var login: String
    public var id: Int
    /// Example: "MDEyOk9yZ2FuaXphdGlvbjE="
    public var nodeID: String
    /// Example: "https://api.github.com/orgs/github"
    public var url: URL
    /// Example: "https://api.github.com/orgs/github/repos"
    public var reposURL: URL
    /// Example: "https://api.github.com/orgs/github/events"
    public var eventsURL: URL
    /// Example: "https://api.github.com/orgs/github/hooks"
    public var hooksURL: String
    /// Example: "https://api.github.com/orgs/github/issues"
    public var issuesURL: String
    /// Example: "https://api.github.com/orgs/github/members{/member}"
    public var membersURL: String
    /// Example: "https://api.github.com/orgs/github/public_members{/member}"
    public var publicMembersURL: String
    /// Example: "https://github.com/images/error/octocat_happy.gif"
    public var avatarURL: String
    /// Example: "A great organization"
    public var description: String?

    public init(login: String, id: Int, nodeID: String, url: URL, reposURL: URL, eventsURL: URL, hooksURL: String, issuesURL: String, membersURL: String, publicMembersURL: String, avatarURL: String, description: String? = nil) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.hooksURL = hooksURL
        self.issuesURL = issuesURL
        self.membersURL = membersURL
        self.publicMembersURL = publicMembersURL
        self.avatarURL = avatarURL
        self.description = description
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.hooksURL = try values.decode(String.self, forKey: "hooks_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.membersURL = try values.decode(String.self, forKey: "members_url")
        self.publicMembersURL = try values.decode(String.self, forKey: "public_members_url")
        self.avatarURL = try values.decode(String.self, forKey: "avatar_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(membersURL, forKey: "members_url")
        try values.encode(publicMembersURL, forKey: "public_members_url")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(description, forKey: "description")
    }
}

public struct SelectedActions: Codable {
    /// Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.
    public var isGithubOwnedAllowed: Bool?
    /// Whether actions in GitHub Marketplace from verified creators are allowed. Set to `true` to allow all GitHub Marketplace actions by verified creators.
    public var isVerifiedAllowed: Bool?
    /// Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."
    public var patternsAllowed: [String]?

    public init(isGithubOwnedAllowed: Bool? = nil, isVerifiedAllowed: Bool? = nil, patternsAllowed: [String]? = nil) {
        self.isGithubOwnedAllowed = isGithubOwnedAllowed
        self.isVerifiedAllowed = isVerifiedAllowed
        self.patternsAllowed = patternsAllowed
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isGithubOwnedAllowed = try values.decodeIfPresent(Bool.self, forKey: "github_owned_allowed")
        self.isVerifiedAllowed = try values.decodeIfPresent(Bool.self, forKey: "verified_allowed")
        self.patternsAllowed = try values.decodeIfPresent([String].self, forKey: "patterns_allowed")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(isGithubOwnedAllowed, forKey: "github_owned_allowed")
        try values.encodeIfPresent(isVerifiedAllowed, forKey: "verified_allowed")
        try values.encodeIfPresent(patternsAllowed, forKey: "patterns_allowed")
    }
}

public struct RunnerGroupsEnterprise: Codable {
    public var id: Double
    public var name: String
    public var visibility: String
    public var isDefault: Bool
    public var selectedOrganizationsURL: String?
    public var runnersURL: String
    public var allowsPublicRepositories: Bool

    public init(id: Double, name: String, visibility: String, isDefault: Bool, selectedOrganizationsURL: String? = nil, runnersURL: String, allowsPublicRepositories: Bool) {
        self.id = id
        self.name = name
        self.visibility = visibility
        self.isDefault = isDefault
        self.selectedOrganizationsURL = selectedOrganizationsURL
        self.runnersURL = runnersURL
        self.allowsPublicRepositories = allowsPublicRepositories
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Double.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.visibility = try values.decode(String.self, forKey: "visibility")
        self.isDefault = try values.decode(Bool.self, forKey: "default")
        self.selectedOrganizationsURL = try values.decodeIfPresent(String.self, forKey: "selected_organizations_url")
        self.runnersURL = try values.decode(String.self, forKey: "runners_url")
        self.allowsPublicRepositories = try values.decode(Bool.self, forKey: "allows_public_repositories")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(visibility, forKey: "visibility")
        try values.encode(isDefault, forKey: "default")
        try values.encodeIfPresent(selectedOrganizationsURL, forKey: "selected_organizations_url")
        try values.encode(runnersURL, forKey: "runners_url")
        try values.encode(allowsPublicRepositories, forKey: "allows_public_repositories")
    }
}

/// Self hosted runner label
///
/// A label for a self hosted runner
public struct RunnerLabel: Codable {
    /// Unique identifier of the label.
    public var id: Int?
    /// Name of the label.
    public var name: String
    /// The type of label. Read-only labels are applied automatically when the runner is configured.
    public var type: `Type`?

    /// The type of label. Read-only labels are applied automatically when the runner is configured.
    public enum `Type`: String, Codable, CaseIterable {
        case readOnly = "read-only"
        case custom
    }

    public init(id: Int? = nil, name: String, type: `Type`? = nil) {
        self.id = id
        self.name = name
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// Self hosted runners
///
/// A self hosted runner
public struct Runner: Codable {
    /// The id of the runner.
    public var id: Int
    /// The name of the runner.
    ///
    /// Example: "iMac"
    public var name: String
    /// The Operating System of the runner.
    ///
    /// Example: "macos"
    public var os: String
    /// The status of the runner.
    ///
    /// Example: "online"
    public var status: String
    public var isBusy: Bool
    public var labels: [RunnerLabel]

    public init(id: Int, name: String, os: String, status: String, isBusy: Bool, labels: [RunnerLabel]) {
        self.id = id
        self.name = name
        self.os = os
        self.status = status
        self.isBusy = isBusy
        self.labels = labels
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.os = try values.decode(String.self, forKey: "os")
        self.status = try values.decode(String.self, forKey: "status")
        self.isBusy = try values.decode(Bool.self, forKey: "busy")
        self.labels = try values.decode([RunnerLabel].self, forKey: "labels")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(os, forKey: "os")
        try values.encode(status, forKey: "status")
        try values.encode(isBusy, forKey: "busy")
        try values.encode(labels, forKey: "labels")
    }
}

public struct RunnerApplication: Codable {
    public var os: String
    public var architecture: String
    public var downloadURL: String
    public var filename: String
    /// A short lived bearer token used to download the runner, if needed.
    public var tempDownloadToken: String?
    public var sha256Checksum: String?

    public init(os: String, architecture: String, downloadURL: String, filename: String, tempDownloadToken: String? = nil, sha256Checksum: String? = nil) {
        self.os = os
        self.architecture = architecture
        self.downloadURL = downloadURL
        self.filename = filename
        self.tempDownloadToken = tempDownloadToken
        self.sha256Checksum = sha256Checksum
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.os = try values.decode(String.self, forKey: "os")
        self.architecture = try values.decode(String.self, forKey: "architecture")
        self.downloadURL = try values.decode(String.self, forKey: "download_url")
        self.filename = try values.decode(String.self, forKey: "filename")
        self.tempDownloadToken = try values.decodeIfPresent(String.self, forKey: "temp_download_token")
        self.sha256Checksum = try values.decodeIfPresent(String.self, forKey: "sha256_checksum")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(os, forKey: "os")
        try values.encode(architecture, forKey: "architecture")
        try values.encode(downloadURL, forKey: "download_url")
        try values.encode(filename, forKey: "filename")
        try values.encodeIfPresent(tempDownloadToken, forKey: "temp_download_token")
        try values.encodeIfPresent(sha256Checksum, forKey: "sha256_checksum")
    }
}

public struct AuthenticationToken: Codable {
    /// The token used for authentication
    ///
    /// Example: "v1.1f699f1069f60xxx"
    public var token: String
    /// The time this token expires
    ///
    /// Example: "2016-07-11T22:14:10Z"
    public var expiresAt: Date
    /// Example:
    ///
    /// {
    ///   "deployments" : "write",
    ///   "issues" : "read"
    /// }
    public var permissions: [String: AnyJSON]?
    /// The repositories this token has access to
    public var repositories: [Repository]?
    /// Example: "config.yaml"
    public var singleFile: String?
    /// Describe whether all repositories have been selected or there's a selection involved
    public var repositorySelection: RepositorySelection?

    /// Describe whether all repositories have been selected or there's a selection involved
    public enum RepositorySelection: String, Codable, CaseIterable {
        case all
        case selected
    }

    public init(token: String, expiresAt: Date, permissions: [String: AnyJSON]? = nil, repositories: [Repository]? = nil, singleFile: String? = nil, repositorySelection: RepositorySelection? = nil) {
        self.token = token
        self.expiresAt = expiresAt
        self.permissions = permissions
        self.repositories = repositories
        self.singleFile = singleFile
        self.repositorySelection = repositorySelection
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.token = try values.decode(String.self, forKey: "token")
        self.expiresAt = try values.decode(Date.self, forKey: "expires_at")
        self.permissions = try values.decodeIfPresent([String: AnyJSON].self, forKey: "permissions")
        self.repositories = try values.decodeIfPresent([Repository].self, forKey: "repositories")
        self.singleFile = try values.decodeIfPresent(String.self, forKey: "single_file")
        self.repositorySelection = try values.decodeIfPresent(RepositorySelection.self, forKey: "repository_selection")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(token, forKey: "token")
        try values.encode(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(repositories, forKey: "repositories")
        try values.encodeIfPresent(singleFile, forKey: "single_file")
        try values.encodeIfPresent(repositorySelection, forKey: "repository_selection")
    }
}

public struct AuditLogEvent: Codable {
    /// The time the audit log event occurred, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
    public var timestamp: Int?
    /// The name of the action that was performed, for example `user.login` or `repo.create`.
    public var action: String?
    public var isActive: Bool?
    public var activeWas: Bool?
    /// The actor who performed the action.
    public var actor: String?
    /// The id of the actor who performed the action.
    public var actorID: Int?
    public var actorLocation: ActorLocation?
    public var data: [String: AnyJSON]?
    public var orgID: Int?
    /// The username of the account being blocked.
    public var blockedUser: String?
    public var business: String?
    public var config: [[String: AnyJSON]]?
    public var configWas: [[String: AnyJSON]]?
    public var contentType: String?
    /// The time the audit log event was recorded, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
    public var createdAt: Int?
    public var deployKeyFingerprint: String?
    /// A unique identifier for an audit event.
    public var documentID: String?
    public var emoji: String?
    public var events: [[String: AnyJSON]]?
    public var eventsWere: [[String: AnyJSON]]?
    public var explanation: String?
    public var fingerprint: String?
    public var hookID: Int?
    public var isLimitedAvailability: Bool?
    public var message: String?
    public var name: String?
    public var oldUser: String?
    public var opensshPublicKey: String?
    public var org: String?
    public var previousVisibility: String?
    public var isReadOnly: Bool?
    /// The name of the repository.
    public var repo: String?
    /// The name of the repository.
    public var repository: String?
    public var isRepositoryPublic: Bool?
    public var targetLogin: String?
    public var team: String?
    /// The type of protocol (for example, HTTP or SSH) used to transfer Git data.
    public var transportProtocol: Int?
    /// A human readable name for the protocol (for example, HTTP or SSH) used to transfer Git data.
    public var transportProtocolName: String?
    /// The user that was affected by the action performed (if available).
    public var user: String?
    /// The repository visibility, for example `public` or `private`.
    public var visibility: String?

    public struct ActorLocation: Codable {
        public var countryName: String?

        public init(countryName: String? = nil) {
            self.countryName = countryName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.countryName = try values.decodeIfPresent(String.self, forKey: "country_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(countryName, forKey: "country_name")
        }
    }

    public init(timestamp: Int? = nil, action: String? = nil, isActive: Bool? = nil, activeWas: Bool? = nil, actor: String? = nil, actorID: Int? = nil, actorLocation: ActorLocation? = nil, data: [String: AnyJSON]? = nil, orgID: Int? = nil, blockedUser: String? = nil, business: String? = nil, config: [[String: AnyJSON]]? = nil, configWas: [[String: AnyJSON]]? = nil, contentType: String? = nil, createdAt: Int? = nil, deployKeyFingerprint: String? = nil, documentID: String? = nil, emoji: String? = nil, events: [[String: AnyJSON]]? = nil, eventsWere: [[String: AnyJSON]]? = nil, explanation: String? = nil, fingerprint: String? = nil, hookID: Int? = nil, isLimitedAvailability: Bool? = nil, message: String? = nil, name: String? = nil, oldUser: String? = nil, opensshPublicKey: String? = nil, org: String? = nil, previousVisibility: String? = nil, isReadOnly: Bool? = nil, repo: String? = nil, repository: String? = nil, isRepositoryPublic: Bool? = nil, targetLogin: String? = nil, team: String? = nil, transportProtocol: Int? = nil, transportProtocolName: String? = nil, user: String? = nil, visibility: String? = nil) {
        self.timestamp = timestamp
        self.action = action
        self.isActive = isActive
        self.activeWas = activeWas
        self.actor = actor
        self.actorID = actorID
        self.actorLocation = actorLocation
        self.data = data
        self.orgID = orgID
        self.blockedUser = blockedUser
        self.business = business
        self.config = config
        self.configWas = configWas
        self.contentType = contentType
        self.createdAt = createdAt
        self.deployKeyFingerprint = deployKeyFingerprint
        self.documentID = documentID
        self.emoji = emoji
        self.events = events
        self.eventsWere = eventsWere
        self.explanation = explanation
        self.fingerprint = fingerprint
        self.hookID = hookID
        self.isLimitedAvailability = isLimitedAvailability
        self.message = message
        self.name = name
        self.oldUser = oldUser
        self.opensshPublicKey = opensshPublicKey
        self.org = org
        self.previousVisibility = previousVisibility
        self.isReadOnly = isReadOnly
        self.repo = repo
        self.repository = repository
        self.isRepositoryPublic = isRepositoryPublic
        self.targetLogin = targetLogin
        self.team = team
        self.transportProtocol = transportProtocol
        self.transportProtocolName = transportProtocolName
        self.user = user
        self.visibility = visibility
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamp = try values.decodeIfPresent(Int.self, forKey: "@timestamp")
        self.action = try values.decodeIfPresent(String.self, forKey: "action")
        self.isActive = try values.decodeIfPresent(Bool.self, forKey: "active")
        self.activeWas = try values.decodeIfPresent(Bool.self, forKey: "active_was")
        self.actor = try values.decodeIfPresent(String.self, forKey: "actor")
        self.actorID = try values.decodeIfPresent(Int.self, forKey: "actor_id")
        self.actorLocation = try values.decodeIfPresent(ActorLocation.self, forKey: "actor_location")
        self.data = try values.decodeIfPresent([String: AnyJSON].self, forKey: "data")
        self.orgID = try values.decodeIfPresent(Int.self, forKey: "org_id")
        self.blockedUser = try values.decodeIfPresent(String.self, forKey: "blocked_user")
        self.business = try values.decodeIfPresent(String.self, forKey: "business")
        self.config = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "config")
        self.configWas = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "config_was")
        self.contentType = try values.decodeIfPresent(String.self, forKey: "content_type")
        self.createdAt = try values.decodeIfPresent(Int.self, forKey: "created_at")
        self.deployKeyFingerprint = try values.decodeIfPresent(String.self, forKey: "deploy_key_fingerprint")
        self.documentID = try values.decodeIfPresent(String.self, forKey: "_document_id")
        self.emoji = try values.decodeIfPresent(String.self, forKey: "emoji")
        self.events = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "events")
        self.eventsWere = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "events_were")
        self.explanation = try values.decodeIfPresent(String.self, forKey: "explanation")
        self.fingerprint = try values.decodeIfPresent(String.self, forKey: "fingerprint")
        self.hookID = try values.decodeIfPresent(Int.self, forKey: "hook_id")
        self.isLimitedAvailability = try values.decodeIfPresent(Bool.self, forKey: "limited_availability")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.oldUser = try values.decodeIfPresent(String.self, forKey: "old_user")
        self.opensshPublicKey = try values.decodeIfPresent(String.self, forKey: "openssh_public_key")
        self.org = try values.decodeIfPresent(String.self, forKey: "org")
        self.previousVisibility = try values.decodeIfPresent(String.self, forKey: "previous_visibility")
        self.isReadOnly = try values.decodeIfPresent(Bool.self, forKey: "read_only")
        self.repo = try values.decodeIfPresent(String.self, forKey: "repo")
        self.repository = try values.decodeIfPresent(String.self, forKey: "repository")
        self.isRepositoryPublic = try values.decodeIfPresent(Bool.self, forKey: "repository_public")
        self.targetLogin = try values.decodeIfPresent(String.self, forKey: "target_login")
        self.team = try values.decodeIfPresent(String.self, forKey: "team")
        self.transportProtocol = try values.decodeIfPresent(Int.self, forKey: "transport_protocol")
        self.transportProtocolName = try values.decodeIfPresent(String.self, forKey: "transport_protocol_name")
        self.user = try values.decodeIfPresent(String.self, forKey: "user")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(timestamp, forKey: "@timestamp")
        try values.encodeIfPresent(action, forKey: "action")
        try values.encodeIfPresent(isActive, forKey: "active")
        try values.encodeIfPresent(activeWas, forKey: "active_was")
        try values.encodeIfPresent(actor, forKey: "actor")
        try values.encodeIfPresent(actorID, forKey: "actor_id")
        try values.encodeIfPresent(actorLocation, forKey: "actor_location")
        try values.encodeIfPresent(data, forKey: "data")
        try values.encodeIfPresent(orgID, forKey: "org_id")
        try values.encodeIfPresent(blockedUser, forKey: "blocked_user")
        try values.encodeIfPresent(business, forKey: "business")
        try values.encodeIfPresent(config, forKey: "config")
        try values.encodeIfPresent(configWas, forKey: "config_was")
        try values.encodeIfPresent(contentType, forKey: "content_type")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(deployKeyFingerprint, forKey: "deploy_key_fingerprint")
        try values.encodeIfPresent(documentID, forKey: "_document_id")
        try values.encodeIfPresent(emoji, forKey: "emoji")
        try values.encodeIfPresent(events, forKey: "events")
        try values.encodeIfPresent(eventsWere, forKey: "events_were")
        try values.encodeIfPresent(explanation, forKey: "explanation")
        try values.encodeIfPresent(fingerprint, forKey: "fingerprint")
        try values.encodeIfPresent(hookID, forKey: "hook_id")
        try values.encodeIfPresent(isLimitedAvailability, forKey: "limited_availability")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(oldUser, forKey: "old_user")
        try values.encodeIfPresent(opensshPublicKey, forKey: "openssh_public_key")
        try values.encodeIfPresent(org, forKey: "org")
        try values.encodeIfPresent(previousVisibility, forKey: "previous_visibility")
        try values.encodeIfPresent(isReadOnly, forKey: "read_only")
        try values.encodeIfPresent(repo, forKey: "repo")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encodeIfPresent(isRepositoryPublic, forKey: "repository_public")
        try values.encodeIfPresent(targetLogin, forKey: "target_login")
        try values.encodeIfPresent(team, forKey: "team")
        try values.encodeIfPresent(transportProtocol, forKey: "transport_protocol")
        try values.encodeIfPresent(transportProtocolName, forKey: "transport_protocol_name")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(visibility, forKey: "visibility")
    }
}

public struct ActionsBillingUsage: Codable {
    /// The sum of the free and paid GitHub Actions minutes used.
    public var totalMinutesUsed: Int
    /// The total paid GitHub Actions minutes used.
    public var totalPaidMinutesUsed: Int
    /// The amount of free GitHub Actions minutes available.
    public var includedMinutes: Int
    public var minutesUsedBreakdown: MinutesUsedBreakdown

    public struct MinutesUsedBreakdown: Codable {
        /// Total minutes used on Ubuntu runner machines.
        public var ubuntu: Int?
        /// Total minutes used on macOS runner machines.
        public var macos: Int?
        /// Total minutes used on Windows runner machines.
        public var windows: Int?

        public init(ubuntu: Int? = nil, macos: Int? = nil, windows: Int? = nil) {
            self.ubuntu = ubuntu
            self.macos = macos
            self.windows = windows
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ubuntu = try values.decodeIfPresent(Int.self, forKey: "UBUNTU")
            self.macos = try values.decodeIfPresent(Int.self, forKey: "MACOS")
            self.windows = try values.decodeIfPresent(Int.self, forKey: "WINDOWS")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(ubuntu, forKey: "UBUNTU")
            try values.encodeIfPresent(macos, forKey: "MACOS")
            try values.encodeIfPresent(windows, forKey: "WINDOWS")
        }
    }

    public init(totalMinutesUsed: Int, totalPaidMinutesUsed: Int, includedMinutes: Int, minutesUsedBreakdown: MinutesUsedBreakdown) {
        self.totalMinutesUsed = totalMinutesUsed
        self.totalPaidMinutesUsed = totalPaidMinutesUsed
        self.includedMinutes = includedMinutes
        self.minutesUsedBreakdown = minutesUsedBreakdown
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalMinutesUsed = try values.decode(Int.self, forKey: "total_minutes_used")
        self.totalPaidMinutesUsed = try values.decode(Int.self, forKey: "total_paid_minutes_used")
        self.includedMinutes = try values.decode(Int.self, forKey: "included_minutes")
        self.minutesUsedBreakdown = try values.decode(MinutesUsedBreakdown.self, forKey: "minutes_used_breakdown")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(totalMinutesUsed, forKey: "total_minutes_used")
        try values.encode(totalPaidMinutesUsed, forKey: "total_paid_minutes_used")
        try values.encode(includedMinutes, forKey: "included_minutes")
        try values.encode(minutesUsedBreakdown, forKey: "minutes_used_breakdown")
    }
}

public struct AdvancedSecurityActiveCommittersUser: Codable {
    public var userLogin: String
    /// Example: "2021-11-03"
    public var lastPushedDate: String

    public init(userLogin: String, lastPushedDate: String) {
        self.userLogin = userLogin
        self.lastPushedDate = lastPushedDate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.userLogin = try values.decode(String.self, forKey: "user_login")
        self.lastPushedDate = try values.decode(String.self, forKey: "last_pushed_date")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(userLogin, forKey: "user_login")
        try values.encode(lastPushedDate, forKey: "last_pushed_date")
    }
}

public struct AdvancedSecurityActiveCommittersRepository: Codable {
    /// Example: "octocat/Hello-World"
    public var name: String
    /// Example: 25
    public var advancedSecurityCommitters: Int
    public var advancedSecurityCommittersBreakdown: [AdvancedSecurityActiveCommittersUser]

    public init(name: String, advancedSecurityCommitters: Int, advancedSecurityCommittersBreakdown: [AdvancedSecurityActiveCommittersUser]) {
        self.name = name
        self.advancedSecurityCommitters = advancedSecurityCommitters
        self.advancedSecurityCommittersBreakdown = advancedSecurityCommittersBreakdown
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.advancedSecurityCommitters = try values.decode(Int.self, forKey: "advanced_security_committers")
        self.advancedSecurityCommittersBreakdown = try values.decode([AdvancedSecurityActiveCommittersUser].self, forKey: "advanced_security_committers_breakdown")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(advancedSecurityCommitters, forKey: "advanced_security_committers")
        try values.encode(advancedSecurityCommittersBreakdown, forKey: "advanced_security_committers_breakdown")
    }
}

public struct AdvancedSecurityActiveCommitters: Codable {
    /// Example: 25
    public var totalAdvancedSecurityCommitters: Int?
    public var repositories: [AdvancedSecurityActiveCommittersRepository]

    public init(totalAdvancedSecurityCommitters: Int? = nil, repositories: [AdvancedSecurityActiveCommittersRepository]) {
        self.totalAdvancedSecurityCommitters = totalAdvancedSecurityCommitters
        self.repositories = repositories
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalAdvancedSecurityCommitters = try values.decodeIfPresent(Int.self, forKey: "total_advanced_security_committers")
        self.repositories = try values.decode([AdvancedSecurityActiveCommittersRepository].self, forKey: "repositories")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalAdvancedSecurityCommitters, forKey: "total_advanced_security_committers")
        try values.encode(repositories, forKey: "repositories")
    }
}

public struct PackagesBillingUsage: Codable {
    /// Sum of the free and paid storage space (GB) for GitHuub Packages.
    public var totalGigabytesBandwidthUsed: Int
    /// Total paid storage space (GB) for GitHuub Packages.
    public var totalPaidGigabytesBandwidthUsed: Int
    /// Free storage space (GB) for GitHub Packages.
    public var includedGigabytesBandwidth: Int

    public init(totalGigabytesBandwidthUsed: Int, totalPaidGigabytesBandwidthUsed: Int, includedGigabytesBandwidth: Int) {
        self.totalGigabytesBandwidthUsed = totalGigabytesBandwidthUsed
        self.totalPaidGigabytesBandwidthUsed = totalPaidGigabytesBandwidthUsed
        self.includedGigabytesBandwidth = includedGigabytesBandwidth
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalGigabytesBandwidthUsed = try values.decode(Int.self, forKey: "total_gigabytes_bandwidth_used")
        self.totalPaidGigabytesBandwidthUsed = try values.decode(Int.self, forKey: "total_paid_gigabytes_bandwidth_used")
        self.includedGigabytesBandwidth = try values.decode(Int.self, forKey: "included_gigabytes_bandwidth")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(totalGigabytesBandwidthUsed, forKey: "total_gigabytes_bandwidth_used")
        try values.encode(totalPaidGigabytesBandwidthUsed, forKey: "total_paid_gigabytes_bandwidth_used")
        try values.encode(includedGigabytesBandwidth, forKey: "included_gigabytes_bandwidth")
    }
}

public struct CombinedBillingUsage: Codable {
    /// Numbers of days left in billing cycle.
    public var daysLeftInBillingCycle: Int
    /// Estimated storage space (GB) used in billing cycle.
    public var estimatedPaidStorageForMonth: Int
    /// Estimated sum of free and paid storage space (GB) used in billing cycle.
    public var estimatedStorageForMonth: Int

    public init(daysLeftInBillingCycle: Int, estimatedPaidStorageForMonth: Int, estimatedStorageForMonth: Int) {
        self.daysLeftInBillingCycle = daysLeftInBillingCycle
        self.estimatedPaidStorageForMonth = estimatedPaidStorageForMonth
        self.estimatedStorageForMonth = estimatedStorageForMonth
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.daysLeftInBillingCycle = try values.decode(Int.self, forKey: "days_left_in_billing_cycle")
        self.estimatedPaidStorageForMonth = try values.decode(Int.self, forKey: "estimated_paid_storage_for_month")
        self.estimatedStorageForMonth = try values.decode(Int.self, forKey: "estimated_storage_for_month")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(daysLeftInBillingCycle, forKey: "days_left_in_billing_cycle")
        try values.encode(estimatedPaidStorageForMonth, forKey: "estimated_paid_storage_for_month")
        try values.encode(estimatedStorageForMonth, forKey: "estimated_storage_for_month")
    }
}

public struct Actor: Codable {
    public var id: Int
    public var login: String
    public var displayLogin: String?
    public var gravatarID: String?
    public var url: URL
    public var avatarURL: URL

    public init(id: Int, login: String, displayLogin: String? = nil, gravatarID: String? = nil, url: URL, avatarURL: URL) {
        self.id = id
        self.login = login
        self.displayLogin = displayLogin
        self.gravatarID = gravatarID
        self.url = url
        self.avatarURL = avatarURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.login = try values.decode(String.self, forKey: "login")
        self.displayLogin = try values.decodeIfPresent(String.self, forKey: "display_login")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(login, forKey: "login")
        try values.encodeIfPresent(displayLogin, forKey: "display_login")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(avatarURL, forKey: "avatar_url")
    }
}

/// Author_association
///
/// How the author is associated with the repository.
///
/// Example: "OWNER"
public enum AuthorAssociation: String, Codable, CaseIterable {
    case collaborator = "COLLABORATOR"
    case contributor = "CONTRIBUTOR"
    case firstTimer = "FIRST_TIMER"
    case firstTimeContributor = "FIRST_TIME_CONTRIBUTOR"
    case mannequin = "MANNEQUIN"
    case member = "MEMBER"
    case `none` = "NONE"
    case owner = "OWNER"
}

public struct ReactionRollup: Codable {
    public var url: URL
    public var totalCount: Int
    public var plus1: Int
    public var minus1: Int
    public var laugh: Int
    public var confused: Int
    public var heart: Int
    public var hooray: Int
    public var eyes: Int
    public var rocket: Int

    public init(url: URL, totalCount: Int, plus1: Int, minus1: Int, laugh: Int, confused: Int, heart: Int, hooray: Int, eyes: Int, rocket: Int) {
        self.url = url
        self.totalCount = totalCount
        self.plus1 = plus1
        self.minus1 = minus1
        self.laugh = laugh
        self.confused = confused
        self.heart = heart
        self.hooray = hooray
        self.eyes = eyes
        self.rocket = rocket
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.totalCount = try values.decode(Int.self, forKey: "total_count")
        self.plus1 = try values.decode(Int.self, forKey: "+1")
        self.minus1 = try values.decode(Int.self, forKey: "-1")
        self.laugh = try values.decode(Int.self, forKey: "laugh")
        self.confused = try values.decode(Int.self, forKey: "confused")
        self.heart = try values.decode(Int.self, forKey: "heart")
        self.hooray = try values.decode(Int.self, forKey: "hooray")
        self.eyes = try values.decode(Int.self, forKey: "eyes")
        self.rocket = try values.decode(Int.self, forKey: "rocket")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(totalCount, forKey: "total_count")
        try values.encode(plus1, forKey: "+1")
        try values.encode(minus1, forKey: "-1")
        try values.encode(laugh, forKey: "laugh")
        try values.encode(confused, forKey: "confused")
        try values.encode(heart, forKey: "heart")
        try values.encode(hooray, forKey: "hooray")
        try values.encode(eyes, forKey: "eyes")
        try values.encode(rocket, forKey: "rocket")
    }
}

/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
public struct Issue: Codable {
    public var id: Int
    public var nodeID: String
    /// URL for the issue
    ///
    /// Example: "https://api.github.com/repositories/42/issues/1"
    public var url: URL
    public var repositoryURL: URL
    public var labelsURL: String
    public var commentsURL: URL
    public var eventsURL: URL
    public var htmlURL: URL
    /// Number uniquely identifying the issue within its repository
    ///
    /// Example: 42
    public var number: Int
    /// State of the issue; either 'open' or 'closed'
    ///
    /// Example: "open"
    public var state: String
    /// Title of the issue
    ///
    /// Example: "Widget creation fails in Safari on OS X 10.8"
    public var title: String
    /// Contents of the issue
    ///
    /// Example: "It looks like the new widget form is broken on Safari. When I try and create the widget, Safari crashes. This is reproducible on 10.8, but not 10.9. Maybe a browser bug?"
    public var body: String?
    /// Simple User
    public var user: SimpleUser?
    /// Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
    ///
    /// Example: ["bug", "registration"]
    public var labels: [Label]
    /// Simple User
    public var assignee: SimpleUser?
    public var assignees: [SimpleUser]?
    /// A collection of related issues and pull requests.
    public var milestone: Milestone?
    public var isLocked: Bool
    public var activeLockReason: String?
    public var comments: Int
    public var pullRequest: PullRequest?
    public var closedAt: Date?
    public var createdAt: Date
    public var updatedAt: Date
    public var isDraft: Bool?
    /// Simple User
    public var closedBy: SimpleUser?
    public var bodyHTML: String?
    public var bodyText: String?
    public var timelineURL: URL?
    /// A git repository
    public var repository: Repository?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public enum Label: Codable {
        case string(String)
        case object(Object)

        public struct Object: Codable {
            public var id: Int?
            public var nodeID: String?
            public var url: URL?
            public var name: String?
            public var description: String?
            public var color: String?
            public var isDefault: Bool?

            public init(id: Int? = nil, nodeID: String? = nil, url: URL? = nil, name: String? = nil, description: String? = nil, color: String? = nil, isDefault: Bool? = nil) {
                self.id = id
                self.nodeID = nodeID
                self.url = url
                self.name = name
                self.description = description
                self.color = color
                self.isDefault = isDefault
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decodeIfPresent(Int.self, forKey: "id")
                self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
                self.url = try values.decodeIfPresent(URL.self, forKey: "url")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.color = try values.decodeIfPresent(String.self, forKey: "color")
                self.isDefault = try values.decodeIfPresent(Bool.self, forKey: "default")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(nodeID, forKey: "node_id")
                try values.encodeIfPresent(url, forKey: "url")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(color, forKey: "color")
                try values.encodeIfPresent(isDefault, forKey: "default")
            }
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(String.self) {
                self = .string(value)
            } else if let value = try? container.decode(Object.self) {
                self = .object(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .string(let value): try container.encode(value)
            case .object(let value): try container.encode(value)
            }
        }
    }

    public struct PullRequest: Codable {
        public var mergedAt: Date?
        public var diffURL: URL?
        public var htmlURL: URL?
        public var patchURL: URL?
        public var url: URL?

        public init(mergedAt: Date? = nil, diffURL: URL? = nil, htmlURL: URL? = nil, patchURL: URL? = nil, url: URL? = nil) {
            self.mergedAt = mergedAt
            self.diffURL = diffURL
            self.htmlURL = htmlURL
            self.patchURL = patchURL
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.mergedAt = try values.decodeIfPresent(Date.self, forKey: "merged_at")
            self.diffURL = try values.decodeIfPresent(URL.self, forKey: "diff_url")
            self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
            self.patchURL = try values.decodeIfPresent(URL.self, forKey: "patch_url")
            self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(mergedAt, forKey: "merged_at")
            try values.encodeIfPresent(diffURL, forKey: "diff_url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(patchURL, forKey: "patch_url")
            try values.encodeIfPresent(url, forKey: "url")
        }
    }

    public init(id: Int, nodeID: String, url: URL, repositoryURL: URL, labelsURL: String, commentsURL: URL, eventsURL: URL, htmlURL: URL, number: Int, state: String, title: String, body: String? = nil, user: SimpleUser? = nil, labels: [Label], assignee: SimpleUser? = nil, assignees: [SimpleUser]? = nil, milestone: Milestone? = nil, isLocked: Bool, activeLockReason: String? = nil, comments: Int, pullRequest: PullRequest? = nil, closedAt: Date? = nil, createdAt: Date, updatedAt: Date, isDraft: Bool? = nil, closedBy: SimpleUser? = nil, bodyHTML: String? = nil, bodyText: String? = nil, timelineURL: URL? = nil, repository: Repository? = nil, performedViaGithubApp: Integration? = nil, authorAssociation: AuthorAssociation, reactions: ReactionRollup? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.repositoryURL = repositoryURL
        self.labelsURL = labelsURL
        self.commentsURL = commentsURL
        self.eventsURL = eventsURL
        self.htmlURL = htmlURL
        self.number = number
        self.state = state
        self.title = title
        self.body = body
        self.user = user
        self.labels = labels
        self.assignee = assignee
        self.assignees = assignees
        self.milestone = milestone
        self.isLocked = isLocked
        self.activeLockReason = activeLockReason
        self.comments = comments
        self.pullRequest = pullRequest
        self.closedAt = closedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.isDraft = isDraft
        self.closedBy = closedBy
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
        self.timelineURL = timelineURL
        self.repository = repository
        self.performedViaGithubApp = performedViaGithubApp
        self.authorAssociation = authorAssociation
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(String.self, forKey: "state")
        self.title = try values.decode(String.self, forKey: "title")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.labels = try values.decode([Label].self, forKey: "labels")
        self.assignee = try values.decodeIfPresent(SimpleUser.self, forKey: "assignee")
        self.assignees = try values.decodeIfPresent([SimpleUser].self, forKey: "assignees")
        self.milestone = try values.decodeIfPresent(Milestone.self, forKey: "milestone")
        self.isLocked = try values.decode(Bool.self, forKey: "locked")
        self.activeLockReason = try values.decodeIfPresent(String.self, forKey: "active_lock_reason")
        self.comments = try values.decode(Int.self, forKey: "comments")
        self.pullRequest = try values.decodeIfPresent(PullRequest.self, forKey: "pull_request")
        self.closedAt = try values.decodeIfPresent(Date.self, forKey: "closed_at")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.isDraft = try values.decodeIfPresent(Bool.self, forKey: "draft")
        self.closedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "closed_by")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.timelineURL = try values.decodeIfPresent(URL.self, forKey: "timeline_url")
        self.repository = try values.decodeIfPresent(Repository.self, forKey: "repository")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encode(title, forKey: "title")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(labels, forKey: "labels")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(assignees, forKey: "assignees")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encode(isLocked, forKey: "locked")
        try values.encodeIfPresent(activeLockReason, forKey: "active_lock_reason")
        try values.encode(comments, forKey: "comments")
        try values.encodeIfPresent(pullRequest, forKey: "pull_request")
        try values.encodeIfPresent(closedAt, forKey: "closed_at")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(isDraft, forKey: "draft")
        try values.encodeIfPresent(closedBy, forKey: "closed_by")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(timelineURL, forKey: "timeline_url")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

/// Comments provide a way for people to collaborate on an issue.
public struct IssueComment: Codable {
    /// Unique identifier of the issue comment
    ///
    /// Example: 42
    public var id: Int
    public var nodeID: String
    /// URL for the issue comment
    ///
    /// Example: "https://api.github.com/repositories/42/issues/comments/1"
    public var url: URL
    /// Contents of the issue comment
    ///
    /// Example: "What version of Safari were you using when you observed this bug?"
    public var body: String?
    public var bodyText: String?
    public var bodyHTML: String?
    public var htmlURL: URL
    /// Simple User
    public var user: SimpleUser?
    /// Example: "2011-04-14T16:00:49Z"
    public var createdAt: Date
    /// Example: "2011-04-14T16:00:49Z"
    public var updatedAt: Date
    public var issueURL: URL
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(id: Int, nodeID: String, url: URL, body: String? = nil, bodyText: String? = nil, bodyHTML: String? = nil, htmlURL: URL, user: SimpleUser? = nil, createdAt: Date, updatedAt: Date, issueURL: URL, authorAssociation: AuthorAssociation, performedViaGithubApp: Integration? = nil, reactions: ReactionRollup? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.body = body
        self.bodyText = bodyText
        self.bodyHTML = bodyHTML
        self.htmlURL = htmlURL
        self.user = user
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.issueURL = issueURL
        self.authorAssociation = authorAssociation
        self.performedViaGithubApp = performedViaGithubApp
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.issueURL = try values.decode(URL.self, forKey: "issue_url")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(issueURL, forKey: "issue_url")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

public struct Event: Codable {
    public var id: String
    public var type: String?
    public var actor: Actor
    public var repo: Repo
    /// Actor
    public var org: Actor?
    public var payload: Payload
    public var isPublic: Bool
    public var createdAt: Date?

    public struct Repo: Codable {
        public var id: Int
        public var name: String
        public var url: URL

        public init(id: Int, name: String, url: URL) {
            self.id = id
            self.name = name
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.name = try values.decode(String.self, forKey: "name")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(name, forKey: "name")
            try values.encode(url, forKey: "url")
        }
    }

    public struct Payload: Codable {
        public var action: String?
        /// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
        public var issue: Issue?
        /// Issue Comment
        ///
        /// Comments provide a way for people to collaborate on an issue.
        public var comment: IssueComment?
        public var pages: [Page]?

        public struct Page: Codable {
            public var pageName: String?
            public var title: String?
            public var summary: String?
            public var action: String?
            public var sha: String?
            public var htmlURL: String?

            public init(pageName: String? = nil, title: String? = nil, summary: String? = nil, action: String? = nil, sha: String? = nil, htmlURL: String? = nil) {
                self.pageName = pageName
                self.title = title
                self.summary = summary
                self.action = action
                self.sha = sha
                self.htmlURL = htmlURL
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.pageName = try values.decodeIfPresent(String.self, forKey: "page_name")
                self.title = try values.decodeIfPresent(String.self, forKey: "title")
                self.summary = try values.decodeIfPresent(String.self, forKey: "summary")
                self.action = try values.decodeIfPresent(String.self, forKey: "action")
                self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
                self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(pageName, forKey: "page_name")
                try values.encodeIfPresent(title, forKey: "title")
                try values.encodeIfPresent(summary, forKey: "summary")
                try values.encodeIfPresent(action, forKey: "action")
                try values.encodeIfPresent(sha, forKey: "sha")
                try values.encodeIfPresent(htmlURL, forKey: "html_url")
            }
        }

        public init(action: String? = nil, issue: Issue? = nil, comment: IssueComment? = nil, pages: [Page]? = nil) {
            self.action = action
            self.issue = issue
            self.comment = comment
            self.pages = pages
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.action = try values.decodeIfPresent(String.self, forKey: "action")
            self.issue = try values.decodeIfPresent(Issue.self, forKey: "issue")
            self.comment = try values.decodeIfPresent(IssueComment.self, forKey: "comment")
            self.pages = try values.decodeIfPresent([Page].self, forKey: "pages")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(action, forKey: "action")
            try values.encodeIfPresent(issue, forKey: "issue")
            try values.encodeIfPresent(comment, forKey: "comment")
            try values.encodeIfPresent(pages, forKey: "pages")
        }
    }

    public init(id: String, type: String? = nil, actor: Actor, repo: Repo, org: Actor? = nil, payload: Payload, isPublic: Bool, createdAt: Date? = nil) {
        self.id = id
        self.type = type
        self.actor = actor
        self.repo = repo
        self.org = org
        self.payload = payload
        self.isPublic = isPublic
        self.createdAt = createdAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.type = try values.decodeIfPresent(String.self, forKey: "type")
        self.actor = try values.decode(Actor.self, forKey: "actor")
        self.repo = try values.decode(Repo.self, forKey: "repo")
        self.org = try values.decodeIfPresent(Actor.self, forKey: "org")
        self.payload = try values.decode(Payload.self, forKey: "payload")
        self.isPublic = try values.decode(Bool.self, forKey: "public")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(actor, forKey: "actor")
        try values.encode(repo, forKey: "repo")
        try values.encodeIfPresent(org, forKey: "org")
        try values.encode(payload, forKey: "payload")
        try values.encode(isPublic, forKey: "public")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
    }
}

/// Hypermedia Link with Type
public struct LinkWithType: Codable {
    public var href: String
    public var type: String

    public init(href: String, type: String) {
        self.href = href
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.href = try values.decode(String.self, forKey: "href")
        self.type = try values.decode(String.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(href, forKey: "href")
        try values.encode(type, forKey: "type")
    }
}

public struct Feed: Codable {
    /// Example: "https://github.com/timeline"
    public var timelineURL: String
    /// Example: "https://github.com/{user}"
    public var userURL: String
    /// Example: "https://github.com/octocat"
    public var currentUserPublicURL: String?
    /// Example: "https://github.com/octocat.private?token=abc123"
    public var currentUserURL: String?
    /// Example: "https://github.com/octocat.private.actor?token=abc123"
    public var currentUserActorURL: String?
    /// Example: "https://github.com/octocat-org"
    public var currentUserOrganizationURL: String?
    /// Example: ["https://github.com/organizations/github/octocat.private.atom?token=abc123"]
    public var currentUserOrganizationURLs: [URL]?
    /// Example: "https://github.com/security-advisories"
    public var securityAdvisoriesURL: String?
    public var links: Links

    public struct Links: Codable {
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var timeline: LinkWithType
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var user: LinkWithType
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var securityAdvisories: LinkWithType?
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var currentUser: LinkWithType?
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var currentUserPublic: LinkWithType?
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var currentUserActor: LinkWithType?
        /// Link With Type
        ///
        /// Hypermedia Link with Type
        public var currentUserOrganization: LinkWithType?
        public var currentUserOrganizations: [LinkWithType]?

        public init(timeline: LinkWithType, user: LinkWithType, securityAdvisories: LinkWithType? = nil, currentUser: LinkWithType? = nil, currentUserPublic: LinkWithType? = nil, currentUserActor: LinkWithType? = nil, currentUserOrganization: LinkWithType? = nil, currentUserOrganizations: [LinkWithType]? = nil) {
            self.timeline = timeline
            self.user = user
            self.securityAdvisories = securityAdvisories
            self.currentUser = currentUser
            self.currentUserPublic = currentUserPublic
            self.currentUserActor = currentUserActor
            self.currentUserOrganization = currentUserOrganization
            self.currentUserOrganizations = currentUserOrganizations
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.timeline = try values.decode(LinkWithType.self, forKey: "timeline")
            self.user = try values.decode(LinkWithType.self, forKey: "user")
            self.securityAdvisories = try values.decodeIfPresent(LinkWithType.self, forKey: "security_advisories")
            self.currentUser = try values.decodeIfPresent(LinkWithType.self, forKey: "current_user")
            self.currentUserPublic = try values.decodeIfPresent(LinkWithType.self, forKey: "current_user_public")
            self.currentUserActor = try values.decodeIfPresent(LinkWithType.self, forKey: "current_user_actor")
            self.currentUserOrganization = try values.decodeIfPresent(LinkWithType.self, forKey: "current_user_organization")
            self.currentUserOrganizations = try values.decodeIfPresent([LinkWithType].self, forKey: "current_user_organizations")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(timeline, forKey: "timeline")
            try values.encode(user, forKey: "user")
            try values.encodeIfPresent(securityAdvisories, forKey: "security_advisories")
            try values.encodeIfPresent(currentUser, forKey: "current_user")
            try values.encodeIfPresent(currentUserPublic, forKey: "current_user_public")
            try values.encodeIfPresent(currentUserActor, forKey: "current_user_actor")
            try values.encodeIfPresent(currentUserOrganization, forKey: "current_user_organization")
            try values.encodeIfPresent(currentUserOrganizations, forKey: "current_user_organizations")
        }
    }

    public init(timelineURL: String, userURL: String, currentUserPublicURL: String? = nil, currentUserURL: String? = nil, currentUserActorURL: String? = nil, currentUserOrganizationURL: String? = nil, currentUserOrganizationURLs: [URL]? = nil, securityAdvisoriesURL: String? = nil, links: Links) {
        self.timelineURL = timelineURL
        self.userURL = userURL
        self.currentUserPublicURL = currentUserPublicURL
        self.currentUserURL = currentUserURL
        self.currentUserActorURL = currentUserActorURL
        self.currentUserOrganizationURL = currentUserOrganizationURL
        self.currentUserOrganizationURLs = currentUserOrganizationURLs
        self.securityAdvisoriesURL = securityAdvisoriesURL
        self.links = links
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timelineURL = try values.decode(String.self, forKey: "timeline_url")
        self.userURL = try values.decode(String.self, forKey: "user_url")
        self.currentUserPublicURL = try values.decodeIfPresent(String.self, forKey: "current_user_public_url")
        self.currentUserURL = try values.decodeIfPresent(String.self, forKey: "current_user_url")
        self.currentUserActorURL = try values.decodeIfPresent(String.self, forKey: "current_user_actor_url")
        self.currentUserOrganizationURL = try values.decodeIfPresent(String.self, forKey: "current_user_organization_url")
        self.currentUserOrganizationURLs = try values.decodeIfPresent([URL].self, forKey: "current_user_organization_urls")
        self.securityAdvisoriesURL = try values.decodeIfPresent(String.self, forKey: "security_advisories_url")
        self.links = try values.decode(Links.self, forKey: "_links")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timelineURL, forKey: "timeline_url")
        try values.encode(userURL, forKey: "user_url")
        try values.encodeIfPresent(currentUserPublicURL, forKey: "current_user_public_url")
        try values.encodeIfPresent(currentUserURL, forKey: "current_user_url")
        try values.encodeIfPresent(currentUserActorURL, forKey: "current_user_actor_url")
        try values.encodeIfPresent(currentUserOrganizationURL, forKey: "current_user_organization_url")
        try values.encodeIfPresent(currentUserOrganizationURLs, forKey: "current_user_organization_urls")
        try values.encodeIfPresent(securityAdvisoriesURL, forKey: "security_advisories_url")
        try values.encode(links, forKey: "_links")
    }
}

public struct BaseGist: Codable {
    public var url: URL
    public var forksURL: URL
    public var commitsURL: URL
    public var id: String
    public var nodeID: String
    public var gitPullURL: URL
    public var gitPushURL: URL
    public var htmlURL: URL
    public var files: [String: File]
    public var isPublic: Bool
    public var createdAt: Date
    public var updatedAt: Date
    public var description: String?
    public var comments: Int
    /// Simple User
    public var user: SimpleUser?
    public var commentsURL: URL
    /// Simple User
    public var owner: SimpleUser?
    public var isTruncated: Bool?
    public var forks: [AnyJSON]?
    public var history: [AnyJSON]?

    public struct File: Codable {
        public var filename: String?
        public var type: String?
        public var language: String?
        public var rawURL: String?
        public var size: Int?

        public init(filename: String? = nil, type: String? = nil, language: String? = nil, rawURL: String? = nil, size: Int? = nil) {
            self.filename = filename
            self.type = type
            self.language = language
            self.rawURL = rawURL
            self.size = size
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.filename = try values.decodeIfPresent(String.self, forKey: "filename")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.language = try values.decodeIfPresent(String.self, forKey: "language")
            self.rawURL = try values.decodeIfPresent(String.self, forKey: "raw_url")
            self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(filename, forKey: "filename")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(language, forKey: "language")
            try values.encodeIfPresent(rawURL, forKey: "raw_url")
            try values.encodeIfPresent(size, forKey: "size")
        }
    }

    public init(url: URL, forksURL: URL, commitsURL: URL, id: String, nodeID: String, gitPullURL: URL, gitPushURL: URL, htmlURL: URL, files: [String: File], isPublic: Bool, createdAt: Date, updatedAt: Date, description: String? = nil, comments: Int, user: SimpleUser? = nil, commentsURL: URL, owner: SimpleUser? = nil, isTruncated: Bool? = nil, forks: [AnyJSON]? = nil, history: [AnyJSON]? = nil) {
        self.url = url
        self.forksURL = forksURL
        self.commitsURL = commitsURL
        self.id = id
        self.nodeID = nodeID
        self.gitPullURL = gitPullURL
        self.gitPushURL = gitPushURL
        self.htmlURL = htmlURL
        self.files = files
        self.isPublic = isPublic
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.description = description
        self.comments = comments
        self.user = user
        self.commentsURL = commentsURL
        self.owner = owner
        self.isTruncated = isTruncated
        self.forks = forks
        self.history = history
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.commitsURL = try values.decode(URL.self, forKey: "commits_url")
        self.id = try values.decode(String.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.gitPullURL = try values.decode(URL.self, forKey: "git_pull_url")
        self.gitPushURL = try values.decode(URL.self, forKey: "git_push_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.files = try values.decode([String: File].self, forKey: "files")
        self.isPublic = try values.decode(Bool.self, forKey: "public")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.comments = try values.decode(Int.self, forKey: "comments")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.isTruncated = try values.decodeIfPresent(Bool.self, forKey: "truncated")
        self.forks = try values.decodeIfPresent([AnyJSON].self, forKey: "forks")
        self.history = try values.decodeIfPresent([AnyJSON].self, forKey: "history")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(gitPullURL, forKey: "git_pull_url")
        try values.encode(gitPushURL, forKey: "git_push_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(files, forKey: "files")
        try values.encode(isPublic, forKey: "public")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(comments, forKey: "comments")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(isTruncated, forKey: "truncated")
        try values.encodeIfPresent(forks, forKey: "forks")
        try values.encodeIfPresent(history, forKey: "history")
    }
}

public struct PublicUser: Codable {
    public var login: String
    public var id: Int
    public var nodeID: String
    public var avatarURL: URL
    public var gravatarID: String?
    public var url: URL
    public var htmlURL: URL
    public var followersURL: URL
    public var followingURL: String
    public var gistsURL: String
    public var starredURL: String
    public var subscriptionsURL: URL
    public var organizationsURL: URL
    public var reposURL: URL
    public var eventsURL: String
    public var receivedEventsURL: URL
    public var type: String
    public var isSiteAdmin: Bool
    public var name: String?
    public var company: String?
    public var blog: String?
    public var location: String?
    public var email: String?
    public var isHireable: Bool?
    public var bio: String?
    public var twitterUsername: String?
    public var publicRepos: Int
    public var publicGists: Int
    public var followers: Int
    public var following: Int
    public var createdAt: Date
    public var updatedAt: Date
    public var plan: Plan?
    public var suspendedAt: Date?
    public var privateGists: Int?
    public var totalPrivateRepos: Int?
    public var ownedPrivateRepos: Int?
    public var diskUsage: Int?
    public var collaborators: Int?

    public struct Plan: Codable {
        public var collaborators: Int
        public var name: String
        public var space: Int
        public var privateRepos: Int

        public init(collaborators: Int, name: String, space: Int, privateRepos: Int) {
            self.collaborators = collaborators
            self.name = name
            self.space = space
            self.privateRepos = privateRepos
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.collaborators = try values.decode(Int.self, forKey: "collaborators")
            self.name = try values.decode(String.self, forKey: "name")
            self.space = try values.decode(Int.self, forKey: "space")
            self.privateRepos = try values.decode(Int.self, forKey: "private_repos")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(collaborators, forKey: "collaborators")
            try values.encode(name, forKey: "name")
            try values.encode(space, forKey: "space")
            try values.encode(privateRepos, forKey: "private_repos")
        }
    }

    public init(login: String, id: Int, nodeID: String, avatarURL: URL, gravatarID: String? = nil, url: URL, htmlURL: URL, followersURL: URL, followingURL: String, gistsURL: String, starredURL: String, subscriptionsURL: URL, organizationsURL: URL, reposURL: URL, eventsURL: String, receivedEventsURL: URL, type: String, isSiteAdmin: Bool, name: String? = nil, company: String? = nil, blog: String? = nil, location: String? = nil, email: String? = nil, isHireable: Bool? = nil, bio: String? = nil, twitterUsername: String? = nil, publicRepos: Int, publicGists: Int, followers: Int, following: Int, createdAt: Date, updatedAt: Date, plan: Plan? = nil, suspendedAt: Date? = nil, privateGists: Int? = nil, totalPrivateRepos: Int? = nil, ownedPrivateRepos: Int? = nil, diskUsage: Int? = nil, collaborators: Int? = nil) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.isSiteAdmin = isSiteAdmin
        self.name = name
        self.company = company
        self.blog = blog
        self.location = location
        self.email = email
        self.isHireable = isHireable
        self.bio = bio
        self.twitterUsername = twitterUsername
        self.publicRepos = publicRepos
        self.publicGists = publicGists
        self.followers = followers
        self.following = following
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.plan = plan
        self.suspendedAt = suspendedAt
        self.privateGists = privateGists
        self.totalPrivateRepos = totalPrivateRepos
        self.ownedPrivateRepos = ownedPrivateRepos
        self.diskUsage = diskUsage
        self.collaborators = collaborators
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.followersURL = try values.decode(URL.self, forKey: "followers_url")
        self.followingURL = try values.decode(String.self, forKey: "following_url")
        self.gistsURL = try values.decode(String.self, forKey: "gists_url")
        self.starredURL = try values.decode(String.self, forKey: "starred_url")
        self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(String.self, forKey: "events_url")
        self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.company = try values.decodeIfPresent(String.self, forKey: "company")
        self.blog = try values.decodeIfPresent(String.self, forKey: "blog")
        self.location = try values.decodeIfPresent(String.self, forKey: "location")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.isHireable = try values.decodeIfPresent(Bool.self, forKey: "hireable")
        self.bio = try values.decodeIfPresent(String.self, forKey: "bio")
        self.twitterUsername = try values.decodeIfPresent(String.self, forKey: "twitter_username")
        self.publicRepos = try values.decode(Int.self, forKey: "public_repos")
        self.publicGists = try values.decode(Int.self, forKey: "public_gists")
        self.followers = try values.decode(Int.self, forKey: "followers")
        self.following = try values.decode(Int.self, forKey: "following")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.plan = try values.decodeIfPresent(Plan.self, forKey: "plan")
        self.suspendedAt = try values.decodeIfPresent(Date.self, forKey: "suspended_at")
        self.privateGists = try values.decodeIfPresent(Int.self, forKey: "private_gists")
        self.totalPrivateRepos = try values.decodeIfPresent(Int.self, forKey: "total_private_repos")
        self.ownedPrivateRepos = try values.decodeIfPresent(Int.self, forKey: "owned_private_repos")
        self.diskUsage = try values.decodeIfPresent(Int.self, forKey: "disk_usage")
        self.collaborators = try values.decodeIfPresent(Int.self, forKey: "collaborators")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(followersURL, forKey: "followers_url")
        try values.encode(followingURL, forKey: "following_url")
        try values.encode(gistsURL, forKey: "gists_url")
        try values.encode(starredURL, forKey: "starred_url")
        try values.encode(subscriptionsURL, forKey: "subscriptions_url")
        try values.encode(organizationsURL, forKey: "organizations_url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encode(isSiteAdmin, forKey: "site_admin")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(company, forKey: "company")
        try values.encodeIfPresent(blog, forKey: "blog")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(isHireable, forKey: "hireable")
        try values.encodeIfPresent(bio, forKey: "bio")
        try values.encodeIfPresent(twitterUsername, forKey: "twitter_username")
        try values.encode(publicRepos, forKey: "public_repos")
        try values.encode(publicGists, forKey: "public_gists")
        try values.encode(followers, forKey: "followers")
        try values.encode(following, forKey: "following")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(plan, forKey: "plan")
        try values.encodeIfPresent(suspendedAt, forKey: "suspended_at")
        try values.encodeIfPresent(privateGists, forKey: "private_gists")
        try values.encodeIfPresent(totalPrivateRepos, forKey: "total_private_repos")
        try values.encodeIfPresent(ownedPrivateRepos, forKey: "owned_private_repos")
        try values.encodeIfPresent(diskUsage, forKey: "disk_usage")
        try values.encodeIfPresent(collaborators, forKey: "collaborators")
    }
}

public struct GistHistory: Codable {
    /// Simple User
    public var user: SimpleUser?
    public var version: String?
    public var committedAt: Date?
    public var changeStatus: ChangeStatus?
    public var url: URL?

    public struct ChangeStatus: Codable {
        public var total: Int?
        public var additions: Int?
        public var deletions: Int?

        public init(total: Int? = nil, additions: Int? = nil, deletions: Int? = nil) {
            self.total = total
            self.additions = additions
            self.deletions = deletions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.total = try values.decodeIfPresent(Int.self, forKey: "total")
            self.additions = try values.decodeIfPresent(Int.self, forKey: "additions")
            self.deletions = try values.decodeIfPresent(Int.self, forKey: "deletions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(total, forKey: "total")
            try values.encodeIfPresent(additions, forKey: "additions")
            try values.encodeIfPresent(deletions, forKey: "deletions")
        }
    }

    public init(user: SimpleUser? = nil, version: String? = nil, committedAt: Date? = nil, changeStatus: ChangeStatus? = nil, url: URL? = nil) {
        self.user = user
        self.version = version
        self.committedAt = committedAt
        self.changeStatus = changeStatus
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.version = try values.decodeIfPresent(String.self, forKey: "version")
        self.committedAt = try values.decodeIfPresent(Date.self, forKey: "committed_at")
        self.changeStatus = try values.decodeIfPresent(ChangeStatus.self, forKey: "change_status")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(version, forKey: "version")
        try values.encodeIfPresent(committedAt, forKey: "committed_at")
        try values.encodeIfPresent(changeStatus, forKey: "change_status")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

public struct GistSimple: Codable {
    /// - warning: Deprecated.
    public var forks: [Fork]?
    /// - warning: Deprecated.
    public var history: [GistHistory]?
    /// Gist
    public var forkOf: ForkOf?
    public var url: String?
    public var forksURL: String?
    public var commitsURL: String?
    public var id: String?
    public var nodeID: String?
    public var gitPullURL: String?
    public var gitPushURL: String?
    public var htmlURL: String?
    public var files: [String: File]?
    public var isPublic: Bool?
    public var createdAt: String?
    public var updatedAt: String?
    public var description: String?
    public var comments: Int?
    public var user: String?
    public var commentsURL: String?
    /// Simple User
    public var owner: SimpleUser?
    public var isTruncated: Bool?

    public struct Fork: Codable {
        public var id: String?
        public var url: URL?
        /// Public User
        public var user: PublicUser?
        public var createdAt: Date?
        public var updatedAt: Date?

        public init(id: String? = nil, url: URL? = nil, user: PublicUser? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
            self.id = id
            self.url = url
            self.user = user
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.url = try values.decodeIfPresent(URL.self, forKey: "url")
            self.user = try values.decodeIfPresent(PublicUser.self, forKey: "user")
            self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(user, forKey: "user")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        }
    }

    /// Gist
    public struct ForkOf: Codable {
        public var url: URL
        public var forksURL: URL
        public var commitsURL: URL
        public var id: String
        public var nodeID: String
        public var gitPullURL: URL
        public var gitPushURL: URL
        public var htmlURL: URL
        public var files: [String: File]
        public var isPublic: Bool
        public var createdAt: Date
        public var updatedAt: Date
        public var description: String?
        public var comments: Int
        /// Simple User
        public var user: SimpleUser?
        public var commentsURL: URL
        /// Simple User
        public var owner: SimpleUser?
        public var isTruncated: Bool?
        public var forks: [AnyJSON]?
        public var history: [AnyJSON]?

        public struct File: Codable {
            public var filename: String?
            public var type: String?
            public var language: String?
            public var rawURL: String?
            public var size: Int?

            public init(filename: String? = nil, type: String? = nil, language: String? = nil, rawURL: String? = nil, size: Int? = nil) {
                self.filename = filename
                self.type = type
                self.language = language
                self.rawURL = rawURL
                self.size = size
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.filename = try values.decodeIfPresent(String.self, forKey: "filename")
                self.type = try values.decodeIfPresent(String.self, forKey: "type")
                self.language = try values.decodeIfPresent(String.self, forKey: "language")
                self.rawURL = try values.decodeIfPresent(String.self, forKey: "raw_url")
                self.size = try values.decodeIfPresent(Int.self, forKey: "size")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(filename, forKey: "filename")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(language, forKey: "language")
                try values.encodeIfPresent(rawURL, forKey: "raw_url")
                try values.encodeIfPresent(size, forKey: "size")
            }
        }

        public init(url: URL, forksURL: URL, commitsURL: URL, id: String, nodeID: String, gitPullURL: URL, gitPushURL: URL, htmlURL: URL, files: [String: File], isPublic: Bool, createdAt: Date, updatedAt: Date, description: String? = nil, comments: Int, user: SimpleUser? = nil, commentsURL: URL, owner: SimpleUser? = nil, isTruncated: Bool? = nil, forks: [AnyJSON]? = nil, history: [AnyJSON]? = nil) {
            self.url = url
            self.forksURL = forksURL
            self.commitsURL = commitsURL
            self.id = id
            self.nodeID = nodeID
            self.gitPullURL = gitPullURL
            self.gitPushURL = gitPushURL
            self.htmlURL = htmlURL
            self.files = files
            self.isPublic = isPublic
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.description = description
            self.comments = comments
            self.user = user
            self.commentsURL = commentsURL
            self.owner = owner
            self.isTruncated = isTruncated
            self.forks = forks
            self.history = history
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.forksURL = try values.decode(URL.self, forKey: "forks_url")
            self.commitsURL = try values.decode(URL.self, forKey: "commits_url")
            self.id = try values.decode(String.self, forKey: "id")
            self.nodeID = try values.decode(String.self, forKey: "node_id")
            self.gitPullURL = try values.decode(URL.self, forKey: "git_pull_url")
            self.gitPushURL = try values.decode(URL.self, forKey: "git_push_url")
            self.htmlURL = try values.decode(URL.self, forKey: "html_url")
            self.files = try values.decode([String: File].self, forKey: "files")
            self.isPublic = try values.decode(Bool.self, forKey: "public")
            self.createdAt = try values.decode(Date.self, forKey: "created_at")
            self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.comments = try values.decode(Int.self, forKey: "comments")
            self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
            self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
            self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
            self.isTruncated = try values.decodeIfPresent(Bool.self, forKey: "truncated")
            self.forks = try values.decodeIfPresent([AnyJSON].self, forKey: "forks")
            self.history = try values.decodeIfPresent([AnyJSON].self, forKey: "history")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encode(forksURL, forKey: "forks_url")
            try values.encode(commitsURL, forKey: "commits_url")
            try values.encode(id, forKey: "id")
            try values.encode(nodeID, forKey: "node_id")
            try values.encode(gitPullURL, forKey: "git_pull_url")
            try values.encode(gitPushURL, forKey: "git_push_url")
            try values.encode(htmlURL, forKey: "html_url")
            try values.encode(files, forKey: "files")
            try values.encode(isPublic, forKey: "public")
            try values.encode(createdAt, forKey: "created_at")
            try values.encode(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(comments, forKey: "comments")
            try values.encodeIfPresent(user, forKey: "user")
            try values.encode(commentsURL, forKey: "comments_url")
            try values.encodeIfPresent(owner, forKey: "owner")
            try values.encodeIfPresent(isTruncated, forKey: "truncated")
            try values.encodeIfPresent(forks, forKey: "forks")
            try values.encodeIfPresent(history, forKey: "history")
        }
    }

    public struct File: Codable {
        public var filename: String?
        public var type: String?
        public var language: String?
        public var rawURL: String?
        public var size: Int?
        public var isTruncated: Bool?
        public var content: String?

        public init(filename: String? = nil, type: String? = nil, language: String? = nil, rawURL: String? = nil, size: Int? = nil, isTruncated: Bool? = nil, content: String? = nil) {
            self.filename = filename
            self.type = type
            self.language = language
            self.rawURL = rawURL
            self.size = size
            self.isTruncated = isTruncated
            self.content = content
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.filename = try values.decodeIfPresent(String.self, forKey: "filename")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.language = try values.decodeIfPresent(String.self, forKey: "language")
            self.rawURL = try values.decodeIfPresent(String.self, forKey: "raw_url")
            self.size = try values.decodeIfPresent(Int.self, forKey: "size")
            self.isTruncated = try values.decodeIfPresent(Bool.self, forKey: "truncated")
            self.content = try values.decodeIfPresent(String.self, forKey: "content")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(filename, forKey: "filename")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(language, forKey: "language")
            try values.encodeIfPresent(rawURL, forKey: "raw_url")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(isTruncated, forKey: "truncated")
            try values.encodeIfPresent(content, forKey: "content")
        }
    }

    public init(forks: [Fork]? = nil, history: [GistHistory]? = nil, forkOf: ForkOf? = nil, url: String? = nil, forksURL: String? = nil, commitsURL: String? = nil, id: String? = nil, nodeID: String? = nil, gitPullURL: String? = nil, gitPushURL: String? = nil, htmlURL: String? = nil, files: [String: File]? = nil, isPublic: Bool? = nil, createdAt: String? = nil, updatedAt: String? = nil, description: String? = nil, comments: Int? = nil, user: String? = nil, commentsURL: String? = nil, owner: SimpleUser? = nil, isTruncated: Bool? = nil) {
        self.forks = forks
        self.history = history
        self.forkOf = forkOf
        self.url = url
        self.forksURL = forksURL
        self.commitsURL = commitsURL
        self.id = id
        self.nodeID = nodeID
        self.gitPullURL = gitPullURL
        self.gitPushURL = gitPushURL
        self.htmlURL = htmlURL
        self.files = files
        self.isPublic = isPublic
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.description = description
        self.comments = comments
        self.user = user
        self.commentsURL = commentsURL
        self.owner = owner
        self.isTruncated = isTruncated
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.forks = try values.decodeIfPresent([Fork].self, forKey: "forks")
        self.history = try values.decodeIfPresent([GistHistory].self, forKey: "history")
        self.forkOf = try values.decodeIfPresent(ForkOf.self, forKey: "fork_of")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.forksURL = try values.decodeIfPresent(String.self, forKey: "forks_url")
        self.commitsURL = try values.decodeIfPresent(String.self, forKey: "commits_url")
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        self.gitPullURL = try values.decodeIfPresent(String.self, forKey: "git_pull_url")
        self.gitPushURL = try values.decodeIfPresent(String.self, forKey: "git_push_url")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.files = try values.decodeIfPresent([String: File].self, forKey: "files")
        self.isPublic = try values.decodeIfPresent(Bool.self, forKey: "public")
        self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.comments = try values.decodeIfPresent(Int.self, forKey: "comments")
        self.user = try values.decodeIfPresent(String.self, forKey: "user")
        self.commentsURL = try values.decodeIfPresent(String.self, forKey: "comments_url")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.isTruncated = try values.decodeIfPresent(Bool.self, forKey: "truncated")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(forks, forKey: "forks")
        try values.encodeIfPresent(history, forKey: "history")
        try values.encodeIfPresent(forkOf, forKey: "fork_of")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(forksURL, forKey: "forks_url")
        try values.encodeIfPresent(commitsURL, forKey: "commits_url")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(nodeID, forKey: "node_id")
        try values.encodeIfPresent(gitPullURL, forKey: "git_pull_url")
        try values.encodeIfPresent(gitPushURL, forKey: "git_push_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(files, forKey: "files")
        try values.encodeIfPresent(isPublic, forKey: "public")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(comments, forKey: "comments")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(commentsURL, forKey: "comments_url")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(isTruncated, forKey: "truncated")
    }
}

/// A comment made to a gist.
public struct GistComment: Codable {
    public var id: Int
    /// Example: "MDExOkdpc3RDb21tZW50MQ=="
    public var nodeID: String
    /// Example: "https://api.github.com/gists/a6db0bec360bb87e9418/comments/1"
    public var url: URL
    /// The comment text.
    ///
    /// Example: "Body of the attachment"
    public var body: String
    /// Simple User
    public var user: SimpleUser?
    /// Example: "2011-04-18T23:23:56Z"
    public var createdAt: Date
    /// Example: "2011-04-18T23:23:56Z"
    public var updatedAt: Date
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation

    public init(id: Int, nodeID: String, url: URL, body: String, user: SimpleUser? = nil, createdAt: Date, updatedAt: Date, authorAssociation: AuthorAssociation) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.body = body
        self.user = user
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.authorAssociation = authorAssociation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.body = try values.decode(String.self, forKey: "body")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(body, forKey: "body")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(authorAssociation, forKey: "author_association")
    }
}

public struct GistCommit: Codable {
    /// Example: "https://api.github.com/gists/aa5a315d61ae9438b18d/57a7f021a713b1c5a6a199b54cc514735d2d462f"
    public var url: URL
    /// Example: "57a7f021a713b1c5a6a199b54cc514735d2d462f"
    public var version: String
    /// Simple User
    public var user: SimpleUser?
    public var changeStatus: ChangeStatus
    /// Example: "2010-04-14T02:15:15Z"
    public var committedAt: Date

    public struct ChangeStatus: Codable {
        public var total: Int?
        public var additions: Int?
        public var deletions: Int?

        public init(total: Int? = nil, additions: Int? = nil, deletions: Int? = nil) {
            self.total = total
            self.additions = additions
            self.deletions = deletions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.total = try values.decodeIfPresent(Int.self, forKey: "total")
            self.additions = try values.decodeIfPresent(Int.self, forKey: "additions")
            self.deletions = try values.decodeIfPresent(Int.self, forKey: "deletions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(total, forKey: "total")
            try values.encodeIfPresent(additions, forKey: "additions")
            try values.encodeIfPresent(deletions, forKey: "deletions")
        }
    }

    public init(url: URL, version: String, user: SimpleUser? = nil, changeStatus: ChangeStatus, committedAt: Date) {
        self.url = url
        self.version = version
        self.user = user
        self.changeStatus = changeStatus
        self.committedAt = committedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.version = try values.decode(String.self, forKey: "version")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.changeStatus = try values.decode(ChangeStatus.self, forKey: "change_status")
        self.committedAt = try values.decode(Date.self, forKey: "committed_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(version, forKey: "version")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(changeStatus, forKey: "change_status")
        try values.encode(committedAt, forKey: "committed_at")
    }
}

public struct GitignoreTemplate: Codable {
    /// Example: "C"
    public var name: String
    /// Example:
    ///
    /// "# Object files
    /// *.o
    /// 
    /// # Libraries
    /// *.lib
    /// *.a
    /// 
    /// # Shared objects (inc. Windows DLLs)
    /// *.dll
    /// *.so
    /// *.so.*
    /// *.dylib
    /// 
    /// # Executables
    /// *.exe
    /// *.out
    /// *.app
    /// "
    public var source: String

    public init(name: String, source: String) {
        self.name = name
        self.source = source
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.source = try values.decode(String.self, forKey: "source")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(source, forKey: "source")
    }
}

public struct LicenseSimple: Codable {
    /// Example: "mit"
    public var key: String
    /// Example: "MIT License"
    public var name: String
    /// Example: "https://api.github.com/licenses/mit"
    public var url: URL?
    /// Example: "MIT"
    public var spdxID: String?
    /// Example: "MDc6TGljZW5zZW1pdA=="
    public var nodeID: String
    public var htmlURL: URL?

    public init(key: String, name: String, url: URL? = nil, spdxID: String? = nil, nodeID: String, htmlURL: URL? = nil) {
        self.key = key
        self.name = name
        self.url = url
        self.spdxID = spdxID
        self.nodeID = nodeID
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.key = try values.decode(String.self, forKey: "key")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.spdxID = try values.decodeIfPresent(String.self, forKey: "spdx_id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(key, forKey: "key")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(spdxID, forKey: "spdx_id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
    }
}

public struct License: Codable {
    /// Example: "mit"
    public var key: String
    /// Example: "MIT License"
    public var name: String
    /// Example: "MIT"
    public var spdxID: String?
    /// Example: "https://api.github.com/licenses/mit"
    public var url: URL?
    /// Example: "MDc6TGljZW5zZW1pdA=="
    public var nodeID: String
    /// Example: "http://choosealicense.com/licenses/mit/"
    public var htmlURL: URL
    /// Example: "A permissive license that is short and to the point. It lets people do anything with your code with proper attribution and without warranty."
    public var description: String
    /// Example: "Create a text file (typically named LICENSE or LICENSE.txt) in the root of your source code and copy the text of the license into the file. Replace [year] with the current year and [fullname] with the name (or names) of the copyright holders."
    public var implementation: String
    /// Example: ["commercial-use", "modifications", "distribution", "sublicense", "private-use"]
    public var permissions: [String]
    /// Example: ["include-copyright"]
    public var conditions: [String]
    /// Example: ["no-liability"]
    public var limitations: [String]
    /// Example:
    ///
    /// "
    /// 
    /// The MIT License (MIT)
    /// 
    /// Copyright (c) [year] [fullname]
    /// 
    /// Permission is hereby granted, free of charge, to any person obtaining a copy
    /// of this software and associated documentation files (the "Software"), to deal
    /// in the Software without restriction, including without limitation the rights
    /// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    /// copies of the Software, and to permit persons to whom the Software is
    /// furnished to do so, subject to the following conditions:
    /// 
    /// The above copyright notice and this permission notice shall be included in all
    /// copies or substantial portions of the Software.
    /// 
    /// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    /// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    /// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    /// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    /// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    /// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    /// SOFTWARE.
    /// "
    public var body: String
    /// Example: true
    public var isFeatured: Bool

    public init(key: String, name: String, spdxID: String? = nil, url: URL? = nil, nodeID: String, htmlURL: URL, description: String, implementation: String, permissions: [String], conditions: [String], limitations: [String], body: String, isFeatured: Bool) {
        self.key = key
        self.name = name
        self.spdxID = spdxID
        self.url = url
        self.nodeID = nodeID
        self.htmlURL = htmlURL
        self.description = description
        self.implementation = implementation
        self.permissions = permissions
        self.conditions = conditions
        self.limitations = limitations
        self.body = body
        self.isFeatured = isFeatured
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.key = try values.decode(String.self, forKey: "key")
        self.name = try values.decode(String.self, forKey: "name")
        self.spdxID = try values.decodeIfPresent(String.self, forKey: "spdx_id")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decode(String.self, forKey: "description")
        self.implementation = try values.decode(String.self, forKey: "implementation")
        self.permissions = try values.decode([String].self, forKey: "permissions")
        self.conditions = try values.decode([String].self, forKey: "conditions")
        self.limitations = try values.decode([String].self, forKey: "limitations")
        self.body = try values.decode(String.self, forKey: "body")
        self.isFeatured = try values.decode(Bool.self, forKey: "featured")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(key, forKey: "key")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(spdxID, forKey: "spdx_id")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(description, forKey: "description")
        try values.encode(implementation, forKey: "implementation")
        try values.encode(permissions, forKey: "permissions")
        try values.encode(conditions, forKey: "conditions")
        try values.encode(limitations, forKey: "limitations")
        try values.encode(body, forKey: "body")
        try values.encode(isFeatured, forKey: "featured")
    }
}

public struct MarketplaceListingPlan: Codable {
    /// Example: "https://api.github.com/marketplace_listing/plans/1313"
    public var url: URL
    /// Example: "https://api.github.com/marketplace_listing/plans/1313/accounts"
    public var accountsURL: URL
    /// Example: 1313
    public var id: Int
    public var number: Int
    /// Example: "Pro"
    public var name: String
    /// Example: "A professional-grade CI solution"
    public var description: String
    /// Example: 1099
    public var monthlyPriceInCents: Int
    /// Example: 11870
    public var yearlyPriceInCents: Int
    /// Example: "flat-rate"
    public var priceModel: String
    /// Example: true
    public var hasFreeTrial: Bool
    public var unitName: String?
    /// Example: "published"
    public var state: String
    /// Example: ["Up to 25 private repositories", "11 concurrent builds"]
    public var bullets: [String]

    public init(url: URL, accountsURL: URL, id: Int, number: Int, name: String, description: String, monthlyPriceInCents: Int, yearlyPriceInCents: Int, priceModel: String, hasFreeTrial: Bool, unitName: String? = nil, state: String, bullets: [String]) {
        self.url = url
        self.accountsURL = accountsURL
        self.id = id
        self.number = number
        self.name = name
        self.description = description
        self.monthlyPriceInCents = monthlyPriceInCents
        self.yearlyPriceInCents = yearlyPriceInCents
        self.priceModel = priceModel
        self.hasFreeTrial = hasFreeTrial
        self.unitName = unitName
        self.state = state
        self.bullets = bullets
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.accountsURL = try values.decode(URL.self, forKey: "accounts_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.name = try values.decode(String.self, forKey: "name")
        self.description = try values.decode(String.self, forKey: "description")
        self.monthlyPriceInCents = try values.decode(Int.self, forKey: "monthly_price_in_cents")
        self.yearlyPriceInCents = try values.decode(Int.self, forKey: "yearly_price_in_cents")
        self.priceModel = try values.decode(String.self, forKey: "price_model")
        self.hasFreeTrial = try values.decode(Bool.self, forKey: "has_free_trial")
        self.unitName = try values.decodeIfPresent(String.self, forKey: "unit_name")
        self.state = try values.decode(String.self, forKey: "state")
        self.bullets = try values.decode([String].self, forKey: "bullets")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(accountsURL, forKey: "accounts_url")
        try values.encode(id, forKey: "id")
        try values.encode(number, forKey: "number")
        try values.encode(name, forKey: "name")
        try values.encode(description, forKey: "description")
        try values.encode(monthlyPriceInCents, forKey: "monthly_price_in_cents")
        try values.encode(yearlyPriceInCents, forKey: "yearly_price_in_cents")
        try values.encode(priceModel, forKey: "price_model")
        try values.encode(hasFreeTrial, forKey: "has_free_trial")
        try values.encodeIfPresent(unitName, forKey: "unit_name")
        try values.encode(state, forKey: "state")
        try values.encode(bullets, forKey: "bullets")
    }
}

public struct MarketplacePurchase: Codable {
    public var url: String
    public var type: String
    public var id: Int
    public var login: String
    public var organizationBillingEmail: String?
    public var email: String?
    public var marketplacePendingChange: MarketplacePendingChange?
    public var marketplacePurchase: MarketplacePurchase

    public struct MarketplacePendingChange: Codable {
        public var isInstalled: Bool?
        public var effectiveDate: String?
        public var unitCount: Int?
        public var id: Int?
        /// Marketplace Listing Plan
        public var plan: MarketplaceListingPlan?

        public init(isInstalled: Bool? = nil, effectiveDate: String? = nil, unitCount: Int? = nil, id: Int? = nil, plan: MarketplaceListingPlan? = nil) {
            self.isInstalled = isInstalled
            self.effectiveDate = effectiveDate
            self.unitCount = unitCount
            self.id = id
            self.plan = plan
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isInstalled = try values.decodeIfPresent(Bool.self, forKey: "is_installed")
            self.effectiveDate = try values.decodeIfPresent(String.self, forKey: "effective_date")
            self.unitCount = try values.decodeIfPresent(Int.self, forKey: "unit_count")
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.plan = try values.decodeIfPresent(MarketplaceListingPlan.self, forKey: "plan")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isInstalled, forKey: "is_installed")
            try values.encodeIfPresent(effectiveDate, forKey: "effective_date")
            try values.encodeIfPresent(unitCount, forKey: "unit_count")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(plan, forKey: "plan")
        }
    }

    public struct MarketplacePurchase: Codable {
        public var billingCycle: String?
        public var nextBillingDate: String?
        public var isInstalled: Bool?
        public var unitCount: Int?
        public var isOnFreeTrial: Bool?
        public var freeTrialEndsOn: String?
        public var updatedAt: String?
        /// Marketplace Listing Plan
        public var plan: MarketplaceListingPlan?

        public init(billingCycle: String? = nil, nextBillingDate: String? = nil, isInstalled: Bool? = nil, unitCount: Int? = nil, isOnFreeTrial: Bool? = nil, freeTrialEndsOn: String? = nil, updatedAt: String? = nil, plan: MarketplaceListingPlan? = nil) {
            self.billingCycle = billingCycle
            self.nextBillingDate = nextBillingDate
            self.isInstalled = isInstalled
            self.unitCount = unitCount
            self.isOnFreeTrial = isOnFreeTrial
            self.freeTrialEndsOn = freeTrialEndsOn
            self.updatedAt = updatedAt
            self.plan = plan
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.billingCycle = try values.decodeIfPresent(String.self, forKey: "billing_cycle")
            self.nextBillingDate = try values.decodeIfPresent(String.self, forKey: "next_billing_date")
            self.isInstalled = try values.decodeIfPresent(Bool.self, forKey: "is_installed")
            self.unitCount = try values.decodeIfPresent(Int.self, forKey: "unit_count")
            self.isOnFreeTrial = try values.decodeIfPresent(Bool.self, forKey: "on_free_trial")
            self.freeTrialEndsOn = try values.decodeIfPresent(String.self, forKey: "free_trial_ends_on")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.plan = try values.decodeIfPresent(MarketplaceListingPlan.self, forKey: "plan")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(billingCycle, forKey: "billing_cycle")
            try values.encodeIfPresent(nextBillingDate, forKey: "next_billing_date")
            try values.encodeIfPresent(isInstalled, forKey: "is_installed")
            try values.encodeIfPresent(unitCount, forKey: "unit_count")
            try values.encodeIfPresent(isOnFreeTrial, forKey: "on_free_trial")
            try values.encodeIfPresent(freeTrialEndsOn, forKey: "free_trial_ends_on")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(plan, forKey: "plan")
        }
    }

    public init(url: String, type: String, id: Int, login: String, organizationBillingEmail: String? = nil, email: String? = nil, marketplacePendingChange: MarketplacePendingChange? = nil, marketplacePurchase: MarketplacePurchase) {
        self.url = url
        self.type = type
        self.id = id
        self.login = login
        self.organizationBillingEmail = organizationBillingEmail
        self.email = email
        self.marketplacePendingChange = marketplacePendingChange
        self.marketplacePurchase = marketplacePurchase
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(String.self, forKey: "url")
        self.type = try values.decode(String.self, forKey: "type")
        self.id = try values.decode(Int.self, forKey: "id")
        self.login = try values.decode(String.self, forKey: "login")
        self.organizationBillingEmail = try values.decodeIfPresent(String.self, forKey: "organization_billing_email")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.marketplacePendingChange = try values.decodeIfPresent(MarketplacePendingChange.self, forKey: "marketplace_pending_change")
        self.marketplacePurchase = try values.decode(MarketplacePurchase.self, forKey: "marketplace_purchase")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(type, forKey: "type")
        try values.encode(id, forKey: "id")
        try values.encode(login, forKey: "login")
        try values.encodeIfPresent(organizationBillingEmail, forKey: "organization_billing_email")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(marketplacePendingChange, forKey: "marketplace_pending_change")
        try values.encode(marketplacePurchase, forKey: "marketplace_purchase")
    }
}

public struct APIOverview: Codable {
    /// Example: true
    public var isVerifiablePasswordAuthentication: Bool
    public var sshKeyFingerprints: SshKeyFingerprints?
    /// Example: ["127.0.0.1/32"]
    public var hooks: [String]?
    /// Example: ["127.0.0.1/32"]
    public var web: [String]?
    /// Example: ["127.0.0.1/32"]
    public var api: [String]?
    /// Example: ["127.0.0.1/32"]
    public var git: [String]?
    /// Example: ["13.65.0.0/16", "157.55.204.33/32", "2a01:111:f403:f90c::/62"]
    public var packages: [String]?
    /// Example: ["192.30.252.153/32", "192.30.252.154/32"]
    public var pages: [String]?
    /// Example: ["54.158.161.132", "54.226.70.38"]
    public var importer: [String]?
    /// Example: ["13.64.0.0/16", "13.65.0.0/16"]
    public var actions: [String]?
    /// Example: ["192.168.7.15/32", "192.168.7.16/32"]
    public var dependabot: [String]?

    public struct SshKeyFingerprints: Codable {
        public var sha256Rsa: String?
        public var sha256Dsa: String?
        public var sha256Ecdsa: String?
        public var sha256Ed25519: String?

        public init(sha256Rsa: String? = nil, sha256Dsa: String? = nil, sha256Ecdsa: String? = nil, sha256Ed25519: String? = nil) {
            self.sha256Rsa = sha256Rsa
            self.sha256Dsa = sha256Dsa
            self.sha256Ecdsa = sha256Ecdsa
            self.sha256Ed25519 = sha256Ed25519
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha256Rsa = try values.decodeIfPresent(String.self, forKey: "SHA256_RSA")
            self.sha256Dsa = try values.decodeIfPresent(String.self, forKey: "SHA256_DSA")
            self.sha256Ecdsa = try values.decodeIfPresent(String.self, forKey: "SHA256_ECDSA")
            self.sha256Ed25519 = try values.decodeIfPresent(String.self, forKey: "SHA256_ED25519")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(sha256Rsa, forKey: "SHA256_RSA")
            try values.encodeIfPresent(sha256Dsa, forKey: "SHA256_DSA")
            try values.encodeIfPresent(sha256Ecdsa, forKey: "SHA256_ECDSA")
            try values.encodeIfPresent(sha256Ed25519, forKey: "SHA256_ED25519")
        }
    }

    public init(isVerifiablePasswordAuthentication: Bool, sshKeyFingerprints: SshKeyFingerprints? = nil, hooks: [String]? = nil, web: [String]? = nil, api: [String]? = nil, git: [String]? = nil, packages: [String]? = nil, pages: [String]? = nil, importer: [String]? = nil, actions: [String]? = nil, dependabot: [String]? = nil) {
        self.isVerifiablePasswordAuthentication = isVerifiablePasswordAuthentication
        self.sshKeyFingerprints = sshKeyFingerprints
        self.hooks = hooks
        self.web = web
        self.api = api
        self.git = git
        self.packages = packages
        self.pages = pages
        self.importer = importer
        self.actions = actions
        self.dependabot = dependabot
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isVerifiablePasswordAuthentication = try values.decode(Bool.self, forKey: "verifiable_password_authentication")
        self.sshKeyFingerprints = try values.decodeIfPresent(SshKeyFingerprints.self, forKey: "ssh_key_fingerprints")
        self.hooks = try values.decodeIfPresent([String].self, forKey: "hooks")
        self.web = try values.decodeIfPresent([String].self, forKey: "web")
        self.api = try values.decodeIfPresent([String].self, forKey: "api")
        self.git = try values.decodeIfPresent([String].self, forKey: "git")
        self.packages = try values.decodeIfPresent([String].self, forKey: "packages")
        self.pages = try values.decodeIfPresent([String].self, forKey: "pages")
        self.importer = try values.decodeIfPresent([String].self, forKey: "importer")
        self.actions = try values.decodeIfPresent([String].self, forKey: "actions")
        self.dependabot = try values.decodeIfPresent([String].self, forKey: "dependabot")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isVerifiablePasswordAuthentication, forKey: "verifiable_password_authentication")
        try values.encodeIfPresent(sshKeyFingerprints, forKey: "ssh_key_fingerprints")
        try values.encodeIfPresent(hooks, forKey: "hooks")
        try values.encodeIfPresent(web, forKey: "web")
        try values.encodeIfPresent(api, forKey: "api")
        try values.encodeIfPresent(git, forKey: "git")
        try values.encodeIfPresent(packages, forKey: "packages")
        try values.encodeIfPresent(pages, forKey: "pages")
        try values.encodeIfPresent(importer, forKey: "importer")
        try values.encodeIfPresent(actions, forKey: "actions")
        try values.encodeIfPresent(dependabot, forKey: "dependabot")
    }
}

public struct MinimalRepository: Codable {
    /// Example: 1296269
    public var id: Int
    /// Example: "MDEwOlJlcG9zaXRvcnkxMjk2MjY5"
    public var nodeID: String
    /// Example: "Hello-World"
    public var name: String
    /// Example: "octocat/Hello-World"
    public var fullName: String
    /// Simple User
    public var owner: SimpleUser
    public var isPrivate: Bool
    /// Example: "https://github.com/octocat/Hello-World"
    public var htmlURL: URL
    /// Example: "This your first repo!"
    public var description: String?
    public var isFork: Bool
    /// Example: "https://api.github.com/repos/octocat/Hello-World"
    public var url: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"
    public var archiveURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/assignees{/user}"
    public var assigneesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"
    public var blobsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/branches{/branch}"
    public var branchesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"
    public var collaboratorsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/comments{/number}"
    public var commentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/commits{/sha}"
    public var commitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"
    public var compareURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contents/{+path}"
    public var contentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contributors"
    public var contributorsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/deployments"
    public var deploymentsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/downloads"
    public var downloadsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/events"
    public var eventsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/forks"
    public var forksURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"
    public var gitCommitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"
    public var gitRefsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"
    public var gitTagsURL: String
    public var gitURL: String?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"
    public var issueCommentURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"
    public var issueEventsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues{/number}"
    public var issuesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"
    public var keysURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/labels{/name}"
    public var labelsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/languages"
    public var languagesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/merges"
    public var mergesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/milestones{/number}"
    public var milestonesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"
    public var notificationsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/pulls{/number}"
    public var pullsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/releases{/id}"
    public var releasesURL: String
    public var sshURL: String?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/stargazers"
    public var stargazersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"
    public var statusesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscribers"
    public var subscribersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscription"
    public var subscriptionURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/tags"
    public var tagsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/teams"
    public var teamsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"
    public var treesURL: String
    public var cloneURL: String?
    public var mirrorURL: String?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/hooks"
    public var hooksURL: URL
    public var svnURL: String?
    public var homepage: String?
    public var language: String?
    public var forksCount: Int?
    public var stargazersCount: Int?
    public var watchersCount: Int?
    public var size: Int?
    public var defaultBranch: String?
    public var openIssuesCount: Int?
    public var isTemplate: Bool?
    public var topics: [String]?
    public var hasIssues: Bool?
    public var hasProjects: Bool?
    public var hasWiki: Bool?
    public var hasPages: Bool?
    public var hasDownloads: Bool?
    public var isArchived: Bool?
    public var isDisabled: Bool?
    public var visibility: String?
    /// Example: "2011-01-26T19:06:43Z"
    public var pushedAt: Date?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date?
    /// Example: "2011-01-26T19:14:43Z"
    public var updatedAt: Date?
    public var permissions: Permissions?
    /// Example: "admin"
    public var roleName: String?
    /// Repository
    ///
    /// A git repository
    public var templateRepository: Repository?
    public var tempCloneToken: String?
    public var deleteBranchOnMerge: Bool?
    public var subscribersCount: Int?
    public var networkCount: Int?
    public var codeOfConduct: CodeOfConduct?
    public var license: License?
    public var forks: Int?
    public var openIssues: Int?
    public var watchers: Int?
    public var allowForking: Bool?

    public struct Permissions: Codable {
        public var isAdmin: Bool?
        public var isMaintain: Bool?
        public var isPush: Bool?
        public var isTriage: Bool?
        public var isPull: Bool?

        public init(isAdmin: Bool? = nil, isMaintain: Bool? = nil, isPush: Bool? = nil, isTriage: Bool? = nil, isPull: Bool? = nil) {
            self.isAdmin = isAdmin
            self.isMaintain = isMaintain
            self.isPush = isPush
            self.isTriage = isTriage
            self.isPull = isPull
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isAdmin = try values.decodeIfPresent(Bool.self, forKey: "admin")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
            self.isPush = try values.decodeIfPresent(Bool.self, forKey: "push")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPull = try values.decodeIfPresent(Bool.self, forKey: "pull")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isAdmin, forKey: "admin")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
            try values.encodeIfPresent(isPush, forKey: "push")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encodeIfPresent(isPull, forKey: "pull")
        }
    }

    public struct License: Codable {
        public var key: String?
        public var name: String?
        public var spdxID: String?
        public var url: String?
        public var nodeID: String?

        public init(key: String? = nil, name: String? = nil, spdxID: String? = nil, url: String? = nil, nodeID: String? = nil) {
            self.key = key
            self.name = name
            self.spdxID = spdxID
            self.url = url
            self.nodeID = nodeID
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.key = try values.decodeIfPresent(String.self, forKey: "key")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.spdxID = try values.decodeIfPresent(String.self, forKey: "spdx_id")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(key, forKey: "key")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(spdxID, forKey: "spdx_id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
        }
    }

    public init(id: Int, nodeID: String, name: String, fullName: String, owner: SimpleUser, isPrivate: Bool, htmlURL: URL, description: String? = nil, isFork: Bool, url: URL, archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, downloadsURL: URL, eventsURL: URL, forksURL: URL, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, gitURL: String? = nil, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, notificationsURL: String, pullsURL: String, releasesURL: String, sshURL: String? = nil, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, cloneURL: String? = nil, mirrorURL: String? = nil, hooksURL: URL, svnURL: String? = nil, homepage: String? = nil, language: String? = nil, forksCount: Int? = nil, stargazersCount: Int? = nil, watchersCount: Int? = nil, size: Int? = nil, defaultBranch: String? = nil, openIssuesCount: Int? = nil, isTemplate: Bool? = nil, topics: [String]? = nil, hasIssues: Bool? = nil, hasProjects: Bool? = nil, hasWiki: Bool? = nil, hasPages: Bool? = nil, hasDownloads: Bool? = nil, isArchived: Bool? = nil, isDisabled: Bool? = nil, visibility: String? = nil, pushedAt: Date? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, permissions: Permissions? = nil, roleName: String? = nil, templateRepository: Repository? = nil, tempCloneToken: String? = nil, deleteBranchOnMerge: Bool? = nil, subscribersCount: Int? = nil, networkCount: Int? = nil, codeOfConduct: CodeOfConduct? = nil, license: License? = nil, forks: Int? = nil, openIssues: Int? = nil, watchers: Int? = nil, allowForking: Bool? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.fullName = fullName
        self.owner = owner
        self.isPrivate = isPrivate
        self.htmlURL = htmlURL
        self.description = description
        self.isFork = isFork
        self.url = url
        self.archiveURL = archiveURL
        self.assigneesURL = assigneesURL
        self.blobsURL = blobsURL
        self.branchesURL = branchesURL
        self.collaboratorsURL = collaboratorsURL
        self.commentsURL = commentsURL
        self.commitsURL = commitsURL
        self.compareURL = compareURL
        self.contentsURL = contentsURL
        self.contributorsURL = contributorsURL
        self.deploymentsURL = deploymentsURL
        self.downloadsURL = downloadsURL
        self.eventsURL = eventsURL
        self.forksURL = forksURL
        self.gitCommitsURL = gitCommitsURL
        self.gitRefsURL = gitRefsURL
        self.gitTagsURL = gitTagsURL
        self.gitURL = gitURL
        self.issueCommentURL = issueCommentURL
        self.issueEventsURL = issueEventsURL
        self.issuesURL = issuesURL
        self.keysURL = keysURL
        self.labelsURL = labelsURL
        self.languagesURL = languagesURL
        self.mergesURL = mergesURL
        self.milestonesURL = milestonesURL
        self.notificationsURL = notificationsURL
        self.pullsURL = pullsURL
        self.releasesURL = releasesURL
        self.sshURL = sshURL
        self.stargazersURL = stargazersURL
        self.statusesURL = statusesURL
        self.subscribersURL = subscribersURL
        self.subscriptionURL = subscriptionURL
        self.tagsURL = tagsURL
        self.teamsURL = teamsURL
        self.treesURL = treesURL
        self.cloneURL = cloneURL
        self.mirrorURL = mirrorURL
        self.hooksURL = hooksURL
        self.svnURL = svnURL
        self.homepage = homepage
        self.language = language
        self.forksCount = forksCount
        self.stargazersCount = stargazersCount
        self.watchersCount = watchersCount
        self.size = size
        self.defaultBranch = defaultBranch
        self.openIssuesCount = openIssuesCount
        self.isTemplate = isTemplate
        self.topics = topics
        self.hasIssues = hasIssues
        self.hasProjects = hasProjects
        self.hasWiki = hasWiki
        self.hasPages = hasPages
        self.hasDownloads = hasDownloads
        self.isArchived = isArchived
        self.isDisabled = isDisabled
        self.visibility = visibility
        self.pushedAt = pushedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.permissions = permissions
        self.roleName = roleName
        self.templateRepository = templateRepository
        self.tempCloneToken = tempCloneToken
        self.deleteBranchOnMerge = deleteBranchOnMerge
        self.subscribersCount = subscribersCount
        self.networkCount = networkCount
        self.codeOfConduct = codeOfConduct
        self.license = license
        self.forks = forks
        self.openIssues = openIssues
        self.watchers = watchers
        self.allowForking = allowForking
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.fullName = try values.decode(String.self, forKey: "full_name")
        self.owner = try values.decode(SimpleUser.self, forKey: "owner")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isFork = try values.decode(Bool.self, forKey: "fork")
        self.url = try values.decode(URL.self, forKey: "url")
        self.archiveURL = try values.decode(String.self, forKey: "archive_url")
        self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
        self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
        self.branchesURL = try values.decode(String.self, forKey: "branches_url")
        self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
        self.commentsURL = try values.decode(String.self, forKey: "comments_url")
        self.commitsURL = try values.decode(String.self, forKey: "commits_url")
        self.compareURL = try values.decode(String.self, forKey: "compare_url")
        self.contentsURL = try values.decode(String.self, forKey: "contents_url")
        self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
        self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
        self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
        self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
        self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
        self.gitURL = try values.decodeIfPresent(String.self, forKey: "git_url")
        self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
        self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.keysURL = try values.decode(String.self, forKey: "keys_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
        self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
        self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
        self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
        self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
        self.releasesURL = try values.decode(String.self, forKey: "releases_url")
        self.sshURL = try values.decodeIfPresent(String.self, forKey: "ssh_url")
        self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
        self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
        self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
        self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
        self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.treesURL = try values.decode(String.self, forKey: "trees_url")
        self.cloneURL = try values.decodeIfPresent(String.self, forKey: "clone_url")
        self.mirrorURL = try values.decodeIfPresent(String.self, forKey: "mirror_url")
        self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
        self.svnURL = try values.decodeIfPresent(String.self, forKey: "svn_url")
        self.homepage = try values.decodeIfPresent(String.self, forKey: "homepage")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.forksCount = try values.decodeIfPresent(Int.self, forKey: "forks_count")
        self.stargazersCount = try values.decodeIfPresent(Int.self, forKey: "stargazers_count")
        self.watchersCount = try values.decodeIfPresent(Int.self, forKey: "watchers_count")
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.defaultBranch = try values.decodeIfPresent(String.self, forKey: "default_branch")
        self.openIssuesCount = try values.decodeIfPresent(Int.self, forKey: "open_issues_count")
        self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
        self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
        self.hasIssues = try values.decodeIfPresent(Bool.self, forKey: "has_issues")
        self.hasProjects = try values.decodeIfPresent(Bool.self, forKey: "has_projects")
        self.hasWiki = try values.decodeIfPresent(Bool.self, forKey: "has_wiki")
        self.hasPages = try values.decodeIfPresent(Bool.self, forKey: "has_pages")
        self.hasDownloads = try values.decodeIfPresent(Bool.self, forKey: "has_downloads")
        self.isArchived = try values.decodeIfPresent(Bool.self, forKey: "archived")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "disabled")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
        self.pushedAt = try values.decodeIfPresent(Date.self, forKey: "pushed_at")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.roleName = try values.decodeIfPresent(String.self, forKey: "role_name")
        self.templateRepository = try values.decodeIfPresent(Repository.self, forKey: "template_repository")
        self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
        self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge")
        self.subscribersCount = try values.decodeIfPresent(Int.self, forKey: "subscribers_count")
        self.networkCount = try values.decodeIfPresent(Int.self, forKey: "network_count")
        self.codeOfConduct = try values.decodeIfPresent(CodeOfConduct.self, forKey: "code_of_conduct")
        self.license = try values.decodeIfPresent(License.self, forKey: "license")
        self.forks = try values.decodeIfPresent(Int.self, forKey: "forks")
        self.openIssues = try values.decodeIfPresent(Int.self, forKey: "open_issues")
        self.watchers = try values.decodeIfPresent(Int.self, forKey: "watchers")
        self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(fullName, forKey: "full_name")
        try values.encode(owner, forKey: "owner")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isFork, forKey: "fork")
        try values.encode(url, forKey: "url")
        try values.encode(archiveURL, forKey: "archive_url")
        try values.encode(assigneesURL, forKey: "assignees_url")
        try values.encode(blobsURL, forKey: "blobs_url")
        try values.encode(branchesURL, forKey: "branches_url")
        try values.encode(collaboratorsURL, forKey: "collaborators_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(compareURL, forKey: "compare_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encode(contributorsURL, forKey: "contributors_url")
        try values.encode(deploymentsURL, forKey: "deployments_url")
        try values.encode(downloadsURL, forKey: "downloads_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(gitCommitsURL, forKey: "git_commits_url")
        try values.encode(gitRefsURL, forKey: "git_refs_url")
        try values.encode(gitTagsURL, forKey: "git_tags_url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encode(issueCommentURL, forKey: "issue_comment_url")
        try values.encode(issueEventsURL, forKey: "issue_events_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(keysURL, forKey: "keys_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(languagesURL, forKey: "languages_url")
        try values.encode(mergesURL, forKey: "merges_url")
        try values.encode(milestonesURL, forKey: "milestones_url")
        try values.encode(notificationsURL, forKey: "notifications_url")
        try values.encode(pullsURL, forKey: "pulls_url")
        try values.encode(releasesURL, forKey: "releases_url")
        try values.encodeIfPresent(sshURL, forKey: "ssh_url")
        try values.encode(stargazersURL, forKey: "stargazers_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(subscribersURL, forKey: "subscribers_url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
        try values.encode(tagsURL, forKey: "tags_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(treesURL, forKey: "trees_url")
        try values.encodeIfPresent(cloneURL, forKey: "clone_url")
        try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encodeIfPresent(svnURL, forKey: "svn_url")
        try values.encodeIfPresent(homepage, forKey: "homepage")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(forksCount, forKey: "forks_count")
        try values.encodeIfPresent(stargazersCount, forKey: "stargazers_count")
        try values.encodeIfPresent(watchersCount, forKey: "watchers_count")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(defaultBranch, forKey: "default_branch")
        try values.encodeIfPresent(openIssuesCount, forKey: "open_issues_count")
        try values.encodeIfPresent(isTemplate, forKey: "is_template")
        try values.encodeIfPresent(topics, forKey: "topics")
        try values.encodeIfPresent(hasIssues, forKey: "has_issues")
        try values.encodeIfPresent(hasProjects, forKey: "has_projects")
        try values.encodeIfPresent(hasWiki, forKey: "has_wiki")
        try values.encodeIfPresent(hasPages, forKey: "has_pages")
        try values.encodeIfPresent(hasDownloads, forKey: "has_downloads")
        try values.encodeIfPresent(isArchived, forKey: "archived")
        try values.encodeIfPresent(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(visibility, forKey: "visibility")
        try values.encodeIfPresent(pushedAt, forKey: "pushed_at")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(roleName, forKey: "role_name")
        try values.encodeIfPresent(templateRepository, forKey: "template_repository")
        try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
        try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
        try values.encodeIfPresent(subscribersCount, forKey: "subscribers_count")
        try values.encodeIfPresent(networkCount, forKey: "network_count")
        try values.encodeIfPresent(codeOfConduct, forKey: "code_of_conduct")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(forks, forKey: "forks")
        try values.encodeIfPresent(openIssues, forKey: "open_issues")
        try values.encodeIfPresent(watchers, forKey: "watchers")
        try values.encodeIfPresent(allowForking, forKey: "allow_forking")
    }
}

public struct Thread: Codable {
    public var id: String
    /// Minimal Repository
    public var repository: MinimalRepository
    public var subject: Subject
    public var reason: String
    public var isUnread: Bool
    public var updatedAt: String
    public var lastReadAt: String?
    public var url: String
    /// Example: "https://api.github.com/notifications/threads/2/subscription"
    public var subscriptionURL: String

    public struct Subject: Codable {
        public var title: String
        public var url: String
        public var latestCommentURL: String
        public var type: String

        public init(title: String, url: String, latestCommentURL: String, type: String) {
            self.title = title
            self.url = url
            self.latestCommentURL = latestCommentURL
            self.type = type
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.title = try values.decode(String.self, forKey: "title")
            self.url = try values.decode(String.self, forKey: "url")
            self.latestCommentURL = try values.decode(String.self, forKey: "latest_comment_url")
            self.type = try values.decode(String.self, forKey: "type")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(title, forKey: "title")
            try values.encode(url, forKey: "url")
            try values.encode(latestCommentURL, forKey: "latest_comment_url")
            try values.encode(type, forKey: "type")
        }
    }

    public init(id: String, repository: MinimalRepository, subject: Subject, reason: String, isUnread: Bool, updatedAt: String, lastReadAt: String? = nil, url: String, subscriptionURL: String) {
        self.id = id
        self.repository = repository
        self.subject = subject
        self.reason = reason
        self.isUnread = isUnread
        self.updatedAt = updatedAt
        self.lastReadAt = lastReadAt
        self.url = url
        self.subscriptionURL = subscriptionURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.subject = try values.decode(Subject.self, forKey: "subject")
        self.reason = try values.decode(String.self, forKey: "reason")
        self.isUnread = try values.decode(Bool.self, forKey: "unread")
        self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        self.lastReadAt = try values.decodeIfPresent(String.self, forKey: "last_read_at")
        self.url = try values.decode(String.self, forKey: "url")
        self.subscriptionURL = try values.decode(String.self, forKey: "subscription_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(repository, forKey: "repository")
        try values.encode(subject, forKey: "subject")
        try values.encode(reason, forKey: "reason")
        try values.encode(isUnread, forKey: "unread")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(lastReadAt, forKey: "last_read_at")
        try values.encode(url, forKey: "url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
    }
}

public struct ThreadSubscription: Codable {
    /// Example: true
    public var isSubscribed: Bool
    public var isIgnored: Bool
    public var reason: String?
    /// Example: "2012-10-06T21:34:12Z"
    public var createdAt: Date?
    /// Example: "https://api.github.com/notifications/threads/1/subscription"
    public var url: URL
    /// Example: "https://api.github.com/notifications/threads/1"
    public var threadURL: URL?
    /// Example: "https://api.github.com/repos/1"
    public var repositoryURL: URL?

    public init(isSubscribed: Bool, isIgnored: Bool, reason: String? = nil, createdAt: Date? = nil, url: URL, threadURL: URL? = nil, repositoryURL: URL? = nil) {
        self.isSubscribed = isSubscribed
        self.isIgnored = isIgnored
        self.reason = reason
        self.createdAt = createdAt
        self.url = url
        self.threadURL = threadURL
        self.repositoryURL = repositoryURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isSubscribed = try values.decode(Bool.self, forKey: "subscribed")
        self.isIgnored = try values.decode(Bool.self, forKey: "ignored")
        self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.threadURL = try values.decodeIfPresent(URL.self, forKey: "thread_url")
        self.repositoryURL = try values.decodeIfPresent(URL.self, forKey: "repository_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isSubscribed, forKey: "subscribed")
        try values.encode(isIgnored, forKey: "ignored")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(threadURL, forKey: "thread_url")
        try values.encodeIfPresent(repositoryURL, forKey: "repository_url")
    }
}

/// Custom repository roles created by organization administrators
public struct OrganizationCustomRepositoryRole: Codable {
    public var id: Int
    public var name: String

    public init(id: Int, name: String) {
        self.id = id
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
    }
}

public struct OrganizationFull: Codable {
    /// Example: "github"
    public var login: String
    public var id: Int
    /// Example: "MDEyOk9yZ2FuaXphdGlvbjE="
    public var nodeID: String
    /// Example: "https://api.github.com/orgs/github"
    public var url: URL
    /// Example: "https://api.github.com/orgs/github/repos"
    public var reposURL: URL
    /// Example: "https://api.github.com/orgs/github/events"
    public var eventsURL: URL
    /// Example: "https://api.github.com/orgs/github/hooks"
    public var hooksURL: String
    /// Example: "https://api.github.com/orgs/github/issues"
    public var issuesURL: String
    /// Example: "https://api.github.com/orgs/github/members{/member}"
    public var membersURL: String
    /// Example: "https://api.github.com/orgs/github/public_members{/member}"
    public var publicMembersURL: String
    /// Example: "https://github.com/images/error/octocat_happy.gif"
    public var avatarURL: String
    /// Example: "A great organization"
    public var description: String?
    /// Example: "github"
    public var name: String?
    /// Example: "GitHub"
    public var company: String?
    /// Example: "https://github.com/blog"
    public var blog: URL?
    /// Example: "San Francisco"
    public var location: String?
    /// Example: "octocat@github.com"
    public var email: String?
    /// Example: "github"
    public var twitterUsername: String?
    /// Example: true
    public var isVerified: Bool?
    /// Example: true
    public var hasOrganizationProjects: Bool
    /// Example: true
    public var hasRepositoryProjects: Bool
    public var publicRepos: Int
    public var publicGists: Int
    /// Example: 20
    public var followers: Int
    public var following: Int
    /// Example: "https://github.com/octocat"
    public var htmlURL: URL
    /// Example: "2008-01-14T04:33:35Z"
    public var createdAt: Date
    /// Example: "Organization"
    public var type: String
    /// Example: 100
    public var totalPrivateRepos: Int?
    /// Example: 100
    public var ownedPrivateRepos: Int?
    /// Example: 81
    public var privateGists: Int?
    /// Example: 10000
    public var diskUsage: Int?
    public var collaborators: Int?
    /// Example: "org@example.com"
    public var billingEmail: String?
    public var plan: Plan?
    public var defaultRepositoryPermission: String?
    /// Example: true
    public var membersCanCreateRepositories: Bool?
    /// Example: true
    public var isTwoFactorRequirementEnabled: Bool?
    /// Example: "all"
    public var membersAllowedRepositoryCreationType: String?
    /// Example: true
    public var membersCanCreatePublicRepositories: Bool?
    /// Example: true
    public var membersCanCreatePrivateRepositories: Bool?
    /// Example: true
    public var membersCanCreateInternalRepositories: Bool?
    /// Example: true
    public var membersCanCreatePages: Bool?
    /// Example: true
    public var membersCanCreatePublicPages: Bool?
    /// Example: true
    public var membersCanCreatePrivatePages: Bool?
    /// Example: false
    public var membersCanForkPrivateRepositories: Bool?
    public var updatedAt: Date

    public struct Plan: Codable {
        public var name: String
        public var space: Int
        public var privateRepos: Int
        public var filledSeats: Int?
        public var seats: Int?

        public init(name: String, space: Int, privateRepos: Int, filledSeats: Int? = nil, seats: Int? = nil) {
            self.name = name
            self.space = space
            self.privateRepos = privateRepos
            self.filledSeats = filledSeats
            self.seats = seats
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.space = try values.decode(Int.self, forKey: "space")
            self.privateRepos = try values.decode(Int.self, forKey: "private_repos")
            self.filledSeats = try values.decodeIfPresent(Int.self, forKey: "filled_seats")
            self.seats = try values.decodeIfPresent(Int.self, forKey: "seats")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(space, forKey: "space")
            try values.encode(privateRepos, forKey: "private_repos")
            try values.encodeIfPresent(filledSeats, forKey: "filled_seats")
            try values.encodeIfPresent(seats, forKey: "seats")
        }
    }

    public init(login: String, id: Int, nodeID: String, url: URL, reposURL: URL, eventsURL: URL, hooksURL: String, issuesURL: String, membersURL: String, publicMembersURL: String, avatarURL: String, description: String? = nil, name: String? = nil, company: String? = nil, blog: URL? = nil, location: String? = nil, email: String? = nil, twitterUsername: String? = nil, isVerified: Bool? = nil, hasOrganizationProjects: Bool, hasRepositoryProjects: Bool, publicRepos: Int, publicGists: Int, followers: Int, following: Int, htmlURL: URL, createdAt: Date, type: String, totalPrivateRepos: Int? = nil, ownedPrivateRepos: Int? = nil, privateGists: Int? = nil, diskUsage: Int? = nil, collaborators: Int? = nil, billingEmail: String? = nil, plan: Plan? = nil, defaultRepositoryPermission: String? = nil, membersCanCreateRepositories: Bool? = nil, isTwoFactorRequirementEnabled: Bool? = nil, membersAllowedRepositoryCreationType: String? = nil, membersCanCreatePublicRepositories: Bool? = nil, membersCanCreatePrivateRepositories: Bool? = nil, membersCanCreateInternalRepositories: Bool? = nil, membersCanCreatePages: Bool? = nil, membersCanCreatePublicPages: Bool? = nil, membersCanCreatePrivatePages: Bool? = nil, membersCanForkPrivateRepositories: Bool? = nil, updatedAt: Date) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.hooksURL = hooksURL
        self.issuesURL = issuesURL
        self.membersURL = membersURL
        self.publicMembersURL = publicMembersURL
        self.avatarURL = avatarURL
        self.description = description
        self.name = name
        self.company = company
        self.blog = blog
        self.location = location
        self.email = email
        self.twitterUsername = twitterUsername
        self.isVerified = isVerified
        self.hasOrganizationProjects = hasOrganizationProjects
        self.hasRepositoryProjects = hasRepositoryProjects
        self.publicRepos = publicRepos
        self.publicGists = publicGists
        self.followers = followers
        self.following = following
        self.htmlURL = htmlURL
        self.createdAt = createdAt
        self.type = type
        self.totalPrivateRepos = totalPrivateRepos
        self.ownedPrivateRepos = ownedPrivateRepos
        self.privateGists = privateGists
        self.diskUsage = diskUsage
        self.collaborators = collaborators
        self.billingEmail = billingEmail
        self.plan = plan
        self.defaultRepositoryPermission = defaultRepositoryPermission
        self.membersCanCreateRepositories = membersCanCreateRepositories
        self.isTwoFactorRequirementEnabled = isTwoFactorRequirementEnabled
        self.membersAllowedRepositoryCreationType = membersAllowedRepositoryCreationType
        self.membersCanCreatePublicRepositories = membersCanCreatePublicRepositories
        self.membersCanCreatePrivateRepositories = membersCanCreatePrivateRepositories
        self.membersCanCreateInternalRepositories = membersCanCreateInternalRepositories
        self.membersCanCreatePages = membersCanCreatePages
        self.membersCanCreatePublicPages = membersCanCreatePublicPages
        self.membersCanCreatePrivatePages = membersCanCreatePrivatePages
        self.membersCanForkPrivateRepositories = membersCanForkPrivateRepositories
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.hooksURL = try values.decode(String.self, forKey: "hooks_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.membersURL = try values.decode(String.self, forKey: "members_url")
        self.publicMembersURL = try values.decode(String.self, forKey: "public_members_url")
        self.avatarURL = try values.decode(String.self, forKey: "avatar_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.company = try values.decodeIfPresent(String.self, forKey: "company")
        self.blog = try values.decodeIfPresent(URL.self, forKey: "blog")
        self.location = try values.decodeIfPresent(String.self, forKey: "location")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.twitterUsername = try values.decodeIfPresent(String.self, forKey: "twitter_username")
        self.isVerified = try values.decodeIfPresent(Bool.self, forKey: "is_verified")
        self.hasOrganizationProjects = try values.decode(Bool.self, forKey: "has_organization_projects")
        self.hasRepositoryProjects = try values.decode(Bool.self, forKey: "has_repository_projects")
        self.publicRepos = try values.decode(Int.self, forKey: "public_repos")
        self.publicGists = try values.decode(Int.self, forKey: "public_gists")
        self.followers = try values.decode(Int.self, forKey: "followers")
        self.following = try values.decode(Int.self, forKey: "following")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.type = try values.decode(String.self, forKey: "type")
        self.totalPrivateRepos = try values.decodeIfPresent(Int.self, forKey: "total_private_repos")
        self.ownedPrivateRepos = try values.decodeIfPresent(Int.self, forKey: "owned_private_repos")
        self.privateGists = try values.decodeIfPresent(Int.self, forKey: "private_gists")
        self.diskUsage = try values.decodeIfPresent(Int.self, forKey: "disk_usage")
        self.collaborators = try values.decodeIfPresent(Int.self, forKey: "collaborators")
        self.billingEmail = try values.decodeIfPresent(String.self, forKey: "billing_email")
        self.plan = try values.decodeIfPresent(Plan.self, forKey: "plan")
        self.defaultRepositoryPermission = try values.decodeIfPresent(String.self, forKey: "default_repository_permission")
        self.membersCanCreateRepositories = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_repositories")
        self.isTwoFactorRequirementEnabled = try values.decodeIfPresent(Bool.self, forKey: "two_factor_requirement_enabled")
        self.membersAllowedRepositoryCreationType = try values.decodeIfPresent(String.self, forKey: "members_allowed_repository_creation_type")
        self.membersCanCreatePublicRepositories = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_public_repositories")
        self.membersCanCreatePrivateRepositories = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_private_repositories")
        self.membersCanCreateInternalRepositories = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_internal_repositories")
        self.membersCanCreatePages = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_pages")
        self.membersCanCreatePublicPages = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_public_pages")
        self.membersCanCreatePrivatePages = try values.decodeIfPresent(Bool.self, forKey: "members_can_create_private_pages")
        self.membersCanForkPrivateRepositories = try values.decodeIfPresent(Bool.self, forKey: "members_can_fork_private_repositories")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(membersURL, forKey: "members_url")
        try values.encode(publicMembersURL, forKey: "public_members_url")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(company, forKey: "company")
        try values.encodeIfPresent(blog, forKey: "blog")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(twitterUsername, forKey: "twitter_username")
        try values.encodeIfPresent(isVerified, forKey: "is_verified")
        try values.encode(hasOrganizationProjects, forKey: "has_organization_projects")
        try values.encode(hasRepositoryProjects, forKey: "has_repository_projects")
        try values.encode(publicRepos, forKey: "public_repos")
        try values.encode(publicGists, forKey: "public_gists")
        try values.encode(followers, forKey: "followers")
        try values.encode(following, forKey: "following")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(totalPrivateRepos, forKey: "total_private_repos")
        try values.encodeIfPresent(ownedPrivateRepos, forKey: "owned_private_repos")
        try values.encodeIfPresent(privateGists, forKey: "private_gists")
        try values.encodeIfPresent(diskUsage, forKey: "disk_usage")
        try values.encodeIfPresent(collaborators, forKey: "collaborators")
        try values.encodeIfPresent(billingEmail, forKey: "billing_email")
        try values.encodeIfPresent(plan, forKey: "plan")
        try values.encodeIfPresent(defaultRepositoryPermission, forKey: "default_repository_permission")
        try values.encodeIfPresent(membersCanCreateRepositories, forKey: "members_can_create_repositories")
        try values.encodeIfPresent(isTwoFactorRequirementEnabled, forKey: "two_factor_requirement_enabled")
        try values.encodeIfPresent(membersAllowedRepositoryCreationType, forKey: "members_allowed_repository_creation_type")
        try values.encodeIfPresent(membersCanCreatePublicRepositories, forKey: "members_can_create_public_repositories")
        try values.encodeIfPresent(membersCanCreatePrivateRepositories, forKey: "members_can_create_private_repositories")
        try values.encodeIfPresent(membersCanCreateInternalRepositories, forKey: "members_can_create_internal_repositories")
        try values.encodeIfPresent(membersCanCreatePages, forKey: "members_can_create_pages")
        try values.encodeIfPresent(membersCanCreatePublicPages, forKey: "members_can_create_public_pages")
        try values.encodeIfPresent(membersCanCreatePrivatePages, forKey: "members_can_create_private_pages")
        try values.encodeIfPresent(membersCanForkPrivateRepositories, forKey: "members_can_fork_private_repositories")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
public enum EnabledRepositories: String, Codable, CaseIterable {
    case all
    case `none`
    case selected
}

public struct ActionsOrganizationPermissions: Codable {
    /// The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Can be one of: `all`, `none`, or `selected`.
    public var enabledRepositories: EnabledRepositories
    /// The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.
    public var selectedRepositoriesURL: String?
    /// The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
    public var allowedActions: AllowedActions?
    /// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
    public var selectedActionsURL: String?

    public init(enabledRepositories: EnabledRepositories, selectedRepositoriesURL: String? = nil, allowedActions: AllowedActions? = nil, selectedActionsURL: String? = nil) {
        self.enabledRepositories = enabledRepositories
        self.selectedRepositoriesURL = selectedRepositoriesURL
        self.allowedActions = allowedActions
        self.selectedActionsURL = selectedActionsURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.enabledRepositories = try values.decode(EnabledRepositories.self, forKey: "enabled_repositories")
        self.selectedRepositoriesURL = try values.decodeIfPresent(String.self, forKey: "selected_repositories_url")
        self.allowedActions = try values.decodeIfPresent(AllowedActions.self, forKey: "allowed_actions")
        self.selectedActionsURL = try values.decodeIfPresent(String.self, forKey: "selected_actions_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(enabledRepositories, forKey: "enabled_repositories")
        try values.encodeIfPresent(selectedRepositoriesURL, forKey: "selected_repositories_url")
        try values.encodeIfPresent(allowedActions, forKey: "allowed_actions")
        try values.encodeIfPresent(selectedActionsURL, forKey: "selected_actions_url")
    }
}

public struct RunnerGroupsOrg: Codable {
    public var id: Double
    public var name: String
    public var visibility: String
    public var isDefault: Bool
    /// Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`
    public var selectedRepositoriesURL: String?
    public var runnersURL: String
    public var isInherited: Bool
    public var inheritedAllowsPublicRepositories: Bool?
    public var allowsPublicRepositories: Bool

    public init(id: Double, name: String, visibility: String, isDefault: Bool, selectedRepositoriesURL: String? = nil, runnersURL: String, isInherited: Bool, inheritedAllowsPublicRepositories: Bool? = nil, allowsPublicRepositories: Bool) {
        self.id = id
        self.name = name
        self.visibility = visibility
        self.isDefault = isDefault
        self.selectedRepositoriesURL = selectedRepositoriesURL
        self.runnersURL = runnersURL
        self.isInherited = isInherited
        self.inheritedAllowsPublicRepositories = inheritedAllowsPublicRepositories
        self.allowsPublicRepositories = allowsPublicRepositories
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Double.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.visibility = try values.decode(String.self, forKey: "visibility")
        self.isDefault = try values.decode(Bool.self, forKey: "default")
        self.selectedRepositoriesURL = try values.decodeIfPresent(String.self, forKey: "selected_repositories_url")
        self.runnersURL = try values.decode(String.self, forKey: "runners_url")
        self.isInherited = try values.decode(Bool.self, forKey: "inherited")
        self.inheritedAllowsPublicRepositories = try values.decodeIfPresent(Bool.self, forKey: "inherited_allows_public_repositories")
        self.allowsPublicRepositories = try values.decode(Bool.self, forKey: "allows_public_repositories")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(visibility, forKey: "visibility")
        try values.encode(isDefault, forKey: "default")
        try values.encodeIfPresent(selectedRepositoriesURL, forKey: "selected_repositories_url")
        try values.encode(runnersURL, forKey: "runners_url")
        try values.encode(isInherited, forKey: "inherited")
        try values.encodeIfPresent(inheritedAllowsPublicRepositories, forKey: "inherited_allows_public_repositories")
        try values.encode(allowsPublicRepositories, forKey: "allows_public_repositories")
    }
}

/// Actions Secret for an Organization
///
/// Secrets for GitHub Actions for an organization.
public struct OrganizationActionsSecret: Codable {
    /// The name of the secret.
    ///
    /// Example: "SECRET_TOKEN"
    public var name: String
    public var createdAt: Date
    public var updatedAt: Date
    /// Visibility of a secret
    public var visibility: Visibility
    /// Example: "https://api.github.com/organizations/org/secrets/my_secret/repositories"
    public var selectedRepositoriesURL: URL?

    /// Visibility of a secret
    public enum Visibility: String, Codable, CaseIterable {
        case all
        case `private`
        case selected
    }

    public init(name: String, createdAt: Date, updatedAt: Date, visibility: Visibility, selectedRepositoriesURL: URL? = nil) {
        self.name = name
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.visibility = visibility
        self.selectedRepositoriesURL = selectedRepositoriesURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.visibility = try values.decode(Visibility.self, forKey: "visibility")
        self.selectedRepositoriesURL = try values.decodeIfPresent(URL.self, forKey: "selected_repositories_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(visibility, forKey: "visibility")
        try values.encodeIfPresent(selectedRepositoriesURL, forKey: "selected_repositories_url")
    }
}

/// The public key used for setting Actions Secrets.
public struct ActionsPublicKey: Codable {
    /// The identifier for the key.
    ///
    /// Example: "1234567"
    public var keyID: String
    /// The Base64 encoded public key.
    ///
    /// Example: "hBT5WZEj8ZoOv6TYJsfWq7MxTEQopZO5/IT3ZCVQPzs="
    public var key: String
    public var id: Int?
    /// Example: "https://api.github.com/user/keys/2"
    public var url: String?
    /// Example: "ssh-rsa AAAAB3NzaC1yc2EAAA"
    public var title: String?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: String?

    public init(keyID: String, key: String, id: Int? = nil, url: String? = nil, title: String? = nil, createdAt: String? = nil) {
        self.keyID = keyID
        self.key = key
        self.id = id
        self.url = url
        self.title = title
        self.createdAt = createdAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.keyID = try values.decode(String.self, forKey: "key_id")
        self.key = try values.decode(String.self, forKey: "key")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(keyID, forKey: "key_id")
        try values.encode(key, forKey: "key")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
    }
}

public struct CredentialAuthorization: Codable {
    /// User login that owns the underlying credential.
    ///
    /// Example: "monalisa"
    public var login: String
    /// Unique identifier for the credential.
    public var credentialID: Int
    /// Human-readable description of the credential type.
    ///
    /// Example: "SSH Key"
    public var credentialType: String
    /// Last eight characters of the credential. Only included in responses with credential_type of personal access token.
    ///
    /// Example: "12345678"
    public var tokenLastEight: String?
    /// Date when the credential was authorized for use.
    ///
    /// Example: "2011-01-26T19:06:43Z"
    public var credentialAuthorizedAt: Date
    /// List of oauth scopes the token has been granted.
    ///
    /// Example: ["user", "repo"]
    public var scopes: [String]?
    /// Unique string to distinguish the credential. Only included in responses with credential_type of SSH Key.
    ///
    /// Example: "jklmnop12345678"
    public var fingerprint: String?
    /// Date when the credential was last accessed. May be null if it was never accessed
    ///
    /// Example: "2011-01-26T19:06:43Z"
    public var credentialAccessedAt: Date?
    /// Example: 12345678
    public var authorizedCredentialID: Int?
    /// The title given to the ssh key. This will only be present when the credential is an ssh key.
    ///
    /// Example: "my ssh key"
    public var authorizedCredentialTitle: String?
    /// The note given to the token. This will only be present when the credential is a token.
    ///
    /// Example: "my token"
    public var authorizedCredentialNote: String?
    /// The expiry for the token. This will only be present when the credential is a token.
    public var authorizedCredentialExpiresAt: Date?

    public init(login: String, credentialID: Int, credentialType: String, tokenLastEight: String? = nil, credentialAuthorizedAt: Date, scopes: [String]? = nil, fingerprint: String? = nil, credentialAccessedAt: Date? = nil, authorizedCredentialID: Int? = nil, authorizedCredentialTitle: String? = nil, authorizedCredentialNote: String? = nil, authorizedCredentialExpiresAt: Date? = nil) {
        self.login = login
        self.credentialID = credentialID
        self.credentialType = credentialType
        self.tokenLastEight = tokenLastEight
        self.credentialAuthorizedAt = credentialAuthorizedAt
        self.scopes = scopes
        self.fingerprint = fingerprint
        self.credentialAccessedAt = credentialAccessedAt
        self.authorizedCredentialID = authorizedCredentialID
        self.authorizedCredentialTitle = authorizedCredentialTitle
        self.authorizedCredentialNote = authorizedCredentialNote
        self.authorizedCredentialExpiresAt = authorizedCredentialExpiresAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.credentialID = try values.decode(Int.self, forKey: "credential_id")
        self.credentialType = try values.decode(String.self, forKey: "credential_type")
        self.tokenLastEight = try values.decodeIfPresent(String.self, forKey: "token_last_eight")
        self.credentialAuthorizedAt = try values.decode(Date.self, forKey: "credential_authorized_at")
        self.scopes = try values.decodeIfPresent([String].self, forKey: "scopes")
        self.fingerprint = try values.decodeIfPresent(String.self, forKey: "fingerprint")
        self.credentialAccessedAt = try values.decodeIfPresent(Date.self, forKey: "credential_accessed_at")
        self.authorizedCredentialID = try values.decodeIfPresent(Int.self, forKey: "authorized_credential_id")
        self.authorizedCredentialTitle = try values.decodeIfPresent(String.self, forKey: "authorized_credential_title")
        self.authorizedCredentialNote = try values.decodeIfPresent(String.self, forKey: "authorized_credential_note")
        self.authorizedCredentialExpiresAt = try values.decodeIfPresent(Date.self, forKey: "authorized_credential_expires_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(credentialID, forKey: "credential_id")
        try values.encode(credentialType, forKey: "credential_type")
        try values.encodeIfPresent(tokenLastEight, forKey: "token_last_eight")
        try values.encode(credentialAuthorizedAt, forKey: "credential_authorized_at")
        try values.encodeIfPresent(scopes, forKey: "scopes")
        try values.encodeIfPresent(fingerprint, forKey: "fingerprint")
        try values.encodeIfPresent(credentialAccessedAt, forKey: "credential_accessed_at")
        try values.encodeIfPresent(authorizedCredentialID, forKey: "authorized_credential_id")
        try values.encodeIfPresent(authorizedCredentialTitle, forKey: "authorized_credential_title")
        try values.encodeIfPresent(authorizedCredentialNote, forKey: "authorized_credential_note")
        try values.encodeIfPresent(authorizedCredentialExpiresAt, forKey: "authorized_credential_expires_at")
    }
}

/// Information about an external group's usage and its members
public struct ExternalGroup: Codable {
    /// The internal ID of the group
    public var groupID: Int
    /// The display name for the group
    ///
    /// Example: "group-azuread-test"
    public var groupName: String
    /// The date when the group was last updated_at
    ///
    /// Example: "2021-01-03 22:27:15:000 -700"
    public var updatedAt: String?
    /// An array of teams linked to this group
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "team_id" : 1,
    ///     "team_name" : "team-test"
    ///   },
    ///   {
    ///     "team_id" : 2,
    ///     "team_name" : "team-test2"
    ///   }
    /// ]
    public var teams: [Team]
    /// An array of external members linked to this group
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "member_email" : "mona_lisa@github.com",
    ///     "member_id" : 1,
    ///     "member_login" : "mona-lisa_eocsaxrs",
    ///     "member_name" : "Mona Lisa"
    ///   },
    ///   {
    ///     "member_email" : "octo_lisa@github.com",
    ///     "member_id" : 2,
    ///     "member_login" : "octo-lisa_eocsaxrs",
    ///     "member_name" : "Octo Lisa"
    ///   }
    /// ]
    public var members: [Member]

    public struct Team: Codable {
        /// The id for a team
        public var teamID: Int
        /// The name of the team
        ///
        /// Example: "team-test"
        public var teamName: String

        public init(teamID: Int, teamName: String) {
            self.teamID = teamID
            self.teamName = teamName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.teamID = try values.decode(Int.self, forKey: "team_id")
            self.teamName = try values.decode(String.self, forKey: "team_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(teamID, forKey: "team_id")
            try values.encode(teamName, forKey: "team_name")
        }
    }

    public struct Member: Codable {
        /// The internal user ID of the identity
        public var memberID: Int
        /// The handle/login for the user
        ///
        /// Example: "mona-lisa_eocsaxrs"
        public var memberLogin: String
        /// The user display name/profile name
        ///
        /// Example: "Mona Lisa"
        public var memberName: String
        /// An email attached to a user
        ///
        /// Example: "mona_lisa@github.com"
        public var memberEmail: String

        public init(memberID: Int, memberLogin: String, memberName: String, memberEmail: String) {
            self.memberID = memberID
            self.memberLogin = memberLogin
            self.memberName = memberName
            self.memberEmail = memberEmail
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.memberID = try values.decode(Int.self, forKey: "member_id")
            self.memberLogin = try values.decode(String.self, forKey: "member_login")
            self.memberName = try values.decode(String.self, forKey: "member_name")
            self.memberEmail = try values.decode(String.self, forKey: "member_email")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(memberID, forKey: "member_id")
            try values.encode(memberLogin, forKey: "member_login")
            try values.encode(memberName, forKey: "member_name")
            try values.encode(memberEmail, forKey: "member_email")
        }
    }

    public init(groupID: Int, groupName: String, updatedAt: String? = nil, teams: [Team], members: [Member]) {
        self.groupID = groupID
        self.groupName = groupName
        self.updatedAt = updatedAt
        self.teams = teams
        self.members = members
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.groupID = try values.decode(Int.self, forKey: "group_id")
        self.groupName = try values.decode(String.self, forKey: "group_name")
        self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
        self.teams = try values.decode([Team].self, forKey: "teams")
        self.members = try values.decode([Member].self, forKey: "members")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(groupID, forKey: "group_id")
        try values.encode(groupName, forKey: "group_name")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(teams, forKey: "teams")
        try values.encode(members, forKey: "members")
    }
}

/// A list of external groups available to be connected to a team
public struct ExternalGroups: Codable {
    /// An array of external groups available to be mapped to a team
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "group_id" : 1,
    ///     "group_name" : "group-azuread-test",
    ///     "updated_at" : "2021-01-03 22:27:15:000 -700"
    ///   },
    ///   {
    ///     "group_id" : 2,
    ///     "group_name" : "group-azuread-test2",
    ///     "updated_at" : "2021-06-03 22:27:15:000 -700"
    ///   }
    /// ]
    public var groups: [Group]?

    public struct Group: Codable {
        /// The internal ID of the group
        public var groupID: Int
        /// The display name of the group
        ///
        /// Example: "group-azuread-test"
        public var groupName: String
        /// The time of the last update for this group
        ///
        /// Example: "2019-06-03 22:27:15:000 -700"
        public var updatedAt: String

        public init(groupID: Int, groupName: String, updatedAt: String) {
            self.groupID = groupID
            self.groupName = groupName
            self.updatedAt = updatedAt
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.groupID = try values.decode(Int.self, forKey: "group_id")
            self.groupName = try values.decode(String.self, forKey: "group_name")
            self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(groupID, forKey: "group_id")
            try values.encode(groupName, forKey: "group_name")
            try values.encode(updatedAt, forKey: "updated_at")
        }
    }

    public init(groups: [Group]? = nil) {
        self.groups = groups
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(groups, forKey: "groups")
    }
}

public struct OrganizationInvitation: Codable {
    public var id: Int
    public var login: String?
    public var email: String?
    public var role: String
    public var createdAt: String
    public var failedAt: String?
    public var failedReason: String?
    /// Simple User
    public var inviter: SimpleUser
    public var teamCount: Int
    /// Example: "MDIyOk9yZ2FuaXphdGlvbkludml0YXRpb24x"
    public var nodeID: String
    /// Example: "https://api.github.com/organizations/16/invitations/1/teams"
    public var invitationTeamsURL: String

    public init(id: Int, login: String? = nil, email: String? = nil, role: String, createdAt: String, failedAt: String? = nil, failedReason: String? = nil, inviter: SimpleUser, teamCount: Int, nodeID: String, invitationTeamsURL: String) {
        self.id = id
        self.login = login
        self.email = email
        self.role = role
        self.createdAt = createdAt
        self.failedAt = failedAt
        self.failedReason = failedReason
        self.inviter = inviter
        self.teamCount = teamCount
        self.nodeID = nodeID
        self.invitationTeamsURL = invitationTeamsURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.login = try values.decodeIfPresent(String.self, forKey: "login")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.role = try values.decode(String.self, forKey: "role")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.failedAt = try values.decodeIfPresent(String.self, forKey: "failed_at")
        self.failedReason = try values.decodeIfPresent(String.self, forKey: "failed_reason")
        self.inviter = try values.decode(SimpleUser.self, forKey: "inviter")
        self.teamCount = try values.decode(Int.self, forKey: "team_count")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.invitationTeamsURL = try values.decode(String.self, forKey: "invitation_teams_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(login, forKey: "login")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encode(role, forKey: "role")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(failedAt, forKey: "failed_at")
        try values.encodeIfPresent(failedReason, forKey: "failed_reason")
        try values.encode(inviter, forKey: "inviter")
        try values.encode(teamCount, forKey: "team_count")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(invitationTeamsURL, forKey: "invitation_teams_url")
    }
}

public struct OrgHook: Codable {
    public var id: Int
    /// Example: "https://api.github.com/orgs/octocat/hooks/1"
    public var url: URL
    /// Example: "https://api.github.com/orgs/octocat/hooks/1/pings"
    public var pingURL: URL
    /// Example: "https://api.github.com/orgs/octocat/hooks/1/deliveries"
    public var deliveriesURL: URL?
    /// Example: "web"
    public var name: String
    /// Example: ["push", "pull_request"]
    public var events: [String]
    /// Example: true
    public var isActive: Bool
    public var config: Config
    /// Example: "2011-09-06T20:39:23Z"
    public var updatedAt: Date
    /// Example: "2011-09-06T17:26:27Z"
    public var createdAt: Date
    public var type: String

    public struct Config: Codable {
        /// Example: "http://example.com/2"
        public var url: String?
        /// Example: "0"
        public var insecureSSL: String?
        /// Example: "form"
        public var contentType: String?
        /// Example: "********"
        public var secret: String?

        public init(url: String? = nil, insecureSSL: String? = nil, contentType: String? = nil, secret: String? = nil) {
            self.url = url
            self.insecureSSL = insecureSSL
            self.contentType = contentType
            self.secret = secret
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.insecureSSL = try values.decodeIfPresent(String.self, forKey: "insecure_ssl")
            self.contentType = try values.decodeIfPresent(String.self, forKey: "content_type")
            self.secret = try values.decodeIfPresent(String.self, forKey: "secret")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(insecureSSL, forKey: "insecure_ssl")
            try values.encodeIfPresent(contentType, forKey: "content_type")
            try values.encodeIfPresent(secret, forKey: "secret")
        }
    }

    public init(id: Int, url: URL, pingURL: URL, deliveriesURL: URL? = nil, name: String, events: [String], isActive: Bool, config: Config, updatedAt: Date, createdAt: Date, type: String) {
        self.id = id
        self.url = url
        self.pingURL = pingURL
        self.deliveriesURL = deliveriesURL
        self.name = name
        self.events = events
        self.isActive = isActive
        self.config = config
        self.updatedAt = updatedAt
        self.createdAt = createdAt
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.pingURL = try values.decode(URL.self, forKey: "ping_url")
        self.deliveriesURL = try values.decodeIfPresent(URL.self, forKey: "deliveries_url")
        self.name = try values.decode(String.self, forKey: "name")
        self.events = try values.decode([String].self, forKey: "events")
        self.isActive = try values.decode(Bool.self, forKey: "active")
        self.config = try values.decode(Config.self, forKey: "config")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.type = try values.decode(String.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(url, forKey: "url")
        try values.encode(pingURL, forKey: "ping_url")
        try values.encodeIfPresent(deliveriesURL, forKey: "deliveries_url")
        try values.encode(name, forKey: "name")
        try values.encode(events, forKey: "events")
        try values.encode(isActive, forKey: "active")
        try values.encode(config, forKey: "config")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(type, forKey: "type")
    }
}

/// The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
///
/// Example: "collaborators_only"
public enum InteractionGroup: String, Codable, CaseIterable {
    case existingUsers = "existing_users"
    case contributorsOnly = "contributors_only"
    case collaboratorsOnly = "collaborators_only"
}

/// Interaction Limits
///
/// Interaction limit settings.
public struct InteractionLimitResponse: Codable {
    /// The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
    ///
    /// Example: "collaborators_only"
    public var limit: InteractionGroup
    /// Example: "repository"
    public var origin: String
    /// Example: "2018-08-17T04:18:39Z"
    public var expiresAt: Date

    public init(limit: InteractionGroup, origin: String, expiresAt: Date) {
        self.limit = limit
        self.origin = origin
        self.expiresAt = expiresAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decode(InteractionGroup.self, forKey: "limit")
        self.origin = try values.decode(String.self, forKey: "origin")
        self.expiresAt = try values.decode(Date.self, forKey: "expires_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(limit, forKey: "limit")
        try values.encode(origin, forKey: "origin")
        try values.encode(expiresAt, forKey: "expires_at")
    }
}

/// The duration of the interaction restriction. Can be one of: `one_day`, `three_days`, `one_week`, `one_month`, `six_months`. Default: `one_day`.
///
/// Example: "one_month"
public enum InteractionExpiry: String, Codable, CaseIterable {
    case oneDay = "one_day"
    case threeDays = "three_days"
    case oneWeek = "one_week"
    case oneMonth = "one_month"
    case sixMonths = "six_months"
}

/// Interaction Restrictions
///
/// Limit interactions to a specific type of user for a specified duration
public struct InteractionLimit: Codable {
    /// The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Can be one of: `existing_users`, `contributors_only`, `collaborators_only`.
    ///
    /// Example: "collaborators_only"
    public var limit: InteractionGroup
    /// The duration of the interaction restriction. Can be one of: `one_day`, `three_days`, `one_week`, `one_month`, `six_months`. Default: `one_day`.
    ///
    /// Example: "one_month"
    public var expiry: InteractionExpiry?

    public init(limit: InteractionGroup, expiry: InteractionExpiry? = nil) {
        self.limit = limit
        self.expiry = expiry
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decode(InteractionGroup.self, forKey: "limit")
        self.expiry = try values.decodeIfPresent(InteractionExpiry.self, forKey: "expiry")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(limit, forKey: "limit")
        try values.encodeIfPresent(expiry, forKey: "expiry")
    }
}

/// Groups of organization members that gives permissions on specified repositories.
public struct Team: Codable {
    public var id: Int
    public var nodeID: String
    public var name: String
    public var slug: String
    public var description: String?
    public var privacy: String?
    public var permission: String
    public var permissions: Permissions?
    public var url: URL
    /// Example: "https://github.com/orgs/rails/teams/core"
    public var htmlURL: URL
    public var membersURL: String
    public var repositoriesURL: URL
    /// Team Simple
    ///
    /// Groups of organization members that gives permissions on specified repositories.
    public var parent: TeamSimple?

    public struct Permissions: Codable {
        public var isPull: Bool
        public var isTriage: Bool
        public var isPush: Bool
        public var isMaintain: Bool
        public var isAdmin: Bool

        public init(isPull: Bool, isTriage: Bool, isPush: Bool, isMaintain: Bool, isAdmin: Bool) {
            self.isPull = isPull
            self.isTriage = isTriage
            self.isPush = isPush
            self.isMaintain = isMaintain
            self.isAdmin = isAdmin
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isPull = try values.decode(Bool.self, forKey: "pull")
            self.isTriage = try values.decode(Bool.self, forKey: "triage")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isMaintain = try values.decode(Bool.self, forKey: "maintain")
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isPull, forKey: "pull")
            try values.encode(isTriage, forKey: "triage")
            try values.encode(isPush, forKey: "push")
            try values.encode(isMaintain, forKey: "maintain")
            try values.encode(isAdmin, forKey: "admin")
        }
    }

    public init(id: Int, nodeID: String, name: String, slug: String, description: String? = nil, privacy: String? = nil, permission: String, permissions: Permissions? = nil, url: URL, htmlURL: URL, membersURL: String, repositoriesURL: URL, parent: TeamSimple? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.slug = slug
        self.description = description
        self.privacy = privacy
        self.permission = permission
        self.permissions = permissions
        self.url = url
        self.htmlURL = htmlURL
        self.membersURL = membersURL
        self.repositoriesURL = repositoriesURL
        self.parent = parent
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.slug = try values.decode(String.self, forKey: "slug")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.privacy = try values.decodeIfPresent(String.self, forKey: "privacy")
        self.permission = try values.decode(String.self, forKey: "permission")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.membersURL = try values.decode(String.self, forKey: "members_url")
        self.repositoriesURL = try values.decode(URL.self, forKey: "repositories_url")
        self.parent = try values.decodeIfPresent(TeamSimple.self, forKey: "parent")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(slug, forKey: "slug")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(privacy, forKey: "privacy")
        try values.encode(permission, forKey: "permission")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(membersURL, forKey: "members_url")
        try values.encode(repositoriesURL, forKey: "repositories_url")
        try values.encodeIfPresent(parent, forKey: "parent")
    }
}

public struct OrgMembership: Codable {
    /// Example: "https://api.github.com/orgs/octocat/memberships/defunkt"
    public var url: URL
    /// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
    ///
    /// Example: "active"
    public var state: State
    /// The user's membership type in the organization.
    ///
    /// Example: "admin"
    public var role: Role
    /// Example: "https://api.github.com/orgs/octocat"
    public var organizationURL: URL
    /// Organization Simple
    public var organization: OrganizationSimple
    /// Simple User
    public var user: SimpleUser?
    public var permissions: Permissions?

    /// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
    ///
    /// Example: "active"
    public enum State: String, Codable, CaseIterable {
        case active
        case pending
    }

    /// The user's membership type in the organization.
    ///
    /// Example: "admin"
    public enum Role: String, Codable, CaseIterable {
        case admin
        case member
        case billingManager = "billing_manager"
    }

    public struct Permissions: Codable {
        public var canCreateRepository: Bool

        public init(canCreateRepository: Bool) {
            self.canCreateRepository = canCreateRepository
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.canCreateRepository = try values.decode(Bool.self, forKey: "can_create_repository")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(canCreateRepository, forKey: "can_create_repository")
        }
    }

    public init(url: URL, state: State, role: Role, organizationURL: URL, organization: OrganizationSimple, user: SimpleUser? = nil, permissions: Permissions? = nil) {
        self.url = url
        self.state = state
        self.role = role
        self.organizationURL = organizationURL
        self.organization = organization
        self.user = user
        self.permissions = permissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.state = try values.decode(State.self, forKey: "state")
        self.role = try values.decode(Role.self, forKey: "role")
        self.organizationURL = try values.decode(URL.self, forKey: "organization_url")
        self.organization = try values.decode(OrganizationSimple.self, forKey: "organization")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(state, forKey: "state")
        try values.encode(role, forKey: "role")
        try values.encode(organizationURL, forKey: "organization_url")
        try values.encode(organization, forKey: "organization")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(permissions, forKey: "permissions")
    }
}

/// A migration.
public struct Migration: Codable {
    /// Example: 79
    public var id: Int
    /// Simple User
    public var owner: SimpleUser?
    /// Example: "0b989ba4-242f-11e5-81e1-c7b6966d2516"
    public var guid: String
    /// Example: "pending"
    public var state: String
    /// Example: true
    public var lockRepositories: Bool
    public var excludeMetadata: Bool
    public var excludeGitData: Bool
    public var excludeAttachments: Bool
    public var excludeReleases: Bool
    public var excludeOwnerProjects: Bool
    public var repositories: [Repository]
    /// Example: "https://api.github.com/orgs/octo-org/migrations/79"
    public var url: URL
    /// Example: "2015-07-06T15:33:38-07:00"
    public var createdAt: Date
    /// Example: "2015-07-06T15:33:38-07:00"
    public var updatedAt: Date
    public var nodeID: String
    public var archiveURL: URL?
    public var exclude: [AnyJSON]?

    public init(id: Int, owner: SimpleUser? = nil, guid: String, state: String, lockRepositories: Bool, excludeMetadata: Bool, excludeGitData: Bool, excludeAttachments: Bool, excludeReleases: Bool, excludeOwnerProjects: Bool, repositories: [Repository], url: URL, createdAt: Date, updatedAt: Date, nodeID: String, archiveURL: URL? = nil, exclude: [AnyJSON]? = nil) {
        self.id = id
        self.owner = owner
        self.guid = guid
        self.state = state
        self.lockRepositories = lockRepositories
        self.excludeMetadata = excludeMetadata
        self.excludeGitData = excludeGitData
        self.excludeAttachments = excludeAttachments
        self.excludeReleases = excludeReleases
        self.excludeOwnerProjects = excludeOwnerProjects
        self.repositories = repositories
        self.url = url
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.nodeID = nodeID
        self.archiveURL = archiveURL
        self.exclude = exclude
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.guid = try values.decode(String.self, forKey: "guid")
        self.state = try values.decode(String.self, forKey: "state")
        self.lockRepositories = try values.decode(Bool.self, forKey: "lock_repositories")
        self.excludeMetadata = try values.decode(Bool.self, forKey: "exclude_metadata")
        self.excludeGitData = try values.decode(Bool.self, forKey: "exclude_git_data")
        self.excludeAttachments = try values.decode(Bool.self, forKey: "exclude_attachments")
        self.excludeReleases = try values.decode(Bool.self, forKey: "exclude_releases")
        self.excludeOwnerProjects = try values.decode(Bool.self, forKey: "exclude_owner_projects")
        self.repositories = try values.decode([Repository].self, forKey: "repositories")
        self.url = try values.decode(URL.self, forKey: "url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.archiveURL = try values.decodeIfPresent(URL.self, forKey: "archive_url")
        self.exclude = try values.decodeIfPresent([AnyJSON].self, forKey: "exclude")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encode(guid, forKey: "guid")
        try values.encode(state, forKey: "state")
        try values.encode(lockRepositories, forKey: "lock_repositories")
        try values.encode(excludeMetadata, forKey: "exclude_metadata")
        try values.encode(excludeGitData, forKey: "exclude_git_data")
        try values.encode(excludeAttachments, forKey: "exclude_attachments")
        try values.encode(excludeReleases, forKey: "exclude_releases")
        try values.encode(excludeOwnerProjects, forKey: "exclude_owner_projects")
        try values.encode(repositories, forKey: "repositories")
        try values.encode(url, forKey: "url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(archiveURL, forKey: "archive_url")
        try values.encodeIfPresent(exclude, forKey: "exclude")
    }
}

/// A software package
public struct Package: Codable {
    /// Unique identifier of the package.
    public var id: Int
    /// The name of the package.
    ///
    /// Example: "super-linter"
    public var name: String
    /// Example: "docker"
    public var packageType: PackageType
    /// Example: "https://api.github.com/orgs/github/packages/container/super-linter"
    public var url: String
    /// Example: "https://github.com/orgs/github/packages/container/package/super-linter"
    public var htmlURL: String
    /// The number of versions of the package.
    public var versionCount: Int
    /// Example: "private"
    public var visibility: Visibility
    /// Simple User
    public var owner: SimpleUser?
    /// Minimal Repository
    public var repository: MinimalRepository?
    public var createdAt: Date
    public var updatedAt: Date

    /// Example: "docker"
    public enum PackageType: String, Codable, CaseIterable {
        case npm
        case maven
        case rubygems
        case docker
        case nuget
        case container
    }

    /// Example: "private"
    public enum Visibility: String, Codable, CaseIterable {
        case `private`
        case `public`
    }

    public init(id: Int, name: String, packageType: PackageType, url: String, htmlURL: String, versionCount: Int, visibility: Visibility, owner: SimpleUser? = nil, repository: MinimalRepository? = nil, createdAt: Date, updatedAt: Date) {
        self.id = id
        self.name = name
        self.packageType = packageType
        self.url = url
        self.htmlURL = htmlURL
        self.versionCount = versionCount
        self.visibility = visibility
        self.owner = owner
        self.repository = repository
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.packageType = try values.decode(PackageType.self, forKey: "package_type")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.versionCount = try values.decode(Int.self, forKey: "version_count")
        self.visibility = try values.decode(Visibility.self, forKey: "visibility")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.repository = try values.decodeIfPresent(MinimalRepository.self, forKey: "repository")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(packageType, forKey: "package_type")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(versionCount, forKey: "version_count")
        try values.encode(visibility, forKey: "visibility")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

/// A version of a software package
public struct PackageVersion: Codable {
    /// Unique identifier of the package version.
    public var id: Int
    /// The name of the package version.
    ///
    /// Example: "latest"
    public var name: String
    /// Example: "https://api.github.com/orgs/github/packages/container/super-linter/versions/786068"
    public var url: String
    /// Example: "https://github.com/orgs/github/packages/container/package/super-linter"
    public var packageHTMLURL: String
    /// Example: "https://github.com/orgs/github/packages/container/super-linter/786068"
    public var htmlURL: String?
    /// Example: "MIT"
    public var license: String?
    public var description: String?
    /// Example: "2011-04-10T20:09:31Z"
    public var createdAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var updatedAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var deletedAt: Date?
    /// Package Version Metadata
    public var metadata: Metadata?

    /// Package Version Metadata
    public struct Metadata: Codable {
        /// Example: "docker"
        public var packageType: PackageType
        /// Container Metadata
        public var container: Container?
        /// Docker Metadata
        public var docker: Docker?

        /// Example: "docker"
        public enum PackageType: String, Codable, CaseIterable {
            case npm
            case maven
            case rubygems
            case docker
            case nuget
            case container
        }

        /// Container Metadata
        public struct Container: Codable {
            public var tags: [String]

            public init(tags: [String]) {
                self.tags = tags
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.tags = try values.decode([String].self, forKey: "tags")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(tags, forKey: "tags")
            }
        }

        /// Docker Metadata
        public struct Docker: Codable {
            public var tag: [String]?
            public var tags: AnyJSON

            public init(tag: [String]? = nil, tags: AnyJSON) {
                self.tag = tag
                self.tags = tags
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.tag = try values.decodeIfPresent([String].self, forKey: "tag")
                self.tags = try values.decode(AnyJSON.self, forKey: "tags")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(tag, forKey: "tag")
                try values.encode(tags, forKey: "tags")
            }
        }

        public init(packageType: PackageType, container: Container? = nil, docker: Docker? = nil) {
            self.packageType = packageType
            self.container = container
            self.docker = docker
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageType = try values.decode(PackageType.self, forKey: "package_type")
            self.container = try values.decodeIfPresent(Container.self, forKey: "container")
            self.docker = try values.decodeIfPresent(Docker.self, forKey: "docker")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageType, forKey: "package_type")
            try values.encodeIfPresent(container, forKey: "container")
            try values.encodeIfPresent(docker, forKey: "docker")
        }
    }

    public init(id: Int, name: String, url: String, packageHTMLURL: String, htmlURL: String? = nil, license: String? = nil, description: String? = nil, createdAt: Date, updatedAt: Date, deletedAt: Date? = nil, metadata: Metadata? = nil) {
        self.id = id
        self.name = name
        self.url = url
        self.packageHTMLURL = packageHTMLURL
        self.htmlURL = htmlURL
        self.license = license
        self.description = description
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deletedAt = deletedAt
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decode(String.self, forKey: "url")
        self.packageHTMLURL = try values.decode(String.self, forKey: "package_html_url")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.license = try values.decodeIfPresent(String.self, forKey: "license")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: "deleted_at")
        self.metadata = try values.decodeIfPresent(Metadata.self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(url, forKey: "url")
        try values.encode(packageHTMLURL, forKey: "package_html_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(deletedAt, forKey: "deleted_at")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}

/// Projects are a way to organize columns and cards of work.
public struct Project: Codable {
    /// Example: "https://api.github.com/repos/api-playground/projects-test"
    public var ownerURL: URL
    /// Example: "https://api.github.com/projects/1002604"
    public var url: URL
    /// Example: "https://github.com/api-playground/projects-test/projects/12"
    public var htmlURL: URL
    /// Example: "https://api.github.com/projects/1002604/columns"
    public var columnsURL: URL
    /// Example: 1002604
    public var id: Int
    /// Example: "MDc6UHJvamVjdDEwMDI2MDQ="
    public var nodeID: String
    /// Name of the project
    ///
    /// Example: "Week One Sprint"
    public var name: String
    /// Body of the project
    ///
    /// Example: "This project represents the sprint of the first week in January"
    public var body: String?
    public var number: Int
    /// State of the project; either 'open' or 'closed'
    ///
    /// Example: "open"
    public var state: String
    /// Simple User
    public var creator: SimpleUser?
    /// Example: "2011-04-10T20:09:31Z"
    public var createdAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var updatedAt: Date
    /// The baseline permission that all organization members have on this project. Only present if owner is an organization.
    public var organizationPermission: OrganizationPermission?
    /// Whether or not this project can be seen by everyone. Only present if owner is an organization.
    public var isPrivate: Bool?

    /// The baseline permission that all organization members have on this project. Only present if owner is an organization.
    public enum OrganizationPermission: String, Codable, CaseIterable {
        case read
        case write
        case admin
        case `none`
    }

    public init(ownerURL: URL, url: URL, htmlURL: URL, columnsURL: URL, id: Int, nodeID: String, name: String, body: String? = nil, number: Int, state: String, creator: SimpleUser? = nil, createdAt: Date, updatedAt: Date, organizationPermission: OrganizationPermission? = nil, isPrivate: Bool? = nil) {
        self.ownerURL = ownerURL
        self.url = url
        self.htmlURL = htmlURL
        self.columnsURL = columnsURL
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.body = body
        self.number = number
        self.state = state
        self.creator = creator
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.organizationPermission = organizationPermission
        self.isPrivate = isPrivate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ownerURL = try values.decode(URL.self, forKey: "owner_url")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.columnsURL = try values.decode(URL.self, forKey: "columns_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(String.self, forKey: "state")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.organizationPermission = try values.decodeIfPresent(OrganizationPermission.self, forKey: "organization_permission")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "private")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ownerURL, forKey: "owner_url")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(columnsURL, forKey: "columns_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(organizationPermission, forKey: "organization_permission")
        try values.encodeIfPresent(isPrivate, forKey: "private")
    }
}

/// Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.
public enum SecretScanningAlertState: String, Codable, CaseIterable {
    case `open`
    case resolved
}

/// **Required when the `state` is `resolved`.** The reason for resolving the alert. Can be one of `false_positive`, `wont_fix`, `revoked`, or `used_in_tests`.
public enum SecretScanningAlertResolution: String, Codable, CaseIterable {
    case falsePositive = "false_positive"
    case wontFix = "wont_fix"
    case revoked
    case usedInTests = "used_in_tests"
}

public struct OrganizationSecretScanningAlert: Codable {
    /// The security alert number.
    public var number: Int?
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var createdAt: Date?
    /// The REST API URL of the alert resource.
    public var url: URL?
    /// The GitHub URL of the alert resource.
    public var htmlURL: URL?
    /// The REST API URL of the code locations for this alert.
    public var locationsURL: URL?
    /// Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.
    public var state: SecretScanningAlertState?
    /// **Required when the `state` is `resolved`.** The reason for resolving the alert. Can be one of `false_positive`, `wont_fix`, `revoked`, or `used_in_tests`.
    public var resolution: SecretScanningAlertResolution?
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var resolvedAt: Date?
    /// Simple User
    public var resolvedBy: SimpleUser?
    /// The type of secret that secret scanning detected.
    public var secretType: String?
    /// The secret that was detected.
    public var secret: String?
    /// Minimal Repository
    public var repository: MinimalRepository?

    public init(number: Int? = nil, createdAt: Date? = nil, url: URL? = nil, htmlURL: URL? = nil, locationsURL: URL? = nil, state: SecretScanningAlertState? = nil, resolution: SecretScanningAlertResolution? = nil, resolvedAt: Date? = nil, resolvedBy: SimpleUser? = nil, secretType: String? = nil, secret: String? = nil, repository: MinimalRepository? = nil) {
        self.number = number
        self.createdAt = createdAt
        self.url = url
        self.htmlURL = htmlURL
        self.locationsURL = locationsURL
        self.state = state
        self.resolution = resolution
        self.resolvedAt = resolvedAt
        self.resolvedBy = resolvedBy
        self.secretType = secretType
        self.secret = secret
        self.repository = repository
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.number = try values.decodeIfPresent(Int.self, forKey: "number")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.locationsURL = try values.decodeIfPresent(URL.self, forKey: "locations_url")
        self.state = try values.decodeIfPresent(SecretScanningAlertState.self, forKey: "state")
        self.resolution = try values.decodeIfPresent(SecretScanningAlertResolution.self, forKey: "resolution")
        self.resolvedAt = try values.decodeIfPresent(Date.self, forKey: "resolved_at")
        self.resolvedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "resolved_by")
        self.secretType = try values.decodeIfPresent(String.self, forKey: "secret_type")
        self.secret = try values.decodeIfPresent(String.self, forKey: "secret")
        self.repository = try values.decodeIfPresent(MinimalRepository.self, forKey: "repository")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(number, forKey: "number")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(locationsURL, forKey: "locations_url")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(resolution, forKey: "resolution")
        try values.encodeIfPresent(resolvedAt, forKey: "resolved_at")
        try values.encodeIfPresent(resolvedBy, forKey: "resolved_by")
        try values.encodeIfPresent(secretType, forKey: "secret_type")
        try values.encodeIfPresent(secret, forKey: "secret")
        try values.encodeIfPresent(repository, forKey: "repository")
    }
}

/// External Groups to be mapped to a team for membership
public struct GroupMapping: Codable {
    /// Array of groups to be mapped to this team
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "group_description" : "A group of Developers working on AzureAD SAML SSO",
    ///     "group_id" : "111a1a11-aaa1-1aaa-11a1-a1a1a1a1a1aa",
    ///     "group_name" : "saml-azuread-test"
    ///   },
    ///   {
    ///     "group_description" : "Another group of Developers working on AzureAD SAML SSO",
    ///     "group_id" : "2bb2bb2b-bb22-22bb-2bb2-bb2bbb2bb2b2",
    ///     "group_name" : "saml-azuread-test2"
    ///   }
    /// ]
    public var groups: [Group]?

    public struct Group: Codable {
        /// The ID of the group
        ///
        /// Example: "111a1a11-aaa1-1aaa-11a1-a1a1a1a1a1aa"
        public var groupID: String
        /// The name of the group
        ///
        /// Example: "saml-azuread-test"
        public var groupName: String
        /// A description of the group
        ///
        /// Example: "A group of Developers working on AzureAD SAML SSO"
        public var groupDescription: String
        /// Synchronization status for this group mapping
        ///
        /// Example: "unsynced"
        public var status: String?
        /// The time of the last sync for this group-mapping
        ///
        /// Example: "2019-06-03 22:27:15:000 -700"
        public var syncedAt: String?

        public init(groupID: String, groupName: String, groupDescription: String, status: String? = nil, syncedAt: String? = nil) {
            self.groupID = groupID
            self.groupName = groupName
            self.groupDescription = groupDescription
            self.status = status
            self.syncedAt = syncedAt
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.groupID = try values.decode(String.self, forKey: "group_id")
            self.groupName = try values.decode(String.self, forKey: "group_name")
            self.groupDescription = try values.decode(String.self, forKey: "group_description")
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
            self.syncedAt = try values.decodeIfPresent(String.self, forKey: "synced_at")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(groupID, forKey: "group_id")
            try values.encode(groupName, forKey: "group_name")
            try values.encode(groupDescription, forKey: "group_description")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(syncedAt, forKey: "synced_at")
        }
    }

    public init(groups: [Group]? = nil) {
        self.groups = groups
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(groups, forKey: "groups")
    }
}

/// Full Team
///
/// Groups of organization members that gives permissions on specified repositories.
public struct TeamFull: Codable {
    /// Unique identifier of the team
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDQ6VGVhbTE="
    public var nodeID: String
    /// URL for the team
    ///
    /// Example: "https://api.github.com/organizations/1/team/1"
    public var url: URL
    /// Example: "https://github.com/orgs/rails/teams/core"
    public var htmlURL: URL
    /// Name of the team
    ///
    /// Example: "Developers"
    public var name: String
    /// Example: "justice-league"
    public var slug: String
    /// Example: "A great team."
    public var description: String?
    /// The level of privacy this team should have
    ///
    /// Example: "closed"
    public var privacy: Privacy?
    /// Permission that the team will have for its repositories
    ///
    /// Example: "push"
    public var permission: String
    /// Example: "https://api.github.com/organizations/1/team/1/members{/member}"
    public var membersURL: String
    /// Example: "https://api.github.com/organizations/1/team/1/repos"
    public var repositoriesURL: URL
    /// Team Simple
    ///
    /// Groups of organization members that gives permissions on specified repositories.
    public var parent: TeamSimple?
    public var membersCount: Int
    /// Example: 10
    public var reposCount: Int
    /// Example: "2017-07-14T16:53:42Z"
    public var createdAt: Date
    /// Example: "2017-08-17T12:37:15Z"
    public var updatedAt: Date
    /// Organization Full
    public var organization: OrganizationFull
    /// Distinguished Name (DN) that team maps to within LDAP environment
    ///
    /// Example: "uid=example,ou=users,dc=github,dc=com"
    public var ldapDn: String?

    /// The level of privacy this team should have
    ///
    /// Example: "closed"
    public enum Privacy: String, Codable, CaseIterable {
        case closed
        case secret
    }

    public init(id: Int, nodeID: String, url: URL, htmlURL: URL, name: String, slug: String, description: String? = nil, privacy: Privacy? = nil, permission: String, membersURL: String, repositoriesURL: URL, parent: TeamSimple? = nil, membersCount: Int, reposCount: Int, createdAt: Date, updatedAt: Date, organization: OrganizationFull, ldapDn: String? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.htmlURL = htmlURL
        self.name = name
        self.slug = slug
        self.description = description
        self.privacy = privacy
        self.permission = permission
        self.membersURL = membersURL
        self.repositoriesURL = repositoriesURL
        self.parent = parent
        self.membersCount = membersCount
        self.reposCount = reposCount
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.organization = organization
        self.ldapDn = ldapDn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.name = try values.decode(String.self, forKey: "name")
        self.slug = try values.decode(String.self, forKey: "slug")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.privacy = try values.decodeIfPresent(Privacy.self, forKey: "privacy")
        self.permission = try values.decode(String.self, forKey: "permission")
        self.membersURL = try values.decode(String.self, forKey: "members_url")
        self.repositoriesURL = try values.decode(URL.self, forKey: "repositories_url")
        self.parent = try values.decodeIfPresent(TeamSimple.self, forKey: "parent")
        self.membersCount = try values.decode(Int.self, forKey: "members_count")
        self.reposCount = try values.decode(Int.self, forKey: "repos_count")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.organization = try values.decode(OrganizationFull.self, forKey: "organization")
        self.ldapDn = try values.decodeIfPresent(String.self, forKey: "ldap_dn")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(name, forKey: "name")
        try values.encode(slug, forKey: "slug")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(privacy, forKey: "privacy")
        try values.encode(permission, forKey: "permission")
        try values.encode(membersURL, forKey: "members_url")
        try values.encode(repositoriesURL, forKey: "repositories_url")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encode(membersCount, forKey: "members_count")
        try values.encode(reposCount, forKey: "repos_count")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(organization, forKey: "organization")
        try values.encodeIfPresent(ldapDn, forKey: "ldap_dn")
    }
}

/// A team discussion is a persistent record of a free-form conversation within a team.
public struct TeamDiscussion: Codable {
    /// Simple User
    public var author: SimpleUser?
    /// The main text of the discussion.
    ///
    /// Example: "Please suggest improvements to our workflow in comments."
    public var body: String
    /// Example: "<p>Hi! This is an area for us to collaborate as a team</p>"
    public var bodyHTML: String
    /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
    ///
    /// Example: "0307116bbf7ced493b8d8a346c650b71"
    public var bodyVersion: String
    public var commentsCount: Int
    /// Example: "https://api.github.com/organizations/1/team/2343027/discussions/1/comments"
    public var commentsURL: URL
    /// Example: "2018-01-25T18:56:31Z"
    public var createdAt: Date
    public var lastEditedAt: Date?
    /// Example: "https://github.com/orgs/github/teams/justice-league/discussions/1"
    public var htmlURL: URL
    /// Example: "MDE0OlRlYW1EaXNjdXNzaW9uMQ=="
    public var nodeID: String
    /// The unique sequence number of a team discussion.
    ///
    /// Example: 42
    public var number: Int
    /// Whether or not this discussion should be pinned for easy retrieval.
    ///
    /// Example: true
    public var isPinned: Bool
    /// Whether or not this discussion should be restricted to team members and organization administrators.
    ///
    /// Example: true
    public var isPrivate: Bool
    /// Example: "https://api.github.com/organizations/1/team/2343027"
    public var teamURL: URL
    /// The title of the discussion.
    ///
    /// Example: "How can we improve our workflow?"
    public var title: String
    /// Example: "2018-01-25T18:56:31Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/organizations/1/team/2343027/discussions/1"
    public var url: URL
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(author: SimpleUser? = nil, body: String, bodyHTML: String, bodyVersion: String, commentsCount: Int, commentsURL: URL, createdAt: Date, lastEditedAt: Date? = nil, htmlURL: URL, nodeID: String, number: Int, isPinned: Bool, isPrivate: Bool, teamURL: URL, title: String, updatedAt: Date, url: URL, reactions: ReactionRollup? = nil) {
        self.author = author
        self.body = body
        self.bodyHTML = bodyHTML
        self.bodyVersion = bodyVersion
        self.commentsCount = commentsCount
        self.commentsURL = commentsURL
        self.createdAt = createdAt
        self.lastEditedAt = lastEditedAt
        self.htmlURL = htmlURL
        self.nodeID = nodeID
        self.number = number
        self.isPinned = isPinned
        self.isPrivate = isPrivate
        self.teamURL = teamURL
        self.title = title
        self.updatedAt = updatedAt
        self.url = url
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.author = try values.decodeIfPresent(SimpleUser.self, forKey: "author")
        self.body = try values.decode(String.self, forKey: "body")
        self.bodyHTML = try values.decode(String.self, forKey: "body_html")
        self.bodyVersion = try values.decode(String.self, forKey: "body_version")
        self.commentsCount = try values.decode(Int.self, forKey: "comments_count")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.lastEditedAt = try values.decodeIfPresent(Date.self, forKey: "last_edited_at")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.isPinned = try values.decode(Bool.self, forKey: "pinned")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.teamURL = try values.decode(URL.self, forKey: "team_url")
        self.title = try values.decode(String.self, forKey: "title")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(author, forKey: "author")
        try values.encode(body, forKey: "body")
        try values.encode(bodyHTML, forKey: "body_html")
        try values.encode(bodyVersion, forKey: "body_version")
        try values.encode(commentsCount, forKey: "comments_count")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(lastEditedAt, forKey: "last_edited_at")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(number, forKey: "number")
        try values.encode(isPinned, forKey: "pinned")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(teamURL, forKey: "team_url")
        try values.encode(title, forKey: "title")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

/// A reply to a discussion within a team.
public struct TeamDiscussionComment: Codable {
    /// Simple User
    public var author: SimpleUser?
    /// The main text of the comment.
    ///
    /// Example: "I agree with this suggestion."
    public var body: String
    /// Example: "<p>Do you like apples?</p>"
    public var bodyHTML: String
    /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
    ///
    /// Example: "0307116bbf7ced493b8d8a346c650b71"
    public var bodyVersion: String
    /// Example: "2018-01-15T23:53:58Z"
    public var createdAt: Date
    public var lastEditedAt: Date?
    /// Example: "https://api.github.com/organizations/1/team/2403582/discussions/1"
    public var discussionURL: URL
    /// Example: "https://github.com/orgs/github/teams/justice-league/discussions/1/comments/1"
    public var htmlURL: URL
    /// Example: "MDIxOlRlYW1EaXNjdXNzaW9uQ29tbWVudDE="
    public var nodeID: String
    /// The unique sequence number of a team discussion comment.
    ///
    /// Example: 42
    public var number: Int
    /// Example: "2018-01-15T23:53:58Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/organizations/1/team/2403582/discussions/1/comments/1"
    public var url: URL
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(author: SimpleUser? = nil, body: String, bodyHTML: String, bodyVersion: String, createdAt: Date, lastEditedAt: Date? = nil, discussionURL: URL, htmlURL: URL, nodeID: String, number: Int, updatedAt: Date, url: URL, reactions: ReactionRollup? = nil) {
        self.author = author
        self.body = body
        self.bodyHTML = bodyHTML
        self.bodyVersion = bodyVersion
        self.createdAt = createdAt
        self.lastEditedAt = lastEditedAt
        self.discussionURL = discussionURL
        self.htmlURL = htmlURL
        self.nodeID = nodeID
        self.number = number
        self.updatedAt = updatedAt
        self.url = url
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.author = try values.decodeIfPresent(SimpleUser.self, forKey: "author")
        self.body = try values.decode(String.self, forKey: "body")
        self.bodyHTML = try values.decode(String.self, forKey: "body_html")
        self.bodyVersion = try values.decode(String.self, forKey: "body_version")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.lastEditedAt = try values.decodeIfPresent(Date.self, forKey: "last_edited_at")
        self.discussionURL = try values.decode(URL.self, forKey: "discussion_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(author, forKey: "author")
        try values.encode(body, forKey: "body")
        try values.encode(bodyHTML, forKey: "body_html")
        try values.encode(bodyVersion, forKey: "body_version")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(lastEditedAt, forKey: "last_edited_at")
        try values.encode(discussionURL, forKey: "discussion_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(number, forKey: "number")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

/// Reactions to conversations provide a way to help people express their feelings more simply and effectively.
public struct Reaction: Codable {
    public var id: Int
    /// Example: "MDg6UmVhY3Rpb24x"
    public var nodeID: String
    /// Simple User
    public var user: SimpleUser?
    /// The reaction to use
    ///
    /// Example: "heart"
    public var content: Content
    /// Example: "2016-05-20T20:09:31Z"
    public var createdAt: Date

    /// The reaction to use
    ///
    /// Example: "heart"
    public enum Content: String, Codable, CaseIterable {
        case plus1 = "+1"
        case minus1 = "-1"
        case laugh
        case confused
        case heart
        case hooray
        case rocket
        case eyes
    }

    public init(id: Int, nodeID: String, user: SimpleUser? = nil, content: Content, createdAt: Date) {
        self.id = id
        self.nodeID = nodeID
        self.user = user
        self.content = content
        self.createdAt = createdAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.content = try values.decode(Content.self, forKey: "content")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(content, forKey: "content")
        try values.encode(createdAt, forKey: "created_at")
    }
}

public struct TeamMembership: Codable {
    public var url: URL
    /// The role of the user in the team.
    ///
    /// Example: "member"
    public var role: Role
    /// The state of the user's membership in the team.
    public var state: State

    /// The role of the user in the team.
    ///
    /// Example: "member"
    public enum Role: String, Codable, CaseIterable {
        case member
        case maintainer
    }

    /// The state of the user's membership in the team.
    public enum State: String, Codable, CaseIterable {
        case active
        case pending
    }

    public init(url: URL, role: Role, state: State) {
        self.url = url
        self.role = role
        self.state = state
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.role = try values.decode(Role.self, forKey: "role")
        self.state = try values.decode(State.self, forKey: "state")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(role, forKey: "role")
        try values.encode(state, forKey: "state")
    }
}

/// A team's access to a project.
public struct TeamProject: Codable {
    public var ownerURL: String
    public var url: String
    public var htmlURL: String
    public var columnsURL: String
    public var id: Int
    public var nodeID: String
    public var name: String
    public var body: String?
    public var number: Int
    public var state: String
    /// Simple User
    public var creator: SimpleUser
    public var createdAt: String
    public var updatedAt: String
    /// The organization permission for this project. Only present when owner is an organization.
    public var organizationPermission: String?
    /// Whether the project is private or not. Only present when owner is an organization.
    public var isPrivate: Bool?
    public var permissions: Permissions

    public struct Permissions: Codable {
        public var isRead: Bool
        public var isWrite: Bool
        public var isAdmin: Bool

        public init(isRead: Bool, isWrite: Bool, isAdmin: Bool) {
            self.isRead = isRead
            self.isWrite = isWrite
            self.isAdmin = isAdmin
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isRead = try values.decode(Bool.self, forKey: "read")
            self.isWrite = try values.decode(Bool.self, forKey: "write")
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isRead, forKey: "read")
            try values.encode(isWrite, forKey: "write")
            try values.encode(isAdmin, forKey: "admin")
        }
    }

    public init(ownerURL: String, url: String, htmlURL: String, columnsURL: String, id: Int, nodeID: String, name: String, body: String? = nil, number: Int, state: String, creator: SimpleUser, createdAt: String, updatedAt: String, organizationPermission: String? = nil, isPrivate: Bool? = nil, permissions: Permissions) {
        self.ownerURL = ownerURL
        self.url = url
        self.htmlURL = htmlURL
        self.columnsURL = columnsURL
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.body = body
        self.number = number
        self.state = state
        self.creator = creator
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.organizationPermission = organizationPermission
        self.isPrivate = isPrivate
        self.permissions = permissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ownerURL = try values.decode(String.self, forKey: "owner_url")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.columnsURL = try values.decode(String.self, forKey: "columns_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(String.self, forKey: "state")
        self.creator = try values.decode(SimpleUser.self, forKey: "creator")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        self.organizationPermission = try values.decodeIfPresent(String.self, forKey: "organization_permission")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "private")
        self.permissions = try values.decode(Permissions.self, forKey: "permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ownerURL, forKey: "owner_url")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(columnsURL, forKey: "columns_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encode(creator, forKey: "creator")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(organizationPermission, forKey: "organization_permission")
        try values.encodeIfPresent(isPrivate, forKey: "private")
        try values.encode(permissions, forKey: "permissions")
    }
}

/// A team's access to a repository.
public struct TeamRepository: Codable {
    /// Unique identifier of the repository
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEwOlJlcG9zaXRvcnkxMjk2MjY5"
    public var nodeID: String
    /// The name of the repository.
    ///
    /// Example: "Team Environment"
    public var name: String
    /// Example: "octocat/Hello-World"
    public var fullName: String
    /// License Simple
    public var license: LicenseSimple?
    public var forks: Int
    public var permissions: Permissions?
    /// Example: "admin"
    public var roleName: String?
    /// Simple User
    public var owner: SimpleUser?
    /// Whether the repository is private or public.
    public var isPrivate: Bool
    /// Example: "https://github.com/octocat/Hello-World"
    public var htmlURL: URL
    /// Example: "This your first repo!"
    public var description: String?
    public var isFork: Bool
    /// Example: "https://api.github.com/repos/octocat/Hello-World"
    public var url: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"
    public var archiveURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/assignees{/user}"
    public var assigneesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"
    public var blobsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/branches{/branch}"
    public var branchesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"
    public var collaboratorsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/comments{/number}"
    public var commentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/commits{/sha}"
    public var commitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"
    public var compareURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contents/{+path}"
    public var contentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contributors"
    public var contributorsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/deployments"
    public var deploymentsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/downloads"
    public var downloadsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/events"
    public var eventsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/forks"
    public var forksURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"
    public var gitCommitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"
    public var gitRefsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"
    public var gitTagsURL: String
    /// Example: "git:github.com/octocat/Hello-World.git"
    public var gitURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"
    public var issueCommentURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"
    public var issueEventsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues{/number}"
    public var issuesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"
    public var keysURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/labels{/name}"
    public var labelsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/languages"
    public var languagesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/merges"
    public var mergesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/milestones{/number}"
    public var milestonesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"
    public var notificationsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/pulls{/number}"
    public var pullsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/releases{/id}"
    public var releasesURL: String
    /// Example: "git@github.com:octocat/Hello-World.git"
    public var sshURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/stargazers"
    public var stargazersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"
    public var statusesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscribers"
    public var subscribersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscription"
    public var subscriptionURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/tags"
    public var tagsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/teams"
    public var teamsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"
    public var treesURL: String
    /// Example: "https://github.com/octocat/Hello-World.git"
    public var cloneURL: String
    /// Example: "git:git.example.com/octocat/Hello-World"
    public var mirrorURL: URL?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/hooks"
    public var hooksURL: URL
    /// Example: "https://svn.github.com/octocat/Hello-World"
    public var svnURL: URL
    /// Example: "https://github.com"
    public var homepage: URL?
    public var language: String?
    public var forksCount: Int
    /// Example: 80
    public var stargazersCount: Int
    /// Example: 80
    public var watchersCount: Int
    /// Example: 108
    public var size: Int
    /// The default branch of the repository.
    ///
    /// Example: "master"
    public var defaultBranch: String
    public var openIssuesCount: Int
    /// Whether this repository acts as a template that can be used to generate new repositories.
    ///
    /// Example: true
    public var isTemplate: Bool
    public var topics: [String]?
    /// Whether issues are enabled.
    ///
    /// Example: true
    public var hasIssues: Bool
    /// Whether projects are enabled.
    ///
    /// Example: true
    public var hasProjects: Bool
    /// Whether the wiki is enabled.
    ///
    /// Example: true
    public var hasWiki: Bool
    public var hasPages: Bool
    /// Whether downloads are enabled.
    ///
    /// Example: true
    public var hasDownloads: Bool
    /// Whether the repository is archived.
    public var isArchived: Bool
    /// Returns whether or not this repository disabled.
    public var isDisabled: Bool
    /// The repository visibility: public, private, or internal.
    public var visibility: String?
    /// Example: "2011-01-26T19:06:43Z"
    public var pushedAt: Date?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date?
    /// Example: "2011-01-26T19:14:43Z"
    public var updatedAt: Date?
    /// Whether to allow rebase merges for pull requests.
    ///
    /// Example: true
    public var allowRebaseMerge: Bool
    /// Repository
    ///
    /// A git repository
    public var templateRepository: Repository?
    public var tempCloneToken: String?
    /// Whether to allow squash merges for pull requests.
    ///
    /// Example: true
    public var allowSquashMerge: Bool
    /// Whether to allow Auto-merge to be used on pull requests.
    ///
    /// Example: false
    public var allowAutoMerge: Bool
    /// Whether to delete head branches when pull requests are merged
    ///
    /// Example: false
    public var deleteBranchOnMerge: Bool
    /// Whether to allow merge commits for pull requests.
    ///
    /// Example: true
    public var allowMergeCommit: Bool
    /// Whether to allow forking this repo
    ///
    /// Example: false
    public var allowForking: Bool
    public var subscribersCount: Int?
    public var networkCount: Int?
    public var openIssues: Int
    public var watchers: Int
    public var masterBranch: String?

    public struct Permissions: Codable {
        public var isAdmin: Bool
        public var isPull: Bool
        public var isTriage: Bool?
        public var isPush: Bool
        public var isMaintain: Bool?

        public init(isAdmin: Bool, isPull: Bool, isTriage: Bool? = nil, isPush: Bool, isMaintain: Bool? = nil) {
            self.isAdmin = isAdmin
            self.isPull = isPull
            self.isTriage = isTriage
            self.isPush = isPush
            self.isMaintain = isMaintain
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
            self.isPull = try values.decode(Bool.self, forKey: "pull")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isAdmin, forKey: "admin")
            try values.encode(isPull, forKey: "pull")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encode(isPush, forKey: "push")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
        }
    }

    public init(id: Int, nodeID: String, name: String, fullName: String, license: LicenseSimple? = nil, forks: Int, permissions: Permissions? = nil, roleName: String? = nil, owner: SimpleUser? = nil, isPrivate: Bool, htmlURL: URL, description: String? = nil, isFork: Bool, url: URL, archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, downloadsURL: URL, eventsURL: URL, forksURL: URL, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, gitURL: String, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, notificationsURL: String, pullsURL: String, releasesURL: String, sshURL: String, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, cloneURL: String, mirrorURL: URL? = nil, hooksURL: URL, svnURL: URL, homepage: URL? = nil, language: String? = nil, forksCount: Int, stargazersCount: Int, watchersCount: Int, size: Int, defaultBranch: String, openIssuesCount: Int, isTemplate: Bool? = nil, topics: [String]? = nil, hasIssues: Bool, hasProjects: Bool, hasWiki: Bool, hasPages: Bool, hasDownloads: Bool, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, pushedAt: Date? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, allowRebaseMerge: Bool? = nil, templateRepository: Repository? = nil, tempCloneToken: String? = nil, allowSquashMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowForking: Bool? = nil, subscribersCount: Int? = nil, networkCount: Int? = nil, openIssues: Int, watchers: Int, masterBranch: String? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.fullName = fullName
        self.license = license
        self.forks = forks
        self.permissions = permissions
        self.roleName = roleName
        self.owner = owner
        self.isPrivate = isPrivate
        self.htmlURL = htmlURL
        self.description = description
        self.isFork = isFork
        self.url = url
        self.archiveURL = archiveURL
        self.assigneesURL = assigneesURL
        self.blobsURL = blobsURL
        self.branchesURL = branchesURL
        self.collaboratorsURL = collaboratorsURL
        self.commentsURL = commentsURL
        self.commitsURL = commitsURL
        self.compareURL = compareURL
        self.contentsURL = contentsURL
        self.contributorsURL = contributorsURL
        self.deploymentsURL = deploymentsURL
        self.downloadsURL = downloadsURL
        self.eventsURL = eventsURL
        self.forksURL = forksURL
        self.gitCommitsURL = gitCommitsURL
        self.gitRefsURL = gitRefsURL
        self.gitTagsURL = gitTagsURL
        self.gitURL = gitURL
        self.issueCommentURL = issueCommentURL
        self.issueEventsURL = issueEventsURL
        self.issuesURL = issuesURL
        self.keysURL = keysURL
        self.labelsURL = labelsURL
        self.languagesURL = languagesURL
        self.mergesURL = mergesURL
        self.milestonesURL = milestonesURL
        self.notificationsURL = notificationsURL
        self.pullsURL = pullsURL
        self.releasesURL = releasesURL
        self.sshURL = sshURL
        self.stargazersURL = stargazersURL
        self.statusesURL = statusesURL
        self.subscribersURL = subscribersURL
        self.subscriptionURL = subscriptionURL
        self.tagsURL = tagsURL
        self.teamsURL = teamsURL
        self.treesURL = treesURL
        self.cloneURL = cloneURL
        self.mirrorURL = mirrorURL
        self.hooksURL = hooksURL
        self.svnURL = svnURL
        self.homepage = homepage
        self.language = language
        self.forksCount = forksCount
        self.stargazersCount = stargazersCount
        self.watchersCount = watchersCount
        self.size = size
        self.defaultBranch = defaultBranch
        self.openIssuesCount = openIssuesCount
        self.isTemplate = isTemplate ?? false
        self.topics = topics
        self.hasIssues = hasIssues
        self.hasProjects = hasProjects
        self.hasWiki = hasWiki
        self.hasPages = hasPages
        self.hasDownloads = hasDownloads
        self.isArchived = isArchived
        self.isDisabled = isDisabled
        self.visibility = visibility
        self.pushedAt = pushedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.allowRebaseMerge = allowRebaseMerge ?? true
        self.templateRepository = templateRepository
        self.tempCloneToken = tempCloneToken
        self.allowSquashMerge = allowSquashMerge ?? true
        self.allowAutoMerge = allowAutoMerge ?? false
        self.deleteBranchOnMerge = deleteBranchOnMerge ?? false
        self.allowMergeCommit = allowMergeCommit ?? true
        self.allowForking = allowForking ?? false
        self.subscribersCount = subscribersCount
        self.networkCount = networkCount
        self.openIssues = openIssues
        self.watchers = watchers
        self.masterBranch = masterBranch
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.fullName = try values.decode(String.self, forKey: "full_name")
        self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
        self.forks = try values.decode(Int.self, forKey: "forks")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.roleName = try values.decodeIfPresent(String.self, forKey: "role_name")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isFork = try values.decode(Bool.self, forKey: "fork")
        self.url = try values.decode(URL.self, forKey: "url")
        self.archiveURL = try values.decode(String.self, forKey: "archive_url")
        self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
        self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
        self.branchesURL = try values.decode(String.self, forKey: "branches_url")
        self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
        self.commentsURL = try values.decode(String.self, forKey: "comments_url")
        self.commitsURL = try values.decode(String.self, forKey: "commits_url")
        self.compareURL = try values.decode(String.self, forKey: "compare_url")
        self.contentsURL = try values.decode(String.self, forKey: "contents_url")
        self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
        self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
        self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
        self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
        self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
        self.gitURL = try values.decode(String.self, forKey: "git_url")
        self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
        self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.keysURL = try values.decode(String.self, forKey: "keys_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
        self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
        self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
        self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
        self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
        self.releasesURL = try values.decode(String.self, forKey: "releases_url")
        self.sshURL = try values.decode(String.self, forKey: "ssh_url")
        self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
        self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
        self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
        self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
        self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.treesURL = try values.decode(String.self, forKey: "trees_url")
        self.cloneURL = try values.decode(String.self, forKey: "clone_url")
        self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
        self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
        self.svnURL = try values.decode(URL.self, forKey: "svn_url")
        self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.forksCount = try values.decode(Int.self, forKey: "forks_count")
        self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
        self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
        self.size = try values.decode(Int.self, forKey: "size")
        self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
        self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
        self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template") ?? false
        self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
        self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
        self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
        self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
        self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
        self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
        self.isArchived = try values.decode(Bool.self, forKey: "archived")
        self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
        self.pushedAt = try values.decodeIfPresent(Date.self, forKey: "pushed_at")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge") ?? true
        self.templateRepository = try values.decodeIfPresent(Repository.self, forKey: "template_repository")
        self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
        self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge") ?? true
        self.allowAutoMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_auto_merge") ?? false
        self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge") ?? false
        self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit") ?? true
        self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking") ?? false
        self.subscribersCount = try values.decodeIfPresent(Int.self, forKey: "subscribers_count")
        self.networkCount = try values.decodeIfPresent(Int.self, forKey: "network_count")
        self.openIssues = try values.decode(Int.self, forKey: "open_issues")
        self.watchers = try values.decode(Int.self, forKey: "watchers")
        self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(fullName, forKey: "full_name")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encode(forks, forKey: "forks")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(roleName, forKey: "role_name")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isFork, forKey: "fork")
        try values.encode(url, forKey: "url")
        try values.encode(archiveURL, forKey: "archive_url")
        try values.encode(assigneesURL, forKey: "assignees_url")
        try values.encode(blobsURL, forKey: "blobs_url")
        try values.encode(branchesURL, forKey: "branches_url")
        try values.encode(collaboratorsURL, forKey: "collaborators_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(compareURL, forKey: "compare_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encode(contributorsURL, forKey: "contributors_url")
        try values.encode(deploymentsURL, forKey: "deployments_url")
        try values.encode(downloadsURL, forKey: "downloads_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(gitCommitsURL, forKey: "git_commits_url")
        try values.encode(gitRefsURL, forKey: "git_refs_url")
        try values.encode(gitTagsURL, forKey: "git_tags_url")
        try values.encode(gitURL, forKey: "git_url")
        try values.encode(issueCommentURL, forKey: "issue_comment_url")
        try values.encode(issueEventsURL, forKey: "issue_events_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(keysURL, forKey: "keys_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(languagesURL, forKey: "languages_url")
        try values.encode(mergesURL, forKey: "merges_url")
        try values.encode(milestonesURL, forKey: "milestones_url")
        try values.encode(notificationsURL, forKey: "notifications_url")
        try values.encode(pullsURL, forKey: "pulls_url")
        try values.encode(releasesURL, forKey: "releases_url")
        try values.encode(sshURL, forKey: "ssh_url")
        try values.encode(stargazersURL, forKey: "stargazers_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(subscribersURL, forKey: "subscribers_url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
        try values.encode(tagsURL, forKey: "tags_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(treesURL, forKey: "trees_url")
        try values.encode(cloneURL, forKey: "clone_url")
        try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(svnURL, forKey: "svn_url")
        try values.encodeIfPresent(homepage, forKey: "homepage")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encode(forksCount, forKey: "forks_count")
        try values.encode(stargazersCount, forKey: "stargazers_count")
        try values.encode(watchersCount, forKey: "watchers_count")
        try values.encode(size, forKey: "size")
        try values.encode(defaultBranch, forKey: "default_branch")
        try values.encode(openIssuesCount, forKey: "open_issues_count")
        try values.encodeIfPresent(isTemplate, forKey: "is_template")
        try values.encodeIfPresent(topics, forKey: "topics")
        try values.encode(hasIssues, forKey: "has_issues")
        try values.encode(hasProjects, forKey: "has_projects")
        try values.encode(hasWiki, forKey: "has_wiki")
        try values.encode(hasPages, forKey: "has_pages")
        try values.encode(hasDownloads, forKey: "has_downloads")
        try values.encode(isArchived, forKey: "archived")
        try values.encode(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(visibility, forKey: "visibility")
        try values.encodeIfPresent(pushedAt, forKey: "pushed_at")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
        try values.encodeIfPresent(templateRepository, forKey: "template_repository")
        try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
        try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
        try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
        try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
        try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
        try values.encodeIfPresent(allowForking, forKey: "allow_forking")
        try values.encodeIfPresent(subscribersCount, forKey: "subscribers_count")
        try values.encodeIfPresent(networkCount, forKey: "network_count")
        try values.encode(openIssues, forKey: "open_issues")
        try values.encode(watchers, forKey: "watchers")
        try values.encodeIfPresent(masterBranch, forKey: "master_branch")
    }
}

/// Project cards represent a scope of work.
public struct ProjectCard: Codable {
    /// Example: "https://api.github.com/projects/columns/cards/1478"
    public var url: URL
    /// The project card's ID
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDExOlByb2plY3RDYXJkMTQ3OA=="
    public var nodeID: String
    /// Example: "Add payload for delete Project column"
    public var note: String?
    /// Simple User
    public var creator: SimpleUser?
    /// Example: "2016-09-05T14:21:06Z"
    public var createdAt: Date
    /// Example: "2016-09-05T14:20:22Z"
    public var updatedAt: Date
    /// Whether or not the card is archived
    ///
    /// Example: false
    public var isArchived: Bool?
    public var columnName: String?
    public var projectID: String?
    /// Example: "https://api.github.com/projects/columns/367"
    public var columnURL: URL
    /// Example: "https://api.github.com/repos/api-playground/projects-test/issues/3"
    public var contentURL: URL?
    /// Example: "https://api.github.com/projects/120"
    public var projectURL: URL

    public init(url: URL, id: Int, nodeID: String, note: String? = nil, creator: SimpleUser? = nil, createdAt: Date, updatedAt: Date, isArchived: Bool? = nil, columnName: String? = nil, projectID: String? = nil, columnURL: URL, contentURL: URL? = nil, projectURL: URL) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.note = note
        self.creator = creator
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.isArchived = isArchived
        self.columnName = columnName
        self.projectID = projectID
        self.columnURL = columnURL
        self.contentURL = contentURL
        self.projectURL = projectURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.note = try values.decodeIfPresent(String.self, forKey: "note")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.isArchived = try values.decodeIfPresent(Bool.self, forKey: "archived")
        self.columnName = try values.decodeIfPresent(String.self, forKey: "column_name")
        self.projectID = try values.decodeIfPresent(String.self, forKey: "project_id")
        self.columnURL = try values.decode(URL.self, forKey: "column_url")
        self.contentURL = try values.decodeIfPresent(URL.self, forKey: "content_url")
        self.projectURL = try values.decode(URL.self, forKey: "project_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(note, forKey: "note")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(isArchived, forKey: "archived")
        try values.encodeIfPresent(columnName, forKey: "column_name")
        try values.encodeIfPresent(projectID, forKey: "project_id")
        try values.encode(columnURL, forKey: "column_url")
        try values.encodeIfPresent(contentURL, forKey: "content_url")
        try values.encode(projectURL, forKey: "project_url")
    }
}

/// Project columns contain cards of work.
public struct ProjectColumn: Codable {
    /// Example: "https://api.github.com/projects/columns/367"
    public var url: URL
    /// Example: "https://api.github.com/projects/120"
    public var projectURL: URL
    /// Example: "https://api.github.com/projects/columns/367/cards"
    public var cardsURL: URL
    /// The unique identifier of the project column
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEzOlByb2plY3RDb2x1bW4zNjc="
    public var nodeID: String
    /// Name of the project column
    ///
    /// Example: "Remaining tasks"
    public var name: String
    /// Example: "2016-09-05T14:18:44Z"
    public var createdAt: Date
    /// Example: "2016-09-05T14:22:28Z"
    public var updatedAt: Date

    public init(url: URL, projectURL: URL, cardsURL: URL, id: Int, nodeID: String, name: String, createdAt: Date, updatedAt: Date) {
        self.url = url
        self.projectURL = projectURL
        self.cardsURL = cardsURL
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.projectURL = try values.decode(URL.self, forKey: "project_url")
        self.cardsURL = try values.decode(URL.self, forKey: "cards_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(projectURL, forKey: "project_url")
        try values.encode(cardsURL, forKey: "cards_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

public struct ProjectCollaboratorPermission: Codable {
    public var permission: String
    /// Simple User
    public var user: SimpleUser?

    public init(permission: String, user: SimpleUser? = nil) {
        self.permission = permission
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.permission = try values.decode(String.self, forKey: "permission")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(permission, forKey: "permission")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct RateLimit: Codable {
    public var limit: Int
    public var remaining: Int
    public var reset: Int
    public var used: Int

    public init(limit: Int, remaining: Int, reset: Int, used: Int) {
        self.limit = limit
        self.remaining = remaining
        self.reset = reset
        self.used = used
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decode(Int.self, forKey: "limit")
        self.remaining = try values.decode(Int.self, forKey: "remaining")
        self.reset = try values.decode(Int.self, forKey: "reset")
        self.used = try values.decode(Int.self, forKey: "used")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(limit, forKey: "limit")
        try values.encode(remaining, forKey: "remaining")
        try values.encode(reset, forKey: "reset")
        try values.encode(used, forKey: "used")
    }
}

public struct RateLimitOverview: Codable {
    public var resources: Resources
    /// Rate Limit
    public var rate: RateLimit

    public struct Resources: Codable {
        /// Rate Limit
        public var core: RateLimit
        /// Rate Limit
        public var graphql: RateLimit?
        /// Rate Limit
        public var search: RateLimit
        /// Rate Limit
        public var sourceImport: RateLimit?
        /// Rate Limit
        public var integrationManifest: RateLimit?
        /// Rate Limit
        public var codeScanningUpload: RateLimit?
        /// Rate Limit
        public var actionsRunnerRegistration: RateLimit?
        /// Rate Limit
        public var scim: RateLimit?

        public init(core: RateLimit, graphql: RateLimit? = nil, search: RateLimit, sourceImport: RateLimit? = nil, integrationManifest: RateLimit? = nil, codeScanningUpload: RateLimit? = nil, actionsRunnerRegistration: RateLimit? = nil, scim: RateLimit? = nil) {
            self.core = core
            self.graphql = graphql
            self.search = search
            self.sourceImport = sourceImport
            self.integrationManifest = integrationManifest
            self.codeScanningUpload = codeScanningUpload
            self.actionsRunnerRegistration = actionsRunnerRegistration
            self.scim = scim
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.core = try values.decode(RateLimit.self, forKey: "core")
            self.graphql = try values.decodeIfPresent(RateLimit.self, forKey: "graphql")
            self.search = try values.decode(RateLimit.self, forKey: "search")
            self.sourceImport = try values.decodeIfPresent(RateLimit.self, forKey: "source_import")
            self.integrationManifest = try values.decodeIfPresent(RateLimit.self, forKey: "integration_manifest")
            self.codeScanningUpload = try values.decodeIfPresent(RateLimit.self, forKey: "code_scanning_upload")
            self.actionsRunnerRegistration = try values.decodeIfPresent(RateLimit.self, forKey: "actions_runner_registration")
            self.scim = try values.decodeIfPresent(RateLimit.self, forKey: "scim")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(core, forKey: "core")
            try values.encodeIfPresent(graphql, forKey: "graphql")
            try values.encode(search, forKey: "search")
            try values.encodeIfPresent(sourceImport, forKey: "source_import")
            try values.encodeIfPresent(integrationManifest, forKey: "integration_manifest")
            try values.encodeIfPresent(codeScanningUpload, forKey: "code_scanning_upload")
            try values.encodeIfPresent(actionsRunnerRegistration, forKey: "actions_runner_registration")
            try values.encodeIfPresent(scim, forKey: "scim")
        }
    }

    public init(resources: Resources, rate: RateLimit) {
        self.resources = resources
        self.rate = rate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.resources = try values.decode(Resources.self, forKey: "resources")
        self.rate = try values.decode(RateLimit.self, forKey: "rate")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(resources, forKey: "resources")
        try values.encode(rate, forKey: "rate")
    }
}

/// Code of Conduct Simple
public struct CodeOfConductSimple: Codable {
    /// Example: "https://api.github.com/repos/github/docs/community/code_of_conduct"
    public var url: URL
    /// Example: "citizen_code_of_conduct"
    public var key: String
    /// Example: "Citizen Code of Conduct"
    public var name: String
    /// Example: "https://github.com/github/docs/blob/main/CODE_OF_CONDUCT.md"
    public var htmlURL: URL?

    public init(url: URL, key: String, name: String, htmlURL: URL? = nil) {
        self.url = url
        self.key = key
        self.name = name
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.key = try values.decode(String.self, forKey: "key")
        self.name = try values.decode(String.self, forKey: "name")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(key, forKey: "key")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
    }
}

public struct FullRepository: Codable {
    /// Example: 1296269
    public var id: Int
    /// Example: "MDEwOlJlcG9zaXRvcnkxMjk2MjY5"
    public var nodeID: String
    /// Example: "Hello-World"
    public var name: String
    /// Example: "octocat/Hello-World"
    public var fullName: String
    /// Simple User
    public var owner: SimpleUser
    public var isPrivate: Bool
    /// Example: "https://github.com/octocat/Hello-World"
    public var htmlURL: URL
    /// Example: "This your first repo!"
    public var description: String?
    public var isFork: Bool
    /// Example: "https://api.github.com/repos/octocat/Hello-World"
    public var url: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}"
    public var archiveURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/assignees{/user}"
    public var assigneesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}"
    public var blobsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/branches{/branch}"
    public var branchesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}"
    public var collaboratorsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/comments{/number}"
    public var commentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/commits{/sha}"
    public var commitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}"
    public var compareURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contents/{+path}"
    public var contentsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/contributors"
    public var contributorsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/deployments"
    public var deploymentsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/downloads"
    public var downloadsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/events"
    public var eventsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/forks"
    public var forksURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/commits{/sha}"
    public var gitCommitsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/refs{/sha}"
    public var gitRefsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/tags{/sha}"
    public var gitTagsURL: String
    /// Example: "git:github.com/octocat/Hello-World.git"
    public var gitURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/comments{/number}"
    public var issueCommentURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues/events{/number}"
    public var issueEventsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/issues{/number}"
    public var issuesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/keys{/key_id}"
    public var keysURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/labels{/name}"
    public var labelsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/languages"
    public var languagesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/merges"
    public var mergesURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/milestones{/number}"
    public var milestonesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}"
    public var notificationsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/pulls{/number}"
    public var pullsURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/releases{/id}"
    public var releasesURL: String
    /// Example: "git@github.com:octocat/Hello-World.git"
    public var sshURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/stargazers"
    public var stargazersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/statuses/{sha}"
    public var statusesURL: String
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscribers"
    public var subscribersURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/subscription"
    public var subscriptionURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/tags"
    public var tagsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/teams"
    public var teamsURL: URL
    /// Example: "http://api.github.com/repos/octocat/Hello-World/git/trees{/sha}"
    public var treesURL: String
    /// Example: "https://github.com/octocat/Hello-World.git"
    public var cloneURL: String
    /// Example: "git:git.example.com/octocat/Hello-World"
    public var mirrorURL: URL?
    /// Example: "http://api.github.com/repos/octocat/Hello-World/hooks"
    public var hooksURL: URL
    /// Example: "https://svn.github.com/octocat/Hello-World"
    public var svnURL: URL
    /// Example: "https://github.com"
    public var homepage: URL?
    public var language: String?
    public var forksCount: Int
    /// Example: 80
    public var stargazersCount: Int
    /// Example: 80
    public var watchersCount: Int
    /// Example: 108
    public var size: Int
    /// Example: "master"
    public var defaultBranch: String
    public var openIssuesCount: Int
    /// Example: true
    public var isTemplate: Bool?
    /// Example: ["octocat", "atom", "electron", "API"]
    public var topics: [String]?
    /// Example: true
    public var hasIssues: Bool
    /// Example: true
    public var hasProjects: Bool
    /// Example: true
    public var hasWiki: Bool
    public var hasPages: Bool
    /// Example: true
    public var hasDownloads: Bool
    public var isArchived: Bool
    /// Returns whether or not this repository disabled.
    public var isDisabled: Bool
    /// The repository visibility: public, private, or internal.
    ///
    /// Example: "public"
    public var visibility: String?
    /// Example: "2011-01-26T19:06:43Z"
    public var pushedAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date
    /// Example: "2011-01-26T19:14:43Z"
    public var updatedAt: Date
    public var permissions: Permissions?
    /// Example: true
    public var allowRebaseMerge: Bool?
    /// Repository
    ///
    /// A git repository
    public var templateRepository: Repository?
    public var tempCloneToken: String?
    /// Example: true
    public var allowSquashMerge: Bool?
    /// Example: false
    public var allowAutoMerge: Bool?
    /// Example: false
    public var deleteBranchOnMerge: Bool?
    /// Example: true
    public var allowMergeCommit: Bool?
    /// Example: true
    public var allowForking: Bool?
    /// Example: 42
    public var subscribersCount: Int
    public var networkCount: Int
    /// License Simple
    public var license: LicenseSimple?
    /// Simple User
    public var organization: SimpleUser?
    /// Repository
    ///
    /// A git repository
    public var parent: Repository?
    /// Repository
    ///
    /// A git repository
    public var source: Repository?
    public var forks: Int
    public var masterBranch: String?
    public var openIssues: Int
    public var watchers: Int
    /// Whether anonymous git access is allowed.
    public var isAnonymousAccessEnabled: Bool
    /// Code Of Conduct Simple
    ///
    /// Code of Conduct Simple
    public var codeOfConduct: CodeOfConductSimple?
    public var securityAndAnalysis: SecurityAndAnalysis?

    public struct Permissions: Codable {
        public var isAdmin: Bool
        public var isMaintain: Bool?
        public var isPush: Bool
        public var isTriage: Bool?
        public var isPull: Bool

        public init(isAdmin: Bool, isMaintain: Bool? = nil, isPush: Bool, isTriage: Bool? = nil, isPull: Bool) {
            self.isAdmin = isAdmin
            self.isMaintain = isMaintain
            self.isPush = isPush
            self.isTriage = isTriage
            self.isPull = isPull
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPull = try values.decode(Bool.self, forKey: "pull")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isAdmin, forKey: "admin")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
            try values.encode(isPush, forKey: "push")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encode(isPull, forKey: "pull")
        }
    }

    public struct SecurityAndAnalysis: Codable {
        public var advancedSecurity: AdvancedSecurity?
        public var secretScanning: SecretScanning?

        public struct AdvancedSecurity: Codable {
            public var status: Status?

            public enum Status: String, Codable, CaseIterable {
                case enabled
                case disabled
            }

            public init(status: Status? = nil) {
                self.status = status
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.status = try values.decodeIfPresent(Status.self, forKey: "status")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(status, forKey: "status")
            }
        }

        public struct SecretScanning: Codable {
            public var status: Status?

            public enum Status: String, Codable, CaseIterable {
                case enabled
                case disabled
            }

            public init(status: Status? = nil) {
                self.status = status
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.status = try values.decodeIfPresent(Status.self, forKey: "status")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(status, forKey: "status")
            }
        }

        public init(advancedSecurity: AdvancedSecurity? = nil, secretScanning: SecretScanning? = nil) {
            self.advancedSecurity = advancedSecurity
            self.secretScanning = secretScanning
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.advancedSecurity = try values.decodeIfPresent(AdvancedSecurity.self, forKey: "advanced_security")
            self.secretScanning = try values.decodeIfPresent(SecretScanning.self, forKey: "secret_scanning")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(advancedSecurity, forKey: "advanced_security")
            try values.encodeIfPresent(secretScanning, forKey: "secret_scanning")
        }
    }

    public init(id: Int, nodeID: String, name: String, fullName: String, owner: SimpleUser, isPrivate: Bool, htmlURL: URL, description: String? = nil, isFork: Bool, url: URL, archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, downloadsURL: URL, eventsURL: URL, forksURL: URL, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, gitURL: String, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, notificationsURL: String, pullsURL: String, releasesURL: String, sshURL: String, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, cloneURL: String, mirrorURL: URL? = nil, hooksURL: URL, svnURL: URL, homepage: URL? = nil, language: String? = nil, forksCount: Int, stargazersCount: Int, watchersCount: Int, size: Int, defaultBranch: String, openIssuesCount: Int, isTemplate: Bool? = nil, topics: [String]? = nil, hasIssues: Bool, hasProjects: Bool, hasWiki: Bool, hasPages: Bool, hasDownloads: Bool, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, pushedAt: Date, createdAt: Date, updatedAt: Date, permissions: Permissions? = nil, allowRebaseMerge: Bool? = nil, templateRepository: Repository? = nil, tempCloneToken: String? = nil, allowSquashMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowForking: Bool? = nil, subscribersCount: Int, networkCount: Int, license: LicenseSimple? = nil, organization: SimpleUser? = nil, parent: Repository? = nil, source: Repository? = nil, forks: Int, masterBranch: String? = nil, openIssues: Int, watchers: Int, isAnonymousAccessEnabled: Bool? = nil, codeOfConduct: CodeOfConductSimple? = nil, securityAndAnalysis: SecurityAndAnalysis? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.fullName = fullName
        self.owner = owner
        self.isPrivate = isPrivate
        self.htmlURL = htmlURL
        self.description = description
        self.isFork = isFork
        self.url = url
        self.archiveURL = archiveURL
        self.assigneesURL = assigneesURL
        self.blobsURL = blobsURL
        self.branchesURL = branchesURL
        self.collaboratorsURL = collaboratorsURL
        self.commentsURL = commentsURL
        self.commitsURL = commitsURL
        self.compareURL = compareURL
        self.contentsURL = contentsURL
        self.contributorsURL = contributorsURL
        self.deploymentsURL = deploymentsURL
        self.downloadsURL = downloadsURL
        self.eventsURL = eventsURL
        self.forksURL = forksURL
        self.gitCommitsURL = gitCommitsURL
        self.gitRefsURL = gitRefsURL
        self.gitTagsURL = gitTagsURL
        self.gitURL = gitURL
        self.issueCommentURL = issueCommentURL
        self.issueEventsURL = issueEventsURL
        self.issuesURL = issuesURL
        self.keysURL = keysURL
        self.labelsURL = labelsURL
        self.languagesURL = languagesURL
        self.mergesURL = mergesURL
        self.milestonesURL = milestonesURL
        self.notificationsURL = notificationsURL
        self.pullsURL = pullsURL
        self.releasesURL = releasesURL
        self.sshURL = sshURL
        self.stargazersURL = stargazersURL
        self.statusesURL = statusesURL
        self.subscribersURL = subscribersURL
        self.subscriptionURL = subscriptionURL
        self.tagsURL = tagsURL
        self.teamsURL = teamsURL
        self.treesURL = treesURL
        self.cloneURL = cloneURL
        self.mirrorURL = mirrorURL
        self.hooksURL = hooksURL
        self.svnURL = svnURL
        self.homepage = homepage
        self.language = language
        self.forksCount = forksCount
        self.stargazersCount = stargazersCount
        self.watchersCount = watchersCount
        self.size = size
        self.defaultBranch = defaultBranch
        self.openIssuesCount = openIssuesCount
        self.isTemplate = isTemplate
        self.topics = topics
        self.hasIssues = hasIssues
        self.hasProjects = hasProjects
        self.hasWiki = hasWiki
        self.hasPages = hasPages
        self.hasDownloads = hasDownloads
        self.isArchived = isArchived
        self.isDisabled = isDisabled
        self.visibility = visibility
        self.pushedAt = pushedAt
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.permissions = permissions
        self.allowRebaseMerge = allowRebaseMerge
        self.templateRepository = templateRepository
        self.tempCloneToken = tempCloneToken
        self.allowSquashMerge = allowSquashMerge
        self.allowAutoMerge = allowAutoMerge
        self.deleteBranchOnMerge = deleteBranchOnMerge
        self.allowMergeCommit = allowMergeCommit
        self.allowForking = allowForking
        self.subscribersCount = subscribersCount
        self.networkCount = networkCount
        self.license = license
        self.organization = organization
        self.parent = parent
        self.source = source
        self.forks = forks
        self.masterBranch = masterBranch
        self.openIssues = openIssues
        self.watchers = watchers
        self.isAnonymousAccessEnabled = isAnonymousAccessEnabled ?? true
        self.codeOfConduct = codeOfConduct
        self.securityAndAnalysis = securityAndAnalysis
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.fullName = try values.decode(String.self, forKey: "full_name")
        self.owner = try values.decode(SimpleUser.self, forKey: "owner")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isFork = try values.decode(Bool.self, forKey: "fork")
        self.url = try values.decode(URL.self, forKey: "url")
        self.archiveURL = try values.decode(String.self, forKey: "archive_url")
        self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
        self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
        self.branchesURL = try values.decode(String.self, forKey: "branches_url")
        self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
        self.commentsURL = try values.decode(String.self, forKey: "comments_url")
        self.commitsURL = try values.decode(String.self, forKey: "commits_url")
        self.compareURL = try values.decode(String.self, forKey: "compare_url")
        self.contentsURL = try values.decode(String.self, forKey: "contents_url")
        self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
        self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
        self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
        self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
        self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
        self.gitURL = try values.decode(String.self, forKey: "git_url")
        self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
        self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.keysURL = try values.decode(String.self, forKey: "keys_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
        self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
        self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
        self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
        self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
        self.releasesURL = try values.decode(String.self, forKey: "releases_url")
        self.sshURL = try values.decode(String.self, forKey: "ssh_url")
        self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
        self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
        self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
        self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
        self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.treesURL = try values.decode(String.self, forKey: "trees_url")
        self.cloneURL = try values.decode(String.self, forKey: "clone_url")
        self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
        self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
        self.svnURL = try values.decode(URL.self, forKey: "svn_url")
        self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.forksCount = try values.decode(Int.self, forKey: "forks_count")
        self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
        self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
        self.size = try values.decode(Int.self, forKey: "size")
        self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
        self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
        self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
        self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
        self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
        self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
        self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
        self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
        self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
        self.isArchived = try values.decode(Bool.self, forKey: "archived")
        self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
        self.pushedAt = try values.decode(Date.self, forKey: "pushed_at")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge")
        self.templateRepository = try values.decodeIfPresent(Repository.self, forKey: "template_repository")
        self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
        self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge")
        self.allowAutoMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_auto_merge")
        self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge")
        self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit")
        self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
        self.subscribersCount = try values.decode(Int.self, forKey: "subscribers_count")
        self.networkCount = try values.decode(Int.self, forKey: "network_count")
        self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
        self.organization = try values.decodeIfPresent(SimpleUser.self, forKey: "organization")
        self.parent = try values.decodeIfPresent(Repository.self, forKey: "parent")
        self.source = try values.decodeIfPresent(Repository.self, forKey: "source")
        self.forks = try values.decode(Int.self, forKey: "forks")
        self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
        self.openIssues = try values.decode(Int.self, forKey: "open_issues")
        self.watchers = try values.decode(Int.self, forKey: "watchers")
        self.isAnonymousAccessEnabled = try values.decodeIfPresent(Bool.self, forKey: "anonymous_access_enabled") ?? true
        self.codeOfConduct = try values.decodeIfPresent(CodeOfConductSimple.self, forKey: "code_of_conduct")
        self.securityAndAnalysis = try values.decodeIfPresent(SecurityAndAnalysis.self, forKey: "security_and_analysis")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(fullName, forKey: "full_name")
        try values.encode(owner, forKey: "owner")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isFork, forKey: "fork")
        try values.encode(url, forKey: "url")
        try values.encode(archiveURL, forKey: "archive_url")
        try values.encode(assigneesURL, forKey: "assignees_url")
        try values.encode(blobsURL, forKey: "blobs_url")
        try values.encode(branchesURL, forKey: "branches_url")
        try values.encode(collaboratorsURL, forKey: "collaborators_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(compareURL, forKey: "compare_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encode(contributorsURL, forKey: "contributors_url")
        try values.encode(deploymentsURL, forKey: "deployments_url")
        try values.encode(downloadsURL, forKey: "downloads_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(gitCommitsURL, forKey: "git_commits_url")
        try values.encode(gitRefsURL, forKey: "git_refs_url")
        try values.encode(gitTagsURL, forKey: "git_tags_url")
        try values.encode(gitURL, forKey: "git_url")
        try values.encode(issueCommentURL, forKey: "issue_comment_url")
        try values.encode(issueEventsURL, forKey: "issue_events_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(keysURL, forKey: "keys_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(languagesURL, forKey: "languages_url")
        try values.encode(mergesURL, forKey: "merges_url")
        try values.encode(milestonesURL, forKey: "milestones_url")
        try values.encode(notificationsURL, forKey: "notifications_url")
        try values.encode(pullsURL, forKey: "pulls_url")
        try values.encode(releasesURL, forKey: "releases_url")
        try values.encode(sshURL, forKey: "ssh_url")
        try values.encode(stargazersURL, forKey: "stargazers_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(subscribersURL, forKey: "subscribers_url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
        try values.encode(tagsURL, forKey: "tags_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(treesURL, forKey: "trees_url")
        try values.encode(cloneURL, forKey: "clone_url")
        try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(svnURL, forKey: "svn_url")
        try values.encodeIfPresent(homepage, forKey: "homepage")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encode(forksCount, forKey: "forks_count")
        try values.encode(stargazersCount, forKey: "stargazers_count")
        try values.encode(watchersCount, forKey: "watchers_count")
        try values.encode(size, forKey: "size")
        try values.encode(defaultBranch, forKey: "default_branch")
        try values.encode(openIssuesCount, forKey: "open_issues_count")
        try values.encodeIfPresent(isTemplate, forKey: "is_template")
        try values.encodeIfPresent(topics, forKey: "topics")
        try values.encode(hasIssues, forKey: "has_issues")
        try values.encode(hasProjects, forKey: "has_projects")
        try values.encode(hasWiki, forKey: "has_wiki")
        try values.encode(hasPages, forKey: "has_pages")
        try values.encode(hasDownloads, forKey: "has_downloads")
        try values.encode(isArchived, forKey: "archived")
        try values.encode(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(visibility, forKey: "visibility")
        try values.encode(pushedAt, forKey: "pushed_at")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
        try values.encodeIfPresent(templateRepository, forKey: "template_repository")
        try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
        try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
        try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
        try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
        try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
        try values.encodeIfPresent(allowForking, forKey: "allow_forking")
        try values.encode(subscribersCount, forKey: "subscribers_count")
        try values.encode(networkCount, forKey: "network_count")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(organization, forKey: "organization")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encode(forks, forKey: "forks")
        try values.encodeIfPresent(masterBranch, forKey: "master_branch")
        try values.encode(openIssues, forKey: "open_issues")
        try values.encode(watchers, forKey: "watchers")
        try values.encodeIfPresent(isAnonymousAccessEnabled, forKey: "anonymous_access_enabled")
        try values.encodeIfPresent(codeOfConduct, forKey: "code_of_conduct")
        try values.encodeIfPresent(securityAndAnalysis, forKey: "security_and_analysis")
    }
}

/// An artifact
public struct Artifact: Codable {
    public var id: Int
    /// Example: "MDEwOkNoZWNrU3VpdGU1"
    public var nodeID: String
    /// The name of the artifact.
    ///
    /// Example: "AdventureWorks.Framework"
    public var name: String
    /// The size in bytes of the artifact.
    ///
    /// Example: 12345
    public var sizeInBytes: Int
    /// Example: "https://api.github.com/repos/github/hello-world/actions/artifacts/5"
    public var url: String
    /// Example: "https://api.github.com/repos/github/hello-world/actions/artifacts/5/zip"
    public var archiveDownloadURL: String
    /// Whether or not the artifact has expired.
    public var isExpired: Bool
    public var createdAt: Date?
    public var expiresAt: Date?
    public var updatedAt: Date?

    public init(id: Int, nodeID: String, name: String, sizeInBytes: Int, url: String, archiveDownloadURL: String, isExpired: Bool, createdAt: Date? = nil, expiresAt: Date? = nil, updatedAt: Date? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.sizeInBytes = sizeInBytes
        self.url = url
        self.archiveDownloadURL = archiveDownloadURL
        self.isExpired = isExpired
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.sizeInBytes = try values.decode(Int.self, forKey: "size_in_bytes")
        self.url = try values.decode(String.self, forKey: "url")
        self.archiveDownloadURL = try values.decode(String.self, forKey: "archive_download_url")
        self.isExpired = try values.decode(Bool.self, forKey: "expired")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.expiresAt = try values.decodeIfPresent(Date.self, forKey: "expires_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(sizeInBytes, forKey: "size_in_bytes")
        try values.encode(url, forKey: "url")
        try values.encode(archiveDownloadURL, forKey: "archive_download_url")
        try values.encode(isExpired, forKey: "expired")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
    }
}

/// Information of a job execution in a workflow run
public struct Job: Codable {
    /// The id of the job.
    ///
    /// Example: 21
    public var id: Int
    /// The id of the associated workflow run.
    public var runID: Int
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5"
    public var runURL: String
    /// Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.
    public var runAttempt: Int?
    /// Example: "MDg6Q2hlY2tSdW40"
    public var nodeID: String
    /// The SHA of the commit that is being run.
    ///
    /// Example: "009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d"
    public var headSha: String
    /// Example: "https://api.github.com/repos/github/hello-world/actions/jobs/21"
    public var url: String
    /// Example: "https://github.com/github/hello-world/runs/4"
    public var htmlURL: String?
    /// The phase of the lifecycle that the job is currently in.
    ///
    /// Example: "queued"
    public var status: Status
    /// The outcome of the job.
    ///
    /// Example: "success"
    public var conclusion: String?
    /// The time that the job started, in ISO 8601 format.
    ///
    /// Example: "2019-08-08T08:00:00-07:00"
    public var startedAt: Date
    /// The time that the job finished, in ISO 8601 format.
    ///
    /// Example: "2019-08-08T08:00:00-07:00"
    public var completedAt: Date?
    /// The name of the job.
    ///
    /// Example: "test-coverage"
    public var name: String
    /// Steps in this job.
    public var steps: [Step]?
    /// Example: "https://api.github.com/repos/github/hello-world/check-runs/4"
    public var checkRunURL: String
    /// Labels for the workflow job. Specified by the "runs_on" attribute in the action's workflow file.
    ///
    /// Example: ["self-hosted", "foo", "bar"]
    public var labels: [String]
    /// The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    public var runnerID: Int?
    /// The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    ///
    /// Example: "my runner"
    public var runnerName: String?
    /// The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    public var runnerGroupID: Int?
    /// The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    ///
    /// Example: "my runner group"
    public var runnerGroupName: String?

    /// The phase of the lifecycle that the job is currently in.
    ///
    /// Example: "queued"
    public enum Status: String, Codable, CaseIterable {
        case queued
        case inProgress = "in_progress"
        case completed
    }

    public struct Step: Codable {
        /// The phase of the lifecycle that the job is currently in.
        ///
        /// Example: "queued"
        public var status: Status
        /// The outcome of the job.
        ///
        /// Example: "success"
        public var conclusion: String?
        /// The name of the job.
        ///
        /// Example: "test-coverage"
        public var name: String
        public var number: Int
        /// The time that the step started, in ISO 8601 format.
        ///
        /// Example: "2019-08-08T08:00:00-07:00"
        public var startedAt: Date?
        /// The time that the job finished, in ISO 8601 format.
        ///
        /// Example: "2019-08-08T08:00:00-07:00"
        public var completedAt: Date?

        /// The phase of the lifecycle that the job is currently in.
        ///
        /// Example: "queued"
        public enum Status: String, Codable, CaseIterable {
            case queued
            case inProgress = "in_progress"
            case completed
        }

        public init(status: Status, conclusion: String? = nil, name: String, number: Int, startedAt: Date? = nil, completedAt: Date? = nil) {
            self.status = status
            self.conclusion = conclusion
            self.name = name
            self.number = number
            self.startedAt = startedAt
            self.completedAt = completedAt
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.status = try values.decode(Status.self, forKey: "status")
            self.conclusion = try values.decodeIfPresent(String.self, forKey: "conclusion")
            self.name = try values.decode(String.self, forKey: "name")
            self.number = try values.decode(Int.self, forKey: "number")
            self.startedAt = try values.decodeIfPresent(Date.self, forKey: "started_at")
            self.completedAt = try values.decodeIfPresent(Date.self, forKey: "completed_at")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(status, forKey: "status")
            try values.encodeIfPresent(conclusion, forKey: "conclusion")
            try values.encode(name, forKey: "name")
            try values.encode(number, forKey: "number")
            try values.encodeIfPresent(startedAt, forKey: "started_at")
            try values.encodeIfPresent(completedAt, forKey: "completed_at")
        }
    }

    public init(id: Int, runID: Int, runURL: String, runAttempt: Int? = nil, nodeID: String, headSha: String, url: String, htmlURL: String? = nil, status: Status, conclusion: String? = nil, startedAt: Date, completedAt: Date? = nil, name: String, steps: [Step]? = nil, checkRunURL: String, labels: [String], runnerID: Int? = nil, runnerName: String? = nil, runnerGroupID: Int? = nil, runnerGroupName: String? = nil) {
        self.id = id
        self.runID = runID
        self.runURL = runURL
        self.runAttempt = runAttempt
        self.nodeID = nodeID
        self.headSha = headSha
        self.url = url
        self.htmlURL = htmlURL
        self.status = status
        self.conclusion = conclusion
        self.startedAt = startedAt
        self.completedAt = completedAt
        self.name = name
        self.steps = steps
        self.checkRunURL = checkRunURL
        self.labels = labels
        self.runnerID = runnerID
        self.runnerName = runnerName
        self.runnerGroupID = runnerGroupID
        self.runnerGroupName = runnerGroupName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.runID = try values.decode(Int.self, forKey: "run_id")
        self.runURL = try values.decode(String.self, forKey: "run_url")
        self.runAttempt = try values.decodeIfPresent(Int.self, forKey: "run_attempt")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.headSha = try values.decode(String.self, forKey: "head_sha")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.status = try values.decode(Status.self, forKey: "status")
        self.conclusion = try values.decodeIfPresent(String.self, forKey: "conclusion")
        self.startedAt = try values.decode(Date.self, forKey: "started_at")
        self.completedAt = try values.decodeIfPresent(Date.self, forKey: "completed_at")
        self.name = try values.decode(String.self, forKey: "name")
        self.steps = try values.decodeIfPresent([Step].self, forKey: "steps")
        self.checkRunURL = try values.decode(String.self, forKey: "check_run_url")
        self.labels = try values.decode([String].self, forKey: "labels")
        self.runnerID = try values.decodeIfPresent(Int.self, forKey: "runner_id")
        self.runnerName = try values.decodeIfPresent(String.self, forKey: "runner_name")
        self.runnerGroupID = try values.decodeIfPresent(Int.self, forKey: "runner_group_id")
        self.runnerGroupName = try values.decodeIfPresent(String.self, forKey: "runner_group_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(runID, forKey: "run_id")
        try values.encode(runURL, forKey: "run_url")
        try values.encodeIfPresent(runAttempt, forKey: "run_attempt")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(headSha, forKey: "head_sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(conclusion, forKey: "conclusion")
        try values.encode(startedAt, forKey: "started_at")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(steps, forKey: "steps")
        try values.encode(checkRunURL, forKey: "check_run_url")
        try values.encode(labels, forKey: "labels")
        try values.encodeIfPresent(runnerID, forKey: "runner_id")
        try values.encodeIfPresent(runnerName, forKey: "runner_name")
        try values.encodeIfPresent(runnerGroupID, forKey: "runner_group_id")
        try values.encodeIfPresent(runnerGroupName, forKey: "runner_group_name")
    }
}

public struct ActionsRepositoryPermissions: Codable {
    /// Whether GitHub Actions is enabled on the repository.
    public var isEnabled: Bool
    /// The permissions policy that controls the actions that are allowed to run. Can be one of: `all`, `local_only`, or `selected`.
    public var allowedActions: AllowedActions?
    /// The API URL to use to get or set the actions that are allowed to run, when `allowed_actions` is set to `selected`.
    public var selectedActionsURL: String?

    public init(isEnabled: Bool, allowedActions: AllowedActions? = nil, selectedActionsURL: String? = nil) {
        self.isEnabled = isEnabled
        self.allowedActions = allowedActions
        self.selectedActionsURL = selectedActionsURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        self.allowedActions = try values.decodeIfPresent(AllowedActions.self, forKey: "allowed_actions")
        self.selectedActionsURL = try values.decodeIfPresent(String.self, forKey: "selected_actions_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(allowedActions, forKey: "allowed_actions")
        try values.encodeIfPresent(selectedActionsURL, forKey: "selected_actions_url")
    }
}

public struct PullRequestMinimal: Codable {
    public var id: Int
    public var number: Int
    public var url: String
    public var head: Head
    public var base: Base

    public struct Head: Codable {
        public var ref: String
        public var sha: String
        public var repo: Repo

        public struct Repo: Codable {
            public var id: Int
            public var url: String
            public var name: String

            public init(id: Int, url: String, name: String) {
                self.id = id
                self.url = url
                self.name = name
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.url = try values.decode(String.self, forKey: "url")
                self.name = try values.decode(String.self, forKey: "name")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encode(url, forKey: "url")
                try values.encode(name, forKey: "name")
            }
        }

        public init(ref: String, sha: String, repo: Repo) {
            self.ref = ref
            self.sha = sha
            self.repo = repo
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ref = try values.decode(String.self, forKey: "ref")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.repo = try values.decode(Repo.self, forKey: "repo")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(ref, forKey: "ref")
            try values.encode(sha, forKey: "sha")
            try values.encode(repo, forKey: "repo")
        }
    }

    public struct Base: Codable {
        public var ref: String
        public var sha: String
        public var repo: Repo

        public struct Repo: Codable {
            public var id: Int
            public var url: String
            public var name: String

            public init(id: Int, url: String, name: String) {
                self.id = id
                self.url = url
                self.name = name
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.url = try values.decode(String.self, forKey: "url")
                self.name = try values.decode(String.self, forKey: "name")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encode(url, forKey: "url")
                try values.encode(name, forKey: "name")
            }
        }

        public init(ref: String, sha: String, repo: Repo) {
            self.ref = ref
            self.sha = sha
            self.repo = repo
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ref = try values.decode(String.self, forKey: "ref")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.repo = try values.decode(Repo.self, forKey: "repo")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(ref, forKey: "ref")
            try values.encode(sha, forKey: "sha")
            try values.encode(repo, forKey: "repo")
        }
    }

    public init(id: Int, number: Int, url: String, head: Head, base: Base) {
        self.id = id
        self.number = number
        self.url = url
        self.head = head
        self.base = base
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.url = try values.decode(String.self, forKey: "url")
        self.head = try values.decode(Head.self, forKey: "head")
        self.base = try values.decode(Base.self, forKey: "base")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(number, forKey: "number")
        try values.encode(url, forKey: "url")
        try values.encode(head, forKey: "head")
        try values.encode(base, forKey: "base")
    }
}

/// An invocation of a workflow
public struct WorkflowRun: Codable {
    /// The ID of the workflow run.
    public var id: Int
    /// The name of the workflow run.
    ///
    /// Example: "Build"
    public var name: String?
    /// Example: "MDEwOkNoZWNrU3VpdGU1"
    public var nodeID: String
    /// The ID of the associated check suite.
    ///
    /// Example: 42
    public var checkSuiteID: Int?
    /// The node ID of the associated check suite.
    ///
    /// Example: "MDEwOkNoZWNrU3VpdGU0Mg=="
    public var checkSuiteNodeID: String?
    /// Example: "master"
    public var headBranch: String?
    /// The SHA of the head commit that points to the version of the worflow being run.
    ///
    /// Example: "009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d"
    public var headSha: String
    /// The auto incrementing run number for the workflow run.
    ///
    /// Example: 106
    public var runNumber: Int
    /// Attempt number of the run, 1 for first attempt and higher if the workflow was re-run.
    public var runAttempt: Int?
    /// Example: "push"
    public var event: String
    /// Example: "completed"
    public var status: String?
    /// Example: "neutral"
    public var conclusion: String?
    /// The ID of the parent workflow.
    public var workflowID: Int
    /// The URL to the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5"
    public var url: String
    /// Example: "https://github.com/github/hello-world/suites/4"
    public var htmlURL: String
    public var pullRequests: [PullRequestMinimal]?
    public var createdAt: Date
    public var updatedAt: Date
    /// The start time of the latest run. Resets on re-run.
    public var runStartedAt: Date?
    /// The URL to the jobs for the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/jobs"
    public var jobsURL: String
    /// The URL to download the logs for the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/logs"
    public var logsURL: String
    /// The URL to the associated check suite.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/check-suites/12"
    public var checkSuiteURL: String
    /// The URL to the artifacts for the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/rerun/artifacts"
    public var artifactsURL: String
    /// The URL to cancel the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/cancel"
    public var cancelURL: String
    /// The URL to rerun the workflow run.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/rerun"
    public var rerunURL: String
    /// The URL to the previous attempted run of this workflow, if one exists.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/runs/5/attempts/3"
    public var previousAttemptURL: String?
    /// The URL to the workflow.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/actions/workflows/main.yaml"
    public var workflowURL: String
    /// Simple Commit
    public var headCommit: SimpleCommit?
    /// Minimal Repository
    public var repository: MinimalRepository
    /// Minimal Repository
    public var headRepository: MinimalRepository
    public var headRepositoryID: Int?

    public init(id: Int, name: String? = nil, nodeID: String, checkSuiteID: Int? = nil, checkSuiteNodeID: String? = nil, headBranch: String? = nil, headSha: String, runNumber: Int, runAttempt: Int? = nil, event: String, status: String? = nil, conclusion: String? = nil, workflowID: Int, url: String, htmlURL: String, pullRequests: [PullRequestMinimal]? = nil, createdAt: Date, updatedAt: Date, runStartedAt: Date? = nil, jobsURL: String, logsURL: String, checkSuiteURL: String, artifactsURL: String, cancelURL: String, rerunURL: String, previousAttemptURL: String? = nil, workflowURL: String, headCommit: SimpleCommit? = nil, repository: MinimalRepository, headRepository: MinimalRepository, headRepositoryID: Int? = nil) {
        self.id = id
        self.name = name
        self.nodeID = nodeID
        self.checkSuiteID = checkSuiteID
        self.checkSuiteNodeID = checkSuiteNodeID
        self.headBranch = headBranch
        self.headSha = headSha
        self.runNumber = runNumber
        self.runAttempt = runAttempt
        self.event = event
        self.status = status
        self.conclusion = conclusion
        self.workflowID = workflowID
        self.url = url
        self.htmlURL = htmlURL
        self.pullRequests = pullRequests
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.runStartedAt = runStartedAt
        self.jobsURL = jobsURL
        self.logsURL = logsURL
        self.checkSuiteURL = checkSuiteURL
        self.artifactsURL = artifactsURL
        self.cancelURL = cancelURL
        self.rerunURL = rerunURL
        self.previousAttemptURL = previousAttemptURL
        self.workflowURL = workflowURL
        self.headCommit = headCommit
        self.repository = repository
        self.headRepository = headRepository
        self.headRepositoryID = headRepositoryID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.checkSuiteID = try values.decodeIfPresent(Int.self, forKey: "check_suite_id")
        self.checkSuiteNodeID = try values.decodeIfPresent(String.self, forKey: "check_suite_node_id")
        self.headBranch = try values.decodeIfPresent(String.self, forKey: "head_branch")
        self.headSha = try values.decode(String.self, forKey: "head_sha")
        self.runNumber = try values.decode(Int.self, forKey: "run_number")
        self.runAttempt = try values.decodeIfPresent(Int.self, forKey: "run_attempt")
        self.event = try values.decode(String.self, forKey: "event")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
        self.conclusion = try values.decodeIfPresent(String.self, forKey: "conclusion")
        self.workflowID = try values.decode(Int.self, forKey: "workflow_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.pullRequests = try values.decodeIfPresent([PullRequestMinimal].self, forKey: "pull_requests")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.runStartedAt = try values.decodeIfPresent(Date.self, forKey: "run_started_at")
        self.jobsURL = try values.decode(String.self, forKey: "jobs_url")
        self.logsURL = try values.decode(String.self, forKey: "logs_url")
        self.checkSuiteURL = try values.decode(String.self, forKey: "check_suite_url")
        self.artifactsURL = try values.decode(String.self, forKey: "artifacts_url")
        self.cancelURL = try values.decode(String.self, forKey: "cancel_url")
        self.rerunURL = try values.decode(String.self, forKey: "rerun_url")
        self.previousAttemptURL = try values.decodeIfPresent(String.self, forKey: "previous_attempt_url")
        self.workflowURL = try values.decode(String.self, forKey: "workflow_url")
        self.headCommit = try values.decodeIfPresent(SimpleCommit.self, forKey: "head_commit")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.headRepository = try values.decode(MinimalRepository.self, forKey: "head_repository")
        self.headRepositoryID = try values.decodeIfPresent(Int.self, forKey: "head_repository_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(checkSuiteID, forKey: "check_suite_id")
        try values.encodeIfPresent(checkSuiteNodeID, forKey: "check_suite_node_id")
        try values.encodeIfPresent(headBranch, forKey: "head_branch")
        try values.encode(headSha, forKey: "head_sha")
        try values.encode(runNumber, forKey: "run_number")
        try values.encodeIfPresent(runAttempt, forKey: "run_attempt")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(conclusion, forKey: "conclusion")
        try values.encode(workflowID, forKey: "workflow_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(pullRequests, forKey: "pull_requests")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(runStartedAt, forKey: "run_started_at")
        try values.encode(jobsURL, forKey: "jobs_url")
        try values.encode(logsURL, forKey: "logs_url")
        try values.encode(checkSuiteURL, forKey: "check_suite_url")
        try values.encode(artifactsURL, forKey: "artifacts_url")
        try values.encode(cancelURL, forKey: "cancel_url")
        try values.encode(rerunURL, forKey: "rerun_url")
        try values.encodeIfPresent(previousAttemptURL, forKey: "previous_attempt_url")
        try values.encode(workflowURL, forKey: "workflow_url")
        try values.encodeIfPresent(headCommit, forKey: "head_commit")
        try values.encode(repository, forKey: "repository")
        try values.encode(headRepository, forKey: "head_repository")
        try values.encodeIfPresent(headRepositoryID, forKey: "head_repository_id")
    }
}

/// Environment Approval
///
/// An entry in the reviews log for environment deployments
public struct EnvironmentApprovals: Codable {
    /// The list of environments that were approved or rejected
    public var environments: [Environment]
    /// Whether deployment to the environment(s) was approved or rejected
    ///
    /// Example: "approved"
    public var state: State
    /// Simple User
    public var user: SimpleUser
    /// The comment submitted with the deployment review
    ///
    /// Example: "Ship it!"
    public var comment: String

    public struct Environment: Codable {
        /// The id of the environment.
        ///
        /// Example: 56780428
        public var id: Int?
        /// Example: "MDExOkVudmlyb25tZW50NTY3ODA0Mjg="
        public var nodeID: String?
        /// The name of the environment.
        ///
        /// Example: "staging"
        public var name: String?
        /// Example: "https://api.github.com/repos/github/hello-world/environments/staging"
        public var url: String?
        /// Example: "https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"
        public var htmlURL: String?
        /// The time that the environment was created, in ISO 8601 format.
        ///
        /// Example: "2020-11-23T22:00:40Z"
        public var createdAt: Date?
        /// The time that the environment was last updated, in ISO 8601 format.
        ///
        /// Example: "2020-11-23T22:00:40Z"
        public var updatedAt: Date?

        public init(id: Int? = nil, nodeID: String? = nil, name: String? = nil, url: String? = nil, htmlURL: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.name = name
            self.url = url
            self.htmlURL = htmlURL
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        }
    }

    /// Whether deployment to the environment(s) was approved or rejected
    ///
    /// Example: "approved"
    public enum State: String, Codable, CaseIterable {
        case approved
        case rejected
    }

    public init(environments: [Environment], state: State, user: SimpleUser, comment: String) {
        self.environments = environments
        self.state = state
        self.user = user
        self.comment = comment
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.environments = try values.decode([Environment].self, forKey: "environments")
        self.state = try values.decode(State.self, forKey: "state")
        self.user = try values.decode(SimpleUser.self, forKey: "user")
        self.comment = try values.decode(String.self, forKey: "comment")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(environments, forKey: "environments")
        try values.encode(state, forKey: "state")
        try values.encode(user, forKey: "user")
        try values.encode(comment, forKey: "comment")
    }
}

/// The type of reviewer. Must be one of: `User` or `Team`
///
/// Example: "User"
public enum DeploymentReviewerType: String, Codable, CaseIterable {
    case user = "User"
    case team = "Team"
}

/// Details of a deployment that is waiting for protection rules to pass
public struct PendingDeployment: Codable {
    public var environment: Environment
    /// The set duration of the wait timer
    ///
    /// Example: 30
    public var waitTimer: Int
    /// The time that the wait timer began.
    ///
    /// Example: "2020-11-23T22:00:40Z"
    public var waitTimerStartedAt: Date?
    /// Whether the currently authenticated user can approve the deployment
    ///
    /// Example: true
    public var currentUserCanApprove: Bool
    /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
    public var reviewers: [Reviewer]

    public struct Environment: Codable {
        /// The id of the environment.
        ///
        /// Example: 56780428
        public var id: Int?
        /// Example: "MDExOkVudmlyb25tZW50NTY3ODA0Mjg="
        public var nodeID: String?
        /// The name of the environment.
        ///
        /// Example: "staging"
        public var name: String?
        /// Example: "https://api.github.com/repos/github/hello-world/environments/staging"
        public var url: String?
        /// Example: "https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"
        public var htmlURL: String?

        public init(id: Int? = nil, nodeID: String? = nil, name: String? = nil, url: String? = nil, htmlURL: String? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.name = name
            self.url = url
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
        }
    }

    public struct Reviewer: Codable {
        /// The type of reviewer. Must be one of: `User` or `Team`
        ///
        /// Example: "User"
        public var type: DeploymentReviewerType?
        public var reviewer: Reviewer?

        public struct Reviewer: Codable {
            public var simpleUser: SimpleUser?
            /// Groups of organization members that gives permissions on specified repositories.
            public var team: Team?

            public init(simpleUser: SimpleUser? = nil, team: Team? = nil) {
                self.simpleUser = simpleUser
                self.team = team
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.simpleUser = try? container.decode(SimpleUser.self)
                self.team = try? container.decode(Team.self)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = simpleUser { try container.encode(value) }
                if let value = team { try container.encode(value) }
            }
        }

        public init(type: DeploymentReviewerType? = nil, reviewer: Reviewer? = nil) {
            self.type = type
            self.reviewer = reviewer
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(DeploymentReviewerType.self, forKey: "type")
            self.reviewer = try values.decodeIfPresent(Reviewer.self, forKey: "reviewer")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(reviewer, forKey: "reviewer")
        }
    }

    public init(environment: Environment, waitTimer: Int, waitTimerStartedAt: Date? = nil, currentUserCanApprove: Bool, reviewers: [Reviewer]) {
        self.environment = environment
        self.waitTimer = waitTimer
        self.waitTimerStartedAt = waitTimerStartedAt
        self.currentUserCanApprove = currentUserCanApprove
        self.reviewers = reviewers
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.environment = try values.decode(Environment.self, forKey: "environment")
        self.waitTimer = try values.decode(Int.self, forKey: "wait_timer")
        self.waitTimerStartedAt = try values.decodeIfPresent(Date.self, forKey: "wait_timer_started_at")
        self.currentUserCanApprove = try values.decode(Bool.self, forKey: "current_user_can_approve")
        self.reviewers = try values.decode([Reviewer].self, forKey: "reviewers")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(environment, forKey: "environment")
        try values.encode(waitTimer, forKey: "wait_timer")
        try values.encodeIfPresent(waitTimerStartedAt, forKey: "wait_timer_started_at")
        try values.encode(currentUserCanApprove, forKey: "current_user_can_approve")
        try values.encode(reviewers, forKey: "reviewers")
    }
}

/// A request for a specific ref(branch,sha,tag) to be deployed
public struct Deployment: Codable {
    /// Example: "https://api.github.com/repos/octocat/example/deployments/1"
    public var url: URL
    /// Unique identifier of the deployment
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEwOkRlcGxveW1lbnQx"
    public var nodeID: String
    /// Example: "a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d"
    public var sha: String
    /// The ref to deploy. This can be a branch, tag, or sha.
    ///
    /// Example: "topic-branch"
    public var ref: String
    /// Parameter to specify a task to execute
    ///
    /// Example: "deploy"
    public var task: String
    public var payload: Payload
    /// Example: "staging"
    public var originalEnvironment: String?
    /// Name for the target deployment environment.
    ///
    /// Example: "production"
    public var environment: String
    /// Example: "Deploy request from hubot"
    public var description: String?
    /// Simple User
    public var creator: SimpleUser?
    /// Example: "2012-07-20T01:19:13Z"
    public var createdAt: Date
    /// Example: "2012-07-20T01:19:13Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/repos/octocat/example/deployments/1/statuses"
    public var statusesURL: URL
    /// Example: "https://api.github.com/repos/octocat/example"
    public var repositoryURL: URL
    /// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
    ///
    /// Example: true
    public var isTransientEnvironment: Bool?
    /// Specifies if the given environment is one that end-users directly interact with. Default: false.
    ///
    /// Example: true
    public var isProductionEnvironment: Bool?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?

    public enum Payload: Codable {
        case object([String: AnyJSON])
        case string(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode([String: AnyJSON].self) {
                self = .object(value)
            } else if let value = try? container.decode(String.self) {
                self = .string(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .object(let value): try container.encode(value)
            case .string(let value): try container.encode(value)
            }
        }
    }

    public init(url: URL, id: Int, nodeID: String, sha: String, ref: String, task: String, payload: Payload, originalEnvironment: String? = nil, environment: String, description: String? = nil, creator: SimpleUser? = nil, createdAt: Date, updatedAt: Date, statusesURL: URL, repositoryURL: URL, isTransientEnvironment: Bool? = nil, isProductionEnvironment: Bool? = nil, performedViaGithubApp: Integration? = nil) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.sha = sha
        self.ref = ref
        self.task = task
        self.payload = payload
        self.originalEnvironment = originalEnvironment
        self.environment = environment
        self.description = description
        self.creator = creator
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.statusesURL = statusesURL
        self.repositoryURL = repositoryURL
        self.isTransientEnvironment = isTransientEnvironment
        self.isProductionEnvironment = isProductionEnvironment
        self.performedViaGithubApp = performedViaGithubApp
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.ref = try values.decode(String.self, forKey: "ref")
        self.task = try values.decode(String.self, forKey: "task")
        self.payload = try values.decode(Payload.self, forKey: "payload")
        self.originalEnvironment = try values.decodeIfPresent(String.self, forKey: "original_environment")
        self.environment = try values.decode(String.self, forKey: "environment")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.statusesURL = try values.decode(URL.self, forKey: "statuses_url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.isTransientEnvironment = try values.decodeIfPresent(Bool.self, forKey: "transient_environment")
        self.isProductionEnvironment = try values.decodeIfPresent(Bool.self, forKey: "production_environment")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(sha, forKey: "sha")
        try values.encode(ref, forKey: "ref")
        try values.encode(task, forKey: "task")
        try values.encode(payload, forKey: "payload")
        try values.encodeIfPresent(originalEnvironment, forKey: "original_environment")
        try values.encode(environment, forKey: "environment")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encodeIfPresent(isTransientEnvironment, forKey: "transient_environment")
        try values.encodeIfPresent(isProductionEnvironment, forKey: "production_environment")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
    }
}

public struct WorkflowRunUsage: Codable {
    public var billable: Billable
    public var runDurationMs: Int?

    public struct Billable: Codable {
        public var ubuntu: Ubuntu?
        public var macos: Macos?
        public var windows: Windows?

        public struct Ubuntu: Codable {
            public var totalMs: Int
            public var jobs: Int
            public var jobRuns: [JobRun]?

            public struct JobRun: Codable {
                public var jobID: Int
                public var durationMs: Int

                public init(jobID: Int, durationMs: Int) {
                    self.jobID = jobID
                    self.durationMs = durationMs
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.jobID = try values.decode(Int.self, forKey: "job_id")
                    self.durationMs = try values.decode(Int.self, forKey: "duration_ms")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(jobID, forKey: "job_id")
                    try values.encode(durationMs, forKey: "duration_ms")
                }
            }

            public init(totalMs: Int, jobs: Int, jobRuns: [JobRun]? = nil) {
                self.totalMs = totalMs
                self.jobs = jobs
                self.jobRuns = jobRuns
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decode(Int.self, forKey: "total_ms")
                self.jobs = try values.decode(Int.self, forKey: "jobs")
                self.jobRuns = try values.decodeIfPresent([JobRun].self, forKey: "job_runs")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalMs, forKey: "total_ms")
                try values.encode(jobs, forKey: "jobs")
                try values.encodeIfPresent(jobRuns, forKey: "job_runs")
            }
        }

        public struct Macos: Codable {
            public var totalMs: Int
            public var jobs: Int
            public var jobRuns: [JobRun]?

            public struct JobRun: Codable {
                public var jobID: Int
                public var durationMs: Int

                public init(jobID: Int, durationMs: Int) {
                    self.jobID = jobID
                    self.durationMs = durationMs
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.jobID = try values.decode(Int.self, forKey: "job_id")
                    self.durationMs = try values.decode(Int.self, forKey: "duration_ms")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(jobID, forKey: "job_id")
                    try values.encode(durationMs, forKey: "duration_ms")
                }
            }

            public init(totalMs: Int, jobs: Int, jobRuns: [JobRun]? = nil) {
                self.totalMs = totalMs
                self.jobs = jobs
                self.jobRuns = jobRuns
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decode(Int.self, forKey: "total_ms")
                self.jobs = try values.decode(Int.self, forKey: "jobs")
                self.jobRuns = try values.decodeIfPresent([JobRun].self, forKey: "job_runs")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalMs, forKey: "total_ms")
                try values.encode(jobs, forKey: "jobs")
                try values.encodeIfPresent(jobRuns, forKey: "job_runs")
            }
        }

        public struct Windows: Codable {
            public var totalMs: Int
            public var jobs: Int
            public var jobRuns: [JobRun]?

            public struct JobRun: Codable {
                public var jobID: Int
                public var durationMs: Int

                public init(jobID: Int, durationMs: Int) {
                    self.jobID = jobID
                    self.durationMs = durationMs
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.jobID = try values.decode(Int.self, forKey: "job_id")
                    self.durationMs = try values.decode(Int.self, forKey: "duration_ms")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(jobID, forKey: "job_id")
                    try values.encode(durationMs, forKey: "duration_ms")
                }
            }

            public init(totalMs: Int, jobs: Int, jobRuns: [JobRun]? = nil) {
                self.totalMs = totalMs
                self.jobs = jobs
                self.jobRuns = jobRuns
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decode(Int.self, forKey: "total_ms")
                self.jobs = try values.decode(Int.self, forKey: "jobs")
                self.jobRuns = try values.decodeIfPresent([JobRun].self, forKey: "job_runs")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(totalMs, forKey: "total_ms")
                try values.encode(jobs, forKey: "jobs")
                try values.encodeIfPresent(jobRuns, forKey: "job_runs")
            }
        }

        public init(ubuntu: Ubuntu? = nil, macos: Macos? = nil, windows: Windows? = nil) {
            self.ubuntu = ubuntu
            self.macos = macos
            self.windows = windows
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ubuntu = try values.decodeIfPresent(Ubuntu.self, forKey: "UBUNTU")
            self.macos = try values.decodeIfPresent(Macos.self, forKey: "MACOS")
            self.windows = try values.decodeIfPresent(Windows.self, forKey: "WINDOWS")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(ubuntu, forKey: "UBUNTU")
            try values.encodeIfPresent(macos, forKey: "MACOS")
            try values.encodeIfPresent(windows, forKey: "WINDOWS")
        }
    }

    public init(billable: Billable, runDurationMs: Int? = nil) {
        self.billable = billable
        self.runDurationMs = runDurationMs
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.billable = try values.decode(Billable.self, forKey: "billable")
        self.runDurationMs = try values.decodeIfPresent(Int.self, forKey: "run_duration_ms")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(billable, forKey: "billable")
        try values.encodeIfPresent(runDurationMs, forKey: "run_duration_ms")
    }
}

/// Set secrets for GitHub Actions.
public struct ActionsSecret: Codable {
    /// The name of the secret.
    ///
    /// Example: "SECRET_TOKEN"
    public var name: String
    public var createdAt: Date
    public var updatedAt: Date

    public init(name: String, createdAt: Date, updatedAt: Date) {
        self.name = name
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

/// A GitHub Actions workflow
public struct Workflow: Codable {
    public var id: Int
    /// Example: "MDg6V29ya2Zsb3cxMg=="
    public var nodeID: String
    /// Example: "CI"
    public var name: String
    /// Example: "ruby.yaml"
    public var path: String
    /// Example: "active"
    public var state: State
    /// Example: "2019-12-06T14:20:20.000Z"
    public var createdAt: Date
    /// Example: "2019-12-06T14:20:20.000Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/repos/actions/setup-ruby/workflows/5"
    public var url: String
    /// Example: "https://github.com/actions/setup-ruby/blob/master/.github/workflows/ruby.yaml"
    public var htmlURL: String
    /// Example: "https://github.com/actions/setup-ruby/workflows/CI/badge.svg"
    public var badgeURL: String
    /// Example: "2019-12-06T14:20:20.000Z"
    public var deletedAt: Date?

    /// Example: "active"
    public enum State: String, Codable, CaseIterable {
        case active
        case deleted
        case disabledFork = "disabled_fork"
        case disabledInactivity = "disabled_inactivity"
        case disabledManually = "disabled_manually"
    }

    public init(id: Int, nodeID: String, name: String, path: String, state: State, createdAt: Date, updatedAt: Date, url: String, htmlURL: String, badgeURL: String, deletedAt: Date? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.path = path
        self.state = state
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.url = url
        self.htmlURL = htmlURL
        self.badgeURL = badgeURL
        self.deletedAt = deletedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.state = try values.decode(State.self, forKey: "state")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.badgeURL = try values.decode(String.self, forKey: "badge_url")
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: "deleted_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(state, forKey: "state")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(badgeURL, forKey: "badge_url")
        try values.encodeIfPresent(deletedAt, forKey: "deleted_at")
    }
}

public struct WorkflowUsage: Codable {
    public var billable: Billable

    public struct Billable: Codable {
        public var ubuntu: Ubuntu?
        public var macos: Macos?
        public var windows: Windows?

        public struct Ubuntu: Codable {
            public var totalMs: Int?

            public init(totalMs: Int? = nil) {
                self.totalMs = totalMs
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decodeIfPresent(Int.self, forKey: "total_ms")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(totalMs, forKey: "total_ms")
            }
        }

        public struct Macos: Codable {
            public var totalMs: Int?

            public init(totalMs: Int? = nil) {
                self.totalMs = totalMs
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decodeIfPresent(Int.self, forKey: "total_ms")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(totalMs, forKey: "total_ms")
            }
        }

        public struct Windows: Codable {
            public var totalMs: Int?

            public init(totalMs: Int? = nil) {
                self.totalMs = totalMs
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalMs = try values.decodeIfPresent(Int.self, forKey: "total_ms")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(totalMs, forKey: "total_ms")
            }
        }

        public init(ubuntu: Ubuntu? = nil, macos: Macos? = nil, windows: Windows? = nil) {
            self.ubuntu = ubuntu
            self.macos = macos
            self.windows = windows
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ubuntu = try values.decodeIfPresent(Ubuntu.self, forKey: "UBUNTU")
            self.macos = try values.decodeIfPresent(Macos.self, forKey: "MACOS")
            self.windows = try values.decodeIfPresent(Windows.self, forKey: "WINDOWS")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(ubuntu, forKey: "UBUNTU")
            try values.encodeIfPresent(macos, forKey: "MACOS")
            try values.encodeIfPresent(windows, forKey: "WINDOWS")
        }
    }

    public init(billable: Billable) {
        self.billable = billable
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.billable = try values.decode(Billable.self, forKey: "billable")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(billable, forKey: "billable")
    }
}

/// Autolink reference
///
/// An autolink reference.
public struct Autolink: Codable {
    public var id: Int
    /// The prefix of a key that is linkified.
    ///
    /// Example: "TICKET-"
    public var keyPrefix: String
    /// A template for the target URL that is generated if a key was found.
    ///
    /// Example: "https://example.com/TICKET?query=<num>"
    public var urlTemplate: String

    public init(id: Int, keyPrefix: String, urlTemplate: String) {
        self.id = id
        self.keyPrefix = keyPrefix
        self.urlTemplate = urlTemplate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.keyPrefix = try values.decode(String.self, forKey: "key_prefix")
        self.urlTemplate = try values.decode(String.self, forKey: "url_template")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(keyPrefix, forKey: "key_prefix")
        try values.encode(urlTemplate, forKey: "url_template")
    }
}

public struct ProtectedBranchRequiredStatusCheck: Codable {
    public var url: String?
    public var enforcementLevel: String?
    public var contexts: [String]
    public var checks: [Check]
    public var contextsURL: String?
    public var isStrict: Bool?

    public struct Check: Codable {
        public var context: String
        public var appID: Int?

        public init(context: String, appID: Int? = nil) {
            self.context = context
            self.appID = appID
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.context = try values.decode(String.self, forKey: "context")
            self.appID = try values.decodeIfPresent(Int.self, forKey: "app_id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(context, forKey: "context")
            try values.encodeIfPresent(appID, forKey: "app_id")
        }
    }

    public init(url: String? = nil, enforcementLevel: String? = nil, contexts: [String], checks: [Check], contextsURL: String? = nil, isStrict: Bool? = nil) {
        self.url = url
        self.enforcementLevel = enforcementLevel
        self.contexts = contexts
        self.checks = checks
        self.contextsURL = contextsURL
        self.isStrict = isStrict
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.enforcementLevel = try values.decodeIfPresent(String.self, forKey: "enforcement_level")
        self.contexts = try values.decode([String].self, forKey: "contexts")
        self.checks = try values.decode([Check].self, forKey: "checks")
        self.contextsURL = try values.decodeIfPresent(String.self, forKey: "contexts_url")
        self.isStrict = try values.decodeIfPresent(Bool.self, forKey: "strict")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(enforcementLevel, forKey: "enforcement_level")
        try values.encode(contexts, forKey: "contexts")
        try values.encode(checks, forKey: "checks")
        try values.encodeIfPresent(contextsURL, forKey: "contexts_url")
        try values.encodeIfPresent(isStrict, forKey: "strict")
    }
}

public struct ProtectedBranchAdminEnforced: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/enforce_admins"
    public var url: URL
    /// Example: true
    public var isEnabled: Bool

    public init(url: URL, isEnabled: Bool) {
        self.url = url
        self.isEnabled = isEnabled
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(isEnabled, forKey: "enabled")
    }
}

public struct ProtectedBranchPullRequestReview: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions"
    public var url: URL?
    public var dismissalRestrictions: DismissalRestrictions?
    /// Example: true
    public var dismissStaleReviews: Bool
    /// Example: true
    public var requireCodeOwnerReviews: Bool
    public var requiredApprovingReviewCount: Int?

    public struct DismissalRestrictions: Codable {
        /// The list of users with review dismissal access.
        public var users: [SimpleUser]?
        /// The list of teams with review dismissal access.
        public var teams: [Team]?
        /// Example: "https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions"
        public var url: String?
        /// Example: "https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions/users"
        public var usersURL: String?
        /// Example: "https://api.github.com/repos/the-org/an-org-repo/branches/master/protection/dismissal_restrictions/teams"
        public var teamsURL: String?

        public init(users: [SimpleUser]? = nil, teams: [Team]? = nil, url: String? = nil, usersURL: String? = nil, teamsURL: String? = nil) {
            self.users = users
            self.teams = teams
            self.url = url
            self.usersURL = usersURL
            self.teamsURL = teamsURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.users = try values.decodeIfPresent([SimpleUser].self, forKey: "users")
            self.teams = try values.decodeIfPresent([Team].self, forKey: "teams")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.usersURL = try values.decodeIfPresent(String.self, forKey: "users_url")
            self.teamsURL = try values.decodeIfPresent(String.self, forKey: "teams_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(users, forKey: "users")
            try values.encodeIfPresent(teams, forKey: "teams")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(usersURL, forKey: "users_url")
            try values.encodeIfPresent(teamsURL, forKey: "teams_url")
        }
    }

    public init(url: URL? = nil, dismissalRestrictions: DismissalRestrictions? = nil, dismissStaleReviews: Bool, requireCodeOwnerReviews: Bool, requiredApprovingReviewCount: Int? = nil) {
        self.url = url
        self.dismissalRestrictions = dismissalRestrictions
        self.dismissStaleReviews = dismissStaleReviews
        self.requireCodeOwnerReviews = requireCodeOwnerReviews
        self.requiredApprovingReviewCount = requiredApprovingReviewCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.dismissalRestrictions = try values.decodeIfPresent(DismissalRestrictions.self, forKey: "dismissal_restrictions")
        self.dismissStaleReviews = try values.decode(Bool.self, forKey: "dismiss_stale_reviews")
        self.requireCodeOwnerReviews = try values.decode(Bool.self, forKey: "require_code_owner_reviews")
        self.requiredApprovingReviewCount = try values.decodeIfPresent(Int.self, forKey: "required_approving_review_count")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(dismissalRestrictions, forKey: "dismissal_restrictions")
        try values.encode(dismissStaleReviews, forKey: "dismiss_stale_reviews")
        try values.encode(requireCodeOwnerReviews, forKey: "require_code_owner_reviews")
        try values.encodeIfPresent(requiredApprovingReviewCount, forKey: "required_approving_review_count")
    }
}

public struct BranchRestrictionPolicy: Codable {
    public var url: URL
    public var usersURL: URL
    public var teamsURL: URL
    public var appsURL: URL
    public var users: [User]
    public var teams: [Team]
    public var apps: [App]

    public struct User: Codable {
        public var login: String?
        public var id: Int?
        public var nodeID: String?
        public var avatarURL: String?
        public var gravatarID: String?
        public var url: String?
        public var htmlURL: String?
        public var followersURL: String?
        public var followingURL: String?
        public var gistsURL: String?
        public var starredURL: String?
        public var subscriptionsURL: String?
        public var organizationsURL: String?
        public var reposURL: String?
        public var eventsURL: String?
        public var receivedEventsURL: String?
        public var type: String?
        public var isSiteAdmin: Bool?

        public init(login: String? = nil, id: Int? = nil, nodeID: String? = nil, avatarURL: String? = nil, gravatarID: String? = nil, url: String? = nil, htmlURL: String? = nil, followersURL: String? = nil, followingURL: String? = nil, gistsURL: String? = nil, starredURL: String? = nil, subscriptionsURL: String? = nil, organizationsURL: String? = nil, reposURL: String? = nil, eventsURL: String? = nil, receivedEventsURL: String? = nil, type: String? = nil, isSiteAdmin: Bool? = nil) {
            self.login = login
            self.id = id
            self.nodeID = nodeID
            self.avatarURL = avatarURL
            self.gravatarID = gravatarID
            self.url = url
            self.htmlURL = htmlURL
            self.followersURL = followersURL
            self.followingURL = followingURL
            self.gistsURL = gistsURL
            self.starredURL = starredURL
            self.subscriptionsURL = subscriptionsURL
            self.organizationsURL = organizationsURL
            self.reposURL = reposURL
            self.eventsURL = eventsURL
            self.receivedEventsURL = receivedEventsURL
            self.type = type
            self.isSiteAdmin = isSiteAdmin
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.login = try values.decodeIfPresent(String.self, forKey: "login")
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
            self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.followersURL = try values.decodeIfPresent(String.self, forKey: "followers_url")
            self.followingURL = try values.decodeIfPresent(String.self, forKey: "following_url")
            self.gistsURL = try values.decodeIfPresent(String.self, forKey: "gists_url")
            self.starredURL = try values.decodeIfPresent(String.self, forKey: "starred_url")
            self.subscriptionsURL = try values.decodeIfPresent(String.self, forKey: "subscriptions_url")
            self.organizationsURL = try values.decodeIfPresent(String.self, forKey: "organizations_url")
            self.reposURL = try values.decodeIfPresent(String.self, forKey: "repos_url")
            self.eventsURL = try values.decodeIfPresent(String.self, forKey: "events_url")
            self.receivedEventsURL = try values.decodeIfPresent(String.self, forKey: "received_events_url")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.isSiteAdmin = try values.decodeIfPresent(Bool.self, forKey: "site_admin")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(login, forKey: "login")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
            try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(followersURL, forKey: "followers_url")
            try values.encodeIfPresent(followingURL, forKey: "following_url")
            try values.encodeIfPresent(gistsURL, forKey: "gists_url")
            try values.encodeIfPresent(starredURL, forKey: "starred_url")
            try values.encodeIfPresent(subscriptionsURL, forKey: "subscriptions_url")
            try values.encodeIfPresent(organizationsURL, forKey: "organizations_url")
            try values.encodeIfPresent(reposURL, forKey: "repos_url")
            try values.encodeIfPresent(eventsURL, forKey: "events_url")
            try values.encodeIfPresent(receivedEventsURL, forKey: "received_events_url")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(isSiteAdmin, forKey: "site_admin")
        }
    }

    public struct Team: Codable {
        public var id: Int?
        public var nodeID: String?
        public var url: String?
        public var htmlURL: String?
        public var name: String?
        public var slug: String?
        public var description: String?
        public var privacy: String?
        public var permission: String?
        public var membersURL: String?
        public var repositoriesURL: String?
        public var parent: String?

        public init(id: Int? = nil, nodeID: String? = nil, url: String? = nil, htmlURL: String? = nil, name: String? = nil, slug: String? = nil, description: String? = nil, privacy: String? = nil, permission: String? = nil, membersURL: String? = nil, repositoriesURL: String? = nil, parent: String? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.url = url
            self.htmlURL = htmlURL
            self.name = name
            self.slug = slug
            self.description = description
            self.privacy = privacy
            self.permission = permission
            self.membersURL = membersURL
            self.repositoriesURL = repositoriesURL
            self.parent = parent
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.slug = try values.decodeIfPresent(String.self, forKey: "slug")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.privacy = try values.decodeIfPresent(String.self, forKey: "privacy")
            self.permission = try values.decodeIfPresent(String.self, forKey: "permission")
            self.membersURL = try values.decodeIfPresent(String.self, forKey: "members_url")
            self.repositoriesURL = try values.decodeIfPresent(String.self, forKey: "repositories_url")
            self.parent = try values.decodeIfPresent(String.self, forKey: "parent")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(slug, forKey: "slug")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(privacy, forKey: "privacy")
            try values.encodeIfPresent(permission, forKey: "permission")
            try values.encodeIfPresent(membersURL, forKey: "members_url")
            try values.encodeIfPresent(repositoriesURL, forKey: "repositories_url")
            try values.encodeIfPresent(parent, forKey: "parent")
        }
    }

    public struct App: Codable {
        public var id: Int?
        public var slug: String?
        public var nodeID: String?
        public var owner: Owner?
        public var name: String?
        public var description: String?
        public var externalURL: String?
        public var htmlURL: String?
        public var createdAt: String?
        public var updatedAt: String?
        public var permissions: Permissions?
        public var events: [String]?

        public struct Owner: Codable {
            public var login: String?
            public var id: Int?
            public var nodeID: String?
            public var url: String?
            public var reposURL: String?
            public var eventsURL: String?
            public var hooksURL: String?
            public var issuesURL: String?
            public var membersURL: String?
            public var publicMembersURL: String?
            public var avatarURL: String?
            public var description: String?
            /// Example: ""
            public var gravatarID: String?
            /// Example: "https://github.com/testorg-ea8ec76d71c3af4b"
            public var htmlURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/followers"
            public var followersURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/following{/other_user}"
            public var followingURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/gists{/gist_id}"
            public var gistsURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/starred{/owner}{/repo}"
            public var starredURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/subscriptions"
            public var subscriptionsURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/orgs"
            public var organizationsURL: String?
            /// Example: "https://api.github.com/users/testorg-ea8ec76d71c3af4b/received_events"
            public var receivedEventsURL: String?
            /// Example: "Organization"
            public var type: String?
            /// Example: false
            public var isSiteAdmin: Bool?

            public init(login: String? = nil, id: Int? = nil, nodeID: String? = nil, url: String? = nil, reposURL: String? = nil, eventsURL: String? = nil, hooksURL: String? = nil, issuesURL: String? = nil, membersURL: String? = nil, publicMembersURL: String? = nil, avatarURL: String? = nil, description: String? = nil, gravatarID: String? = nil, htmlURL: String? = nil, followersURL: String? = nil, followingURL: String? = nil, gistsURL: String? = nil, starredURL: String? = nil, subscriptionsURL: String? = nil, organizationsURL: String? = nil, receivedEventsURL: String? = nil, type: String? = nil, isSiteAdmin: Bool? = nil) {
                self.login = login
                self.id = id
                self.nodeID = nodeID
                self.url = url
                self.reposURL = reposURL
                self.eventsURL = eventsURL
                self.hooksURL = hooksURL
                self.issuesURL = issuesURL
                self.membersURL = membersURL
                self.publicMembersURL = publicMembersURL
                self.avatarURL = avatarURL
                self.description = description
                self.gravatarID = gravatarID
                self.htmlURL = htmlURL
                self.followersURL = followersURL
                self.followingURL = followingURL
                self.gistsURL = gistsURL
                self.starredURL = starredURL
                self.subscriptionsURL = subscriptionsURL
                self.organizationsURL = organizationsURL
                self.receivedEventsURL = receivedEventsURL
                self.type = type
                self.isSiteAdmin = isSiteAdmin
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.login = try values.decodeIfPresent(String.self, forKey: "login")
                self.id = try values.decodeIfPresent(Int.self, forKey: "id")
                self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
                self.reposURL = try values.decodeIfPresent(String.self, forKey: "repos_url")
                self.eventsURL = try values.decodeIfPresent(String.self, forKey: "events_url")
                self.hooksURL = try values.decodeIfPresent(String.self, forKey: "hooks_url")
                self.issuesURL = try values.decodeIfPresent(String.self, forKey: "issues_url")
                self.membersURL = try values.decodeIfPresent(String.self, forKey: "members_url")
                self.publicMembersURL = try values.decodeIfPresent(String.self, forKey: "public_members_url")
                self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
                self.followersURL = try values.decodeIfPresent(String.self, forKey: "followers_url")
                self.followingURL = try values.decodeIfPresent(String.self, forKey: "following_url")
                self.gistsURL = try values.decodeIfPresent(String.self, forKey: "gists_url")
                self.starredURL = try values.decodeIfPresent(String.self, forKey: "starred_url")
                self.subscriptionsURL = try values.decodeIfPresent(String.self, forKey: "subscriptions_url")
                self.organizationsURL = try values.decodeIfPresent(String.self, forKey: "organizations_url")
                self.receivedEventsURL = try values.decodeIfPresent(String.self, forKey: "received_events_url")
                self.type = try values.decodeIfPresent(String.self, forKey: "type")
                self.isSiteAdmin = try values.decodeIfPresent(Bool.self, forKey: "site_admin")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(login, forKey: "login")
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(nodeID, forKey: "node_id")
                try values.encodeIfPresent(url, forKey: "url")
                try values.encodeIfPresent(reposURL, forKey: "repos_url")
                try values.encodeIfPresent(eventsURL, forKey: "events_url")
                try values.encodeIfPresent(hooksURL, forKey: "hooks_url")
                try values.encodeIfPresent(issuesURL, forKey: "issues_url")
                try values.encodeIfPresent(membersURL, forKey: "members_url")
                try values.encodeIfPresent(publicMembersURL, forKey: "public_members_url")
                try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                try values.encodeIfPresent(htmlURL, forKey: "html_url")
                try values.encodeIfPresent(followersURL, forKey: "followers_url")
                try values.encodeIfPresent(followingURL, forKey: "following_url")
                try values.encodeIfPresent(gistsURL, forKey: "gists_url")
                try values.encodeIfPresent(starredURL, forKey: "starred_url")
                try values.encodeIfPresent(subscriptionsURL, forKey: "subscriptions_url")
                try values.encodeIfPresent(organizationsURL, forKey: "organizations_url")
                try values.encodeIfPresent(receivedEventsURL, forKey: "received_events_url")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(isSiteAdmin, forKey: "site_admin")
            }
        }

        public struct Permissions: Codable {
            public var metadata: String?
            public var contents: String?
            public var issues: String?
            public var singleFile: String?

            public init(metadata: String? = nil, contents: String? = nil, issues: String? = nil, singleFile: String? = nil) {
                self.metadata = metadata
                self.contents = contents
                self.issues = issues
                self.singleFile = singleFile
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.metadata = try values.decodeIfPresent(String.self, forKey: "metadata")
                self.contents = try values.decodeIfPresent(String.self, forKey: "contents")
                self.issues = try values.decodeIfPresent(String.self, forKey: "issues")
                self.singleFile = try values.decodeIfPresent(String.self, forKey: "single_file")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(metadata, forKey: "metadata")
                try values.encodeIfPresent(contents, forKey: "contents")
                try values.encodeIfPresent(issues, forKey: "issues")
                try values.encodeIfPresent(singleFile, forKey: "single_file")
            }
        }

        public init(id: Int? = nil, slug: String? = nil, nodeID: String? = nil, owner: Owner? = nil, name: String? = nil, description: String? = nil, externalURL: String? = nil, htmlURL: String? = nil, createdAt: String? = nil, updatedAt: String? = nil, permissions: Permissions? = nil, events: [String]? = nil) {
            self.id = id
            self.slug = slug
            self.nodeID = nodeID
            self.owner = owner
            self.name = name
            self.description = description
            self.externalURL = externalURL
            self.htmlURL = htmlURL
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.permissions = permissions
            self.events = events
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.slug = try values.decodeIfPresent(String.self, forKey: "slug")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.owner = try values.decodeIfPresent(Owner.self, forKey: "owner")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.externalURL = try values.decodeIfPresent(String.self, forKey: "external_url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
            self.events = try values.decodeIfPresent([String].self, forKey: "events")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(slug, forKey: "slug")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(owner, forKey: "owner")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(externalURL, forKey: "external_url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encodeIfPresent(events, forKey: "events")
        }
    }

    public init(url: URL, usersURL: URL, teamsURL: URL, appsURL: URL, users: [User], teams: [Team], apps: [App]) {
        self.url = url
        self.usersURL = usersURL
        self.teamsURL = teamsURL
        self.appsURL = appsURL
        self.users = users
        self.teams = teams
        self.apps = apps
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.usersURL = try values.decode(URL.self, forKey: "users_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.appsURL = try values.decode(URL.self, forKey: "apps_url")
        self.users = try values.decode([User].self, forKey: "users")
        self.teams = try values.decode([Team].self, forKey: "teams")
        self.apps = try values.decode([App].self, forKey: "apps")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(usersURL, forKey: "users_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(appsURL, forKey: "apps_url")
        try values.encode(users, forKey: "users")
        try values.encode(teams, forKey: "teams")
        try values.encode(apps, forKey: "apps")
    }
}

public struct BranchProtection: Codable {
    public var url: String?
    public var isEnabled: Bool?
    /// Protected Branch Required Status Check
    public var requiredStatusChecks: ProtectedBranchRequiredStatusCheck?
    /// Protected Branch Admin Enforced
    public var enforceAdmins: ProtectedBranchAdminEnforced?
    /// Protected Branch Pull Request Review
    public var requiredPullRequestReviews: ProtectedBranchPullRequestReview?
    /// Branch Restriction Policy
    public var restrictions: BranchRestrictionPolicy?
    public var requiredLinearHistory: RequiredLinearHistory?
    public var allowForcePushes: AllowForcePushes?
    public var allowDeletions: AllowDeletions?
    public var requiredConversationResolution: RequiredConversationResolution?
    /// Example: "branch/with/protection"
    public var name: String?
    /// Example: "https://api.github.com/repos/owner-79e94e2d36b3fd06a32bb213/AAA_Public_Repo/branches/branch/with/protection/protection"
    public var protectionURL: String?
    public var requiredSignatures: RequiredSignatures?

    public struct RequiredLinearHistory: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isEnabled, forKey: "enabled")
        }
    }

    public struct AllowForcePushes: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isEnabled, forKey: "enabled")
        }
    }

    public struct AllowDeletions: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isEnabled, forKey: "enabled")
        }
    }

    public struct RequiredConversationResolution: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isEnabled, forKey: "enabled")
        }
    }

    public struct RequiredSignatures: Codable {
        /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_signatures"
        public var url: URL
        /// Example: true
        public var isEnabled: Bool

        public init(url: URL, isEnabled: Bool) {
            self.url = url
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public init(url: String? = nil, isEnabled: Bool? = nil, requiredStatusChecks: ProtectedBranchRequiredStatusCheck? = nil, enforceAdmins: ProtectedBranchAdminEnforced? = nil, requiredPullRequestReviews: ProtectedBranchPullRequestReview? = nil, restrictions: BranchRestrictionPolicy? = nil, requiredLinearHistory: RequiredLinearHistory? = nil, allowForcePushes: AllowForcePushes? = nil, allowDeletions: AllowDeletions? = nil, requiredConversationResolution: RequiredConversationResolution? = nil, name: String? = nil, protectionURL: String? = nil, requiredSignatures: RequiredSignatures? = nil) {
        self.url = url
        self.isEnabled = isEnabled
        self.requiredStatusChecks = requiredStatusChecks
        self.enforceAdmins = enforceAdmins
        self.requiredPullRequestReviews = requiredPullRequestReviews
        self.restrictions = restrictions
        self.requiredLinearHistory = requiredLinearHistory
        self.allowForcePushes = allowForcePushes
        self.allowDeletions = allowDeletions
        self.requiredConversationResolution = requiredConversationResolution
        self.name = name
        self.protectionURL = protectionURL
        self.requiredSignatures = requiredSignatures
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        self.requiredStatusChecks = try values.decodeIfPresent(ProtectedBranchRequiredStatusCheck.self, forKey: "required_status_checks")
        self.enforceAdmins = try values.decodeIfPresent(ProtectedBranchAdminEnforced.self, forKey: "enforce_admins")
        self.requiredPullRequestReviews = try values.decodeIfPresent(ProtectedBranchPullRequestReview.self, forKey: "required_pull_request_reviews")
        self.restrictions = try values.decodeIfPresent(BranchRestrictionPolicy.self, forKey: "restrictions")
        self.requiredLinearHistory = try values.decodeIfPresent(RequiredLinearHistory.self, forKey: "required_linear_history")
        self.allowForcePushes = try values.decodeIfPresent(AllowForcePushes.self, forKey: "allow_force_pushes")
        self.allowDeletions = try values.decodeIfPresent(AllowDeletions.self, forKey: "allow_deletions")
        self.requiredConversationResolution = try values.decodeIfPresent(RequiredConversationResolution.self, forKey: "required_conversation_resolution")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.protectionURL = try values.decodeIfPresent(String.self, forKey: "protection_url")
        self.requiredSignatures = try values.decodeIfPresent(RequiredSignatures.self, forKey: "required_signatures")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(requiredStatusChecks, forKey: "required_status_checks")
        try values.encodeIfPresent(enforceAdmins, forKey: "enforce_admins")
        try values.encodeIfPresent(requiredPullRequestReviews, forKey: "required_pull_request_reviews")
        try values.encodeIfPresent(restrictions, forKey: "restrictions")
        try values.encodeIfPresent(requiredLinearHistory, forKey: "required_linear_history")
        try values.encodeIfPresent(allowForcePushes, forKey: "allow_force_pushes")
        try values.encodeIfPresent(allowDeletions, forKey: "allow_deletions")
        try values.encodeIfPresent(requiredConversationResolution, forKey: "required_conversation_resolution")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(protectionURL, forKey: "protection_url")
        try values.encodeIfPresent(requiredSignatures, forKey: "required_signatures")
    }
}

public struct ShortBranch: Codable {
    public var name: String
    public var commit: Commit
    public var isProtected: Bool
    /// Branch Protection
    public var protection: BranchProtection?
    public var protectionURL: URL?

    public struct Commit: Codable {
        public var sha: String
        public var url: URL

        public init(sha: String, url: URL) {
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public init(name: String, commit: Commit, isProtected: Bool, protection: BranchProtection? = nil, protectionURL: URL? = nil) {
        self.name = name
        self.commit = commit
        self.isProtected = isProtected
        self.protection = protection
        self.protectionURL = protectionURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.isProtected = try values.decode(Bool.self, forKey: "protected")
        self.protection = try values.decodeIfPresent(BranchProtection.self, forKey: "protection")
        self.protectionURL = try values.decodeIfPresent(URL.self, forKey: "protection_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(commit, forKey: "commit")
        try values.encode(isProtected, forKey: "protected")
        try values.encodeIfPresent(protection, forKey: "protection")
        try values.encodeIfPresent(protectionURL, forKey: "protection_url")
    }
}

/// Metaproperties for Git author/committer information.
public struct GitUser: Codable {
    /// Example: "Chris Wanstrath"
    public var name: String?
    /// Example: "chris@ozmm.org"
    public var email: String?
    /// Example: "2007-10-29T02:42:39.000-07:00"
    public var date: String?

    public init(name: String? = nil, email: String? = nil, date: String? = nil) {
        self.name = name
        self.email = email
        self.date = date
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.date = try values.decodeIfPresent(String.self, forKey: "date")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(date, forKey: "date")
    }
}

public struct Verification: Codable {
    public var isVerified: Bool
    public var reason: String
    public var payload: String?
    public var signature: String?

    public init(isVerified: Bool, reason: String, payload: String? = nil, signature: String? = nil) {
        self.isVerified = isVerified
        self.reason = reason
        self.payload = payload
        self.signature = signature
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isVerified = try values.decode(Bool.self, forKey: "verified")
        self.reason = try values.decode(String.self, forKey: "reason")
        self.payload = try values.decodeIfPresent(String.self, forKey: "payload")
        self.signature = try values.decodeIfPresent(String.self, forKey: "signature")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isVerified, forKey: "verified")
        try values.encode(reason, forKey: "reason")
        try values.encodeIfPresent(payload, forKey: "payload")
        try values.encodeIfPresent(signature, forKey: "signature")
    }
}

public struct DiffEntry: Codable {
    /// Example: "bbcd538c8e72b8c175046e27cc8f907076331401"
    public var sha: String
    /// Example: "file1.txt"
    public var filename: String
    /// Example: "added"
    public var status: Status
    /// Example: 103
    public var additions: Int
    /// Example: 21
    public var deletions: Int
    /// Example: 124
    public var changes: Int
    /// Example: "https://github.com/octocat/Hello-World/blob/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt"
    public var blobURL: URL
    /// Example: "https://github.com/octocat/Hello-World/raw/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt"
    public var rawURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/contents/file1.txt?ref=6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var contentsURL: URL
    /// Example: "@@ -132,7 +132,7 @@ module Test @@ -1000,7 +1000,7 @@ module Test"
    public var patch: String?
    /// Example: "file.txt"
    public var previousFilename: String?

    /// Example: "added"
    public enum Status: String, Codable, CaseIterable {
        case added
        case removed
        case modified
        case renamed
        case copied
        case changed
        case unchanged
    }

    public init(sha: String, filename: String, status: Status, additions: Int, deletions: Int, changes: Int, blobURL: URL, rawURL: URL, contentsURL: URL, patch: String? = nil, previousFilename: String? = nil) {
        self.sha = sha
        self.filename = filename
        self.status = status
        self.additions = additions
        self.deletions = deletions
        self.changes = changes
        self.blobURL = blobURL
        self.rawURL = rawURL
        self.contentsURL = contentsURL
        self.patch = patch
        self.previousFilename = previousFilename
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decode(String.self, forKey: "sha")
        self.filename = try values.decode(String.self, forKey: "filename")
        self.status = try values.decode(Status.self, forKey: "status")
        self.additions = try values.decode(Int.self, forKey: "additions")
        self.deletions = try values.decode(Int.self, forKey: "deletions")
        self.changes = try values.decode(Int.self, forKey: "changes")
        self.blobURL = try values.decode(URL.self, forKey: "blob_url")
        self.rawURL = try values.decode(URL.self, forKey: "raw_url")
        self.contentsURL = try values.decode(URL.self, forKey: "contents_url")
        self.patch = try values.decodeIfPresent(String.self, forKey: "patch")
        self.previousFilename = try values.decodeIfPresent(String.self, forKey: "previous_filename")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(sha, forKey: "sha")
        try values.encode(filename, forKey: "filename")
        try values.encode(status, forKey: "status")
        try values.encode(additions, forKey: "additions")
        try values.encode(deletions, forKey: "deletions")
        try values.encode(changes, forKey: "changes")
        try values.encode(blobURL, forKey: "blob_url")
        try values.encode(rawURL, forKey: "raw_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encodeIfPresent(patch, forKey: "patch")
        try values.encodeIfPresent(previousFilename, forKey: "previous_filename")
    }
}

public struct Commit: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var url: URL
    /// Example: "6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var sha: String
    /// Example: "MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ=="
    public var nodeID: String
    /// Example: "https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var htmlURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments"
    public var commentsURL: URL
    public var commit: Commit
    /// Simple User
    public var author: SimpleUser?
    /// Simple User
    public var committer: SimpleUser?
    public var parents: [Parent]
    public var stats: Stats?
    public var files: [DiffEntry]?

    public struct Commit: Codable {
        /// Example: "https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e"
        public var url: URL
        /// Git User
        ///
        /// Metaproperties for Git author/committer information.
        public var author: GitUser?
        /// Git User
        ///
        /// Metaproperties for Git author/committer information.
        public var committer: GitUser?
        /// Example: "Fix all the bugs"
        public var message: String
        public var commentCount: Int
        public var tree: Tree
        public var verification: Verification?

        public struct Tree: Codable {
            /// Example: "827efc6d56897b048c772eb4087f854f46256132"
            public var sha: String
            /// Example: "https://api.github.com/repos/octocat/Hello-World/tree/827efc6d56897b048c772eb4087f854f46256132"
            public var url: URL

            public init(sha: String, url: URL) {
                self.sha = sha
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.sha = try values.decode(String.self, forKey: "sha")
                self.url = try values.decode(URL.self, forKey: "url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(sha, forKey: "sha")
                try values.encode(url, forKey: "url")
            }
        }

        public init(url: URL, author: GitUser? = nil, committer: GitUser? = nil, message: String, commentCount: Int, tree: Tree, verification: Verification? = nil) {
            self.url = url
            self.author = author
            self.committer = committer
            self.message = message
            self.commentCount = commentCount
            self.tree = tree
            self.verification = verification
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.author = try values.decodeIfPresent(GitUser.self, forKey: "author")
            self.committer = try values.decodeIfPresent(GitUser.self, forKey: "committer")
            self.message = try values.decode(String.self, forKey: "message")
            self.commentCount = try values.decode(Int.self, forKey: "comment_count")
            self.tree = try values.decode(Tree.self, forKey: "tree")
            self.verification = try values.decodeIfPresent(Verification.self, forKey: "verification")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encodeIfPresent(author, forKey: "author")
            try values.encodeIfPresent(committer, forKey: "committer")
            try values.encode(message, forKey: "message")
            try values.encode(commentCount, forKey: "comment_count")
            try values.encode(tree, forKey: "tree")
            try values.encodeIfPresent(verification, forKey: "verification")
        }
    }

    public struct Parent: Codable {
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        /// Example: "https://api.github.com/repos/octocat/Hello-World/commits/7638417db6d59f3c431d3e1f261cc637155684cd"
        public var url: URL
        /// Example: "https://github.com/octocat/Hello-World/commit/7638417db6d59f3c431d3e1f261cc637155684cd"
        public var htmlURL: URL?

        public init(sha: String, url: URL, htmlURL: URL? = nil) {
            self.sha = sha
            self.url = url
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
        }
    }

    public struct Stats: Codable {
        public var additions: Int?
        public var deletions: Int?
        public var total: Int?

        public init(additions: Int? = nil, deletions: Int? = nil, total: Int? = nil) {
            self.additions = additions
            self.deletions = deletions
            self.total = total
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.additions = try values.decodeIfPresent(Int.self, forKey: "additions")
            self.deletions = try values.decodeIfPresent(Int.self, forKey: "deletions")
            self.total = try values.decodeIfPresent(Int.self, forKey: "total")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(additions, forKey: "additions")
            try values.encodeIfPresent(deletions, forKey: "deletions")
            try values.encodeIfPresent(total, forKey: "total")
        }
    }

    public init(url: URL, sha: String, nodeID: String, htmlURL: URL, commentsURL: URL, commit: Commit, author: SimpleUser? = nil, committer: SimpleUser? = nil, parents: [Parent], stats: Stats? = nil, files: [DiffEntry]? = nil) {
        self.url = url
        self.sha = sha
        self.nodeID = nodeID
        self.htmlURL = htmlURL
        self.commentsURL = commentsURL
        self.commit = commit
        self.author = author
        self.committer = committer
        self.parents = parents
        self.stats = stats
        self.files = files
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.author = try values.decodeIfPresent(SimpleUser.self, forKey: "author")
        self.committer = try values.decodeIfPresent(SimpleUser.self, forKey: "committer")
        self.parents = try values.decode([Parent].self, forKey: "parents")
        self.stats = try values.decodeIfPresent(Stats.self, forKey: "stats")
        self.files = try values.decodeIfPresent([DiffEntry].self, forKey: "files")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(sha, forKey: "sha")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commit, forKey: "commit")
        try values.encodeIfPresent(author, forKey: "author")
        try values.encodeIfPresent(committer, forKey: "committer")
        try values.encode(parents, forKey: "parents")
        try values.encodeIfPresent(stats, forKey: "stats")
        try values.encodeIfPresent(files, forKey: "files")
    }
}

public struct BranchWithProtection: Codable {
    public var name: String
    public var commit: Commit
    public var links: Links
    public var isProtected: Bool
    /// Branch Protection
    public var protection: BranchProtection
    public var protectionURL: URL
    /// Example: "mas*"
    public var pattern: String?
    public var requiredApprovingReviewCount: Int?

    public struct Links: Codable {
        public var html: String
        public var this: URL

        public init(html: String, this: URL) {
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.html = try values.decode(String.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(name: String, commit: Commit, links: Links, isProtected: Bool, protection: BranchProtection, protectionURL: URL, pattern: String? = nil, requiredApprovingReviewCount: Int? = nil) {
        self.name = name
        self.commit = commit
        self.links = links
        self.isProtected = isProtected
        self.protection = protection
        self.protectionURL = protectionURL
        self.pattern = pattern
        self.requiredApprovingReviewCount = requiredApprovingReviewCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.isProtected = try values.decode(Bool.self, forKey: "protected")
        self.protection = try values.decode(BranchProtection.self, forKey: "protection")
        self.protectionURL = try values.decode(URL.self, forKey: "protection_url")
        self.pattern = try values.decodeIfPresent(String.self, forKey: "pattern")
        self.requiredApprovingReviewCount = try values.decodeIfPresent(Int.self, forKey: "required_approving_review_count")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(commit, forKey: "commit")
        try values.encode(links, forKey: "_links")
        try values.encode(isProtected, forKey: "protected")
        try values.encode(protection, forKey: "protection")
        try values.encode(protectionURL, forKey: "protection_url")
        try values.encodeIfPresent(pattern, forKey: "pattern")
        try values.encodeIfPresent(requiredApprovingReviewCount, forKey: "required_approving_review_count")
    }
}

public struct StatusCheckPolicy: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks"
    public var url: URL
    /// Example: true
    public var isStrict: Bool
    /// Example: ["continuous-integration/travis-ci"]
    public var contexts: [String]
    public var checks: [Check]
    /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks/contexts"
    public var contextsURL: URL

    public struct Check: Codable {
        /// Example: "continuous-integration/travis-ci"
        public var context: String
        public var appID: Int?

        public init(context: String, appID: Int? = nil) {
            self.context = context
            self.appID = appID
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.context = try values.decode(String.self, forKey: "context")
            self.appID = try values.decodeIfPresent(Int.self, forKey: "app_id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(context, forKey: "context")
            try values.encodeIfPresent(appID, forKey: "app_id")
        }
    }

    public init(url: URL, isStrict: Bool, contexts: [String], checks: [Check], contextsURL: URL) {
        self.url = url
        self.isStrict = isStrict
        self.contexts = contexts
        self.checks = checks
        self.contextsURL = contextsURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.isStrict = try values.decode(Bool.self, forKey: "strict")
        self.contexts = try values.decode([String].self, forKey: "contexts")
        self.checks = try values.decode([Check].self, forKey: "checks")
        self.contextsURL = try values.decode(URL.self, forKey: "contexts_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(isStrict, forKey: "strict")
        try values.encode(contexts, forKey: "contexts")
        try values.encode(checks, forKey: "checks")
        try values.encode(contextsURL, forKey: "contexts_url")
    }
}

/// Branch protections protect branches
public struct ProtectedBranch: Codable {
    public var url: URL
    /// Status Check Policy
    public var requiredStatusChecks: StatusCheckPolicy?
    public var requiredPullRequestReviews: RequiredPullRequestReviews?
    public var requiredSignatures: RequiredSignatures?
    public var enforceAdmins: EnforceAdmins?
    public var requiredLinearHistory: RequiredLinearHistory?
    public var allowForcePushes: AllowForcePushes?
    public var allowDeletions: AllowDeletions?
    /// Branch Restriction Policy
    public var restrictions: BranchRestrictionPolicy?
    public var requiredConversationResolution: RequiredConversationResolution?

    public struct RequiredPullRequestReviews: Codable {
        public var url: URL
        public var dismissStaleReviews: Bool?
        public var requireCodeOwnerReviews: Bool?
        public var requiredApprovingReviewCount: Int?
        public var dismissalRestrictions: DismissalRestrictions?

        public struct DismissalRestrictions: Codable {
            public var url: URL
            public var usersURL: URL
            public var teamsURL: URL
            public var users: [SimpleUser]
            public var teams: [Team]

            public init(url: URL, usersURL: URL, teamsURL: URL, users: [SimpleUser], teams: [Team]) {
                self.url = url
                self.usersURL = usersURL
                self.teamsURL = teamsURL
                self.users = users
                self.teams = teams
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.url = try values.decode(URL.self, forKey: "url")
                self.usersURL = try values.decode(URL.self, forKey: "users_url")
                self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
                self.users = try values.decode([SimpleUser].self, forKey: "users")
                self.teams = try values.decode([Team].self, forKey: "teams")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(url, forKey: "url")
                try values.encode(usersURL, forKey: "users_url")
                try values.encode(teamsURL, forKey: "teams_url")
                try values.encode(users, forKey: "users")
                try values.encode(teams, forKey: "teams")
            }
        }

        public init(url: URL, dismissStaleReviews: Bool? = nil, requireCodeOwnerReviews: Bool? = nil, requiredApprovingReviewCount: Int? = nil, dismissalRestrictions: DismissalRestrictions? = nil) {
            self.url = url
            self.dismissStaleReviews = dismissStaleReviews
            self.requireCodeOwnerReviews = requireCodeOwnerReviews
            self.requiredApprovingReviewCount = requiredApprovingReviewCount
            self.dismissalRestrictions = dismissalRestrictions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.dismissStaleReviews = try values.decodeIfPresent(Bool.self, forKey: "dismiss_stale_reviews")
            self.requireCodeOwnerReviews = try values.decodeIfPresent(Bool.self, forKey: "require_code_owner_reviews")
            self.requiredApprovingReviewCount = try values.decodeIfPresent(Int.self, forKey: "required_approving_review_count")
            self.dismissalRestrictions = try values.decodeIfPresent(DismissalRestrictions.self, forKey: "dismissal_restrictions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encodeIfPresent(dismissStaleReviews, forKey: "dismiss_stale_reviews")
            try values.encodeIfPresent(requireCodeOwnerReviews, forKey: "require_code_owner_reviews")
            try values.encodeIfPresent(requiredApprovingReviewCount, forKey: "required_approving_review_count")
            try values.encodeIfPresent(dismissalRestrictions, forKey: "dismissal_restrictions")
        }
    }

    public struct RequiredSignatures: Codable {
        /// Example: "https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_signatures"
        public var url: URL
        /// Example: true
        public var isEnabled: Bool

        public init(url: URL, isEnabled: Bool) {
            self.url = url
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public struct EnforceAdmins: Codable {
        public var url: URL
        public var isEnabled: Bool

        public init(url: URL, isEnabled: Bool) {
            self.url = url
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decode(URL.self, forKey: "url")
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(url, forKey: "url")
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public struct RequiredLinearHistory: Codable {
        public var isEnabled: Bool

        public init(isEnabled: Bool) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public struct AllowForcePushes: Codable {
        public var isEnabled: Bool

        public init(isEnabled: Bool) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public struct AllowDeletions: Codable {
        public var isEnabled: Bool

        public init(isEnabled: Bool) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isEnabled, forKey: "enabled")
        }
    }

    public struct RequiredConversationResolution: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isEnabled, forKey: "enabled")
        }
    }

    public init(url: URL, requiredStatusChecks: StatusCheckPolicy? = nil, requiredPullRequestReviews: RequiredPullRequestReviews? = nil, requiredSignatures: RequiredSignatures? = nil, enforceAdmins: EnforceAdmins? = nil, requiredLinearHistory: RequiredLinearHistory? = nil, allowForcePushes: AllowForcePushes? = nil, allowDeletions: AllowDeletions? = nil, restrictions: BranchRestrictionPolicy? = nil, requiredConversationResolution: RequiredConversationResolution? = nil) {
        self.url = url
        self.requiredStatusChecks = requiredStatusChecks
        self.requiredPullRequestReviews = requiredPullRequestReviews
        self.requiredSignatures = requiredSignatures
        self.enforceAdmins = enforceAdmins
        self.requiredLinearHistory = requiredLinearHistory
        self.allowForcePushes = allowForcePushes
        self.allowDeletions = allowDeletions
        self.restrictions = restrictions
        self.requiredConversationResolution = requiredConversationResolution
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.requiredStatusChecks = try values.decodeIfPresent(StatusCheckPolicy.self, forKey: "required_status_checks")
        self.requiredPullRequestReviews = try values.decodeIfPresent(RequiredPullRequestReviews.self, forKey: "required_pull_request_reviews")
        self.requiredSignatures = try values.decodeIfPresent(RequiredSignatures.self, forKey: "required_signatures")
        self.enforceAdmins = try values.decodeIfPresent(EnforceAdmins.self, forKey: "enforce_admins")
        self.requiredLinearHistory = try values.decodeIfPresent(RequiredLinearHistory.self, forKey: "required_linear_history")
        self.allowForcePushes = try values.decodeIfPresent(AllowForcePushes.self, forKey: "allow_force_pushes")
        self.allowDeletions = try values.decodeIfPresent(AllowDeletions.self, forKey: "allow_deletions")
        self.restrictions = try values.decodeIfPresent(BranchRestrictionPolicy.self, forKey: "restrictions")
        self.requiredConversationResolution = try values.decodeIfPresent(RequiredConversationResolution.self, forKey: "required_conversation_resolution")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(requiredStatusChecks, forKey: "required_status_checks")
        try values.encodeIfPresent(requiredPullRequestReviews, forKey: "required_pull_request_reviews")
        try values.encodeIfPresent(requiredSignatures, forKey: "required_signatures")
        try values.encodeIfPresent(enforceAdmins, forKey: "enforce_admins")
        try values.encodeIfPresent(requiredLinearHistory, forKey: "required_linear_history")
        try values.encodeIfPresent(allowForcePushes, forKey: "allow_force_pushes")
        try values.encodeIfPresent(allowDeletions, forKey: "allow_deletions")
        try values.encodeIfPresent(restrictions, forKey: "restrictions")
        try values.encodeIfPresent(requiredConversationResolution, forKey: "required_conversation_resolution")
    }
}

/// Deployment
///
/// A deployment created as the result of an Actions check run from a workflow that references an environment
public struct DeploymentSimple: Codable {
    /// Example: "https://api.github.com/repos/octocat/example/deployments/1"
    public var url: URL
    /// Unique identifier of the deployment
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDEwOkRlcGxveW1lbnQx"
    public var nodeID: String
    /// Parameter to specify a task to execute
    ///
    /// Example: "deploy"
    public var task: String
    /// Example: "staging"
    public var originalEnvironment: String?
    /// Name for the target deployment environment.
    ///
    /// Example: "production"
    public var environment: String
    /// Example: "Deploy request from hubot"
    public var description: String?
    /// Example: "2012-07-20T01:19:13Z"
    public var createdAt: Date
    /// Example: "2012-07-20T01:19:13Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/repos/octocat/example/deployments/1/statuses"
    public var statusesURL: URL
    /// Example: "https://api.github.com/repos/octocat/example"
    public var repositoryURL: URL
    /// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
    ///
    /// Example: true
    public var isTransientEnvironment: Bool?
    /// Specifies if the given environment is one that end-users directly interact with. Default: false.
    ///
    /// Example: true
    public var isProductionEnvironment: Bool?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?

    public init(url: URL, id: Int, nodeID: String, task: String, originalEnvironment: String? = nil, environment: String, description: String? = nil, createdAt: Date, updatedAt: Date, statusesURL: URL, repositoryURL: URL, isTransientEnvironment: Bool? = nil, isProductionEnvironment: Bool? = nil, performedViaGithubApp: Integration? = nil) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.task = task
        self.originalEnvironment = originalEnvironment
        self.environment = environment
        self.description = description
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.statusesURL = statusesURL
        self.repositoryURL = repositoryURL
        self.isTransientEnvironment = isTransientEnvironment
        self.isProductionEnvironment = isProductionEnvironment
        self.performedViaGithubApp = performedViaGithubApp
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.task = try values.decode(String.self, forKey: "task")
        self.originalEnvironment = try values.decodeIfPresent(String.self, forKey: "original_environment")
        self.environment = try values.decode(String.self, forKey: "environment")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.statusesURL = try values.decode(URL.self, forKey: "statuses_url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.isTransientEnvironment = try values.decodeIfPresent(Bool.self, forKey: "transient_environment")
        self.isProductionEnvironment = try values.decodeIfPresent(Bool.self, forKey: "production_environment")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(task, forKey: "task")
        try values.encodeIfPresent(originalEnvironment, forKey: "original_environment")
        try values.encode(environment, forKey: "environment")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encodeIfPresent(isTransientEnvironment, forKey: "transient_environment")
        try values.encodeIfPresent(isProductionEnvironment, forKey: "production_environment")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
    }
}

/// A check performed on the code of a given code change
public struct CheckRun: Codable {
    /// The id of the check.
    ///
    /// Example: 21
    public var id: Int
    /// The SHA of the commit that is being checked.
    ///
    /// Example: "009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d"
    public var headSha: String
    /// Example: "MDg6Q2hlY2tSdW40"
    public var nodeID: String
    /// Example: "42"
    public var externalID: String?
    /// Example: "https://api.github.com/repos/github/hello-world/check-runs/4"
    public var url: String
    /// Example: "https://github.com/github/hello-world/runs/4"
    public var htmlURL: String?
    /// Example: "https://example.com"
    public var detailsURL: String?
    /// The phase of the lifecycle that the check is currently in.
    ///
    /// Example: "queued"
    public var status: Status
    /// Example: "neutral"
    public var conclusion: Conclusion?
    /// Example: "2018-05-04T01:14:52Z"
    public var startedAt: Date?
    /// Example: "2018-05-04T01:14:52Z"
    public var completedAt: Date?
    public var output: Output
    /// The name of the check.
    ///
    /// Example: "test-coverage"
    public var name: String
    public var checkSuite: CheckSuite?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var app: Integration?
    public var pullRequests: [PullRequestMinimal]
    /// A deployment created as the result of an Actions check run from a workflow that references an environment
    public var deployment: DeploymentSimple?

    /// The phase of the lifecycle that the check is currently in.
    ///
    /// Example: "queued"
    public enum Status: String, Codable, CaseIterable {
        case queued
        case inProgress = "in_progress"
        case completed
    }

    /// Example: "neutral"
    public enum Conclusion: String, Codable, CaseIterable {
        case success
        case failure
        case neutral
        case cancelled
        case skipped
        case timedOut = "timed_out"
        case actionRequired = "action_required"
    }

    public struct Output: Codable {
        public var title: String?
        public var summary: String?
        public var text: String?
        public var annotationsCount: Int
        public var annotationsURL: URL

        public init(title: String? = nil, summary: String? = nil, text: String? = nil, annotationsCount: Int, annotationsURL: URL) {
            self.title = title
            self.summary = summary
            self.text = text
            self.annotationsCount = annotationsCount
            self.annotationsURL = annotationsURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.title = try values.decodeIfPresent(String.self, forKey: "title")
            self.summary = try values.decodeIfPresent(String.self, forKey: "summary")
            self.text = try values.decodeIfPresent(String.self, forKey: "text")
            self.annotationsCount = try values.decode(Int.self, forKey: "annotations_count")
            self.annotationsURL = try values.decode(URL.self, forKey: "annotations_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(title, forKey: "title")
            try values.encodeIfPresent(summary, forKey: "summary")
            try values.encodeIfPresent(text, forKey: "text")
            try values.encode(annotationsCount, forKey: "annotations_count")
            try values.encode(annotationsURL, forKey: "annotations_url")
        }
    }

    public struct CheckSuite: Codable {
        public var id: Int

        public init(id: Int) {
            self.id = id
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
        }
    }

    public init(id: Int, headSha: String, nodeID: String, externalID: String? = nil, url: String, htmlURL: String? = nil, detailsURL: String? = nil, status: Status, conclusion: Conclusion? = nil, startedAt: Date? = nil, completedAt: Date? = nil, output: Output, name: String, checkSuite: CheckSuite? = nil, app: Integration? = nil, pullRequests: [PullRequestMinimal], deployment: DeploymentSimple? = nil) {
        self.id = id
        self.headSha = headSha
        self.nodeID = nodeID
        self.externalID = externalID
        self.url = url
        self.htmlURL = htmlURL
        self.detailsURL = detailsURL
        self.status = status
        self.conclusion = conclusion
        self.startedAt = startedAt
        self.completedAt = completedAt
        self.output = output
        self.name = name
        self.checkSuite = checkSuite
        self.app = app
        self.pullRequests = pullRequests
        self.deployment = deployment
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.headSha = try values.decode(String.self, forKey: "head_sha")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "external_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.detailsURL = try values.decodeIfPresent(String.self, forKey: "details_url")
        self.status = try values.decode(Status.self, forKey: "status")
        self.conclusion = try values.decodeIfPresent(Conclusion.self, forKey: "conclusion")
        self.startedAt = try values.decodeIfPresent(Date.self, forKey: "started_at")
        self.completedAt = try values.decodeIfPresent(Date.self, forKey: "completed_at")
        self.output = try values.decode(Output.self, forKey: "output")
        self.name = try values.decode(String.self, forKey: "name")
        self.checkSuite = try values.decodeIfPresent(CheckSuite.self, forKey: "check_suite")
        self.app = try values.decodeIfPresent(Integration.self, forKey: "app")
        self.pullRequests = try values.decode([PullRequestMinimal].self, forKey: "pull_requests")
        self.deployment = try values.decodeIfPresent(DeploymentSimple.self, forKey: "deployment")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(headSha, forKey: "head_sha")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(externalID, forKey: "external_id")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(detailsURL, forKey: "details_url")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(conclusion, forKey: "conclusion")
        try values.encodeIfPresent(startedAt, forKey: "started_at")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encode(output, forKey: "output")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(checkSuite, forKey: "check_suite")
        try values.encodeIfPresent(app, forKey: "app")
        try values.encode(pullRequests, forKey: "pull_requests")
        try values.encodeIfPresent(deployment, forKey: "deployment")
    }
}

public struct CheckAnnotation: Codable {
    /// Example: "README.md"
    public var path: String
    public var startLine: Int
    public var endLine: Int
    public var startColumn: Int?
    /// Example: 10
    public var endColumn: Int?
    /// Example: "warning"
    public var annotationLevel: String?
    /// Example: "Spell Checker"
    public var title: String?
    /// Example: "Check your spelling for 'banaas'."
    public var message: String?
    /// Example: "Do you mean 'bananas' or 'banana'?"
    public var rawDetails: String?
    public var blobHref: String

    public init(path: String, startLine: Int, endLine: Int, startColumn: Int? = nil, endColumn: Int? = nil, annotationLevel: String? = nil, title: String? = nil, message: String? = nil, rawDetails: String? = nil, blobHref: String) {
        self.path = path
        self.startLine = startLine
        self.endLine = endLine
        self.startColumn = startColumn
        self.endColumn = endColumn
        self.annotationLevel = annotationLevel
        self.title = title
        self.message = message
        self.rawDetails = rawDetails
        self.blobHref = blobHref
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.path = try values.decode(String.self, forKey: "path")
        self.startLine = try values.decode(Int.self, forKey: "start_line")
        self.endLine = try values.decode(Int.self, forKey: "end_line")
        self.startColumn = try values.decodeIfPresent(Int.self, forKey: "start_column")
        self.endColumn = try values.decodeIfPresent(Int.self, forKey: "end_column")
        self.annotationLevel = try values.decodeIfPresent(String.self, forKey: "annotation_level")
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.rawDetails = try values.decodeIfPresent(String.self, forKey: "raw_details")
        self.blobHref = try values.decode(String.self, forKey: "blob_href")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(path, forKey: "path")
        try values.encode(startLine, forKey: "start_line")
        try values.encode(endLine, forKey: "end_line")
        try values.encodeIfPresent(startColumn, forKey: "start_column")
        try values.encodeIfPresent(endColumn, forKey: "end_column")
        try values.encodeIfPresent(annotationLevel, forKey: "annotation_level")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(rawDetails, forKey: "raw_details")
        try values.encode(blobHref, forKey: "blob_href")
    }
}

public struct SimpleCommit: Codable {
    public var id: String
    public var treeID: String
    public var message: String
    public var timestamp: Date
    public var author: Author?
    public var committer: Committer?

    public struct Author: Codable {
        public var name: String
        public var email: String

        public init(name: String, email: String) {
            self.name = name
            self.email = email
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.email = try values.decode(String.self, forKey: "email")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(email, forKey: "email")
        }
    }

    public struct Committer: Codable {
        public var name: String
        public var email: String

        public init(name: String, email: String) {
            self.name = name
            self.email = email
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.email = try values.decode(String.self, forKey: "email")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(email, forKey: "email")
        }
    }

    public init(id: String, treeID: String, message: String, timestamp: Date, author: Author? = nil, committer: Committer? = nil) {
        self.id = id
        self.treeID = treeID
        self.message = message
        self.timestamp = timestamp
        self.author = author
        self.committer = committer
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.treeID = try values.decode(String.self, forKey: "tree_id")
        self.message = try values.decode(String.self, forKey: "message")
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.author = try values.decodeIfPresent(Author.self, forKey: "author")
        self.committer = try values.decodeIfPresent(Committer.self, forKey: "committer")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(treeID, forKey: "tree_id")
        try values.encode(message, forKey: "message")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encodeIfPresent(author, forKey: "author")
        try values.encodeIfPresent(committer, forKey: "committer")
    }
}

/// A suite of checks performed on the code of a given code change
public struct CheckSuite: Codable {
    public var id: Int
    /// Example: "MDEwOkNoZWNrU3VpdGU1"
    public var nodeID: String
    /// Example: "master"
    public var headBranch: String?
    /// The SHA of the head commit that is being checked.
    ///
    /// Example: "009b8a3a9ccbb128af87f9b1c0f4c62e8a304f6d"
    public var headSha: String
    /// Example: "completed"
    public var status: Status?
    /// Example: "neutral"
    public var conclusion: Conclusion?
    /// Example: "https://api.github.com/repos/github/hello-world/check-suites/5"
    public var url: String?
    /// Example: "146e867f55c26428e5f9fade55a9bbf5e95a7912"
    public var before: String?
    /// Example: "d6fde92930d4715a2b49857d24b940956b26d2d3"
    public var after: String?
    public var pullRequests: [PullRequestMinimal]?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var app: Integration?
    /// Minimal Repository
    public var repository: MinimalRepository
    public var createdAt: Date?
    public var updatedAt: Date?
    /// Simple Commit
    public var headCommit: SimpleCommit
    public var latestCheckRunsCount: Int
    public var checkRunsURL: String
    public var isRerequestable: Bool?
    public var isRunsRerequestable: Bool?

    /// Example: "completed"
    public enum Status: String, Codable, CaseIterable {
        case queued
        case inProgress = "in_progress"
        case completed
    }

    /// Example: "neutral"
    public enum Conclusion: String, Codable, CaseIterable {
        case success
        case failure
        case neutral
        case cancelled
        case skipped
        case timedOut = "timed_out"
        case actionRequired = "action_required"
    }

    public init(id: Int, nodeID: String, headBranch: String? = nil, headSha: String, status: Status? = nil, conclusion: Conclusion? = nil, url: String? = nil, before: String? = nil, after: String? = nil, pullRequests: [PullRequestMinimal]? = nil, app: Integration? = nil, repository: MinimalRepository, createdAt: Date? = nil, updatedAt: Date? = nil, headCommit: SimpleCommit, latestCheckRunsCount: Int, checkRunsURL: String, isRerequestable: Bool? = nil, isRunsRerequestable: Bool? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.headBranch = headBranch
        self.headSha = headSha
        self.status = status
        self.conclusion = conclusion
        self.url = url
        self.before = before
        self.after = after
        self.pullRequests = pullRequests
        self.app = app
        self.repository = repository
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.headCommit = headCommit
        self.latestCheckRunsCount = latestCheckRunsCount
        self.checkRunsURL = checkRunsURL
        self.isRerequestable = isRerequestable
        self.isRunsRerequestable = isRunsRerequestable
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.headBranch = try values.decodeIfPresent(String.self, forKey: "head_branch")
        self.headSha = try values.decode(String.self, forKey: "head_sha")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.conclusion = try values.decodeIfPresent(Conclusion.self, forKey: "conclusion")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.before = try values.decodeIfPresent(String.self, forKey: "before")
        self.after = try values.decodeIfPresent(String.self, forKey: "after")
        self.pullRequests = try values.decodeIfPresent([PullRequestMinimal].self, forKey: "pull_requests")
        self.app = try values.decodeIfPresent(Integration.self, forKey: "app")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.headCommit = try values.decode(SimpleCommit.self, forKey: "head_commit")
        self.latestCheckRunsCount = try values.decode(Int.self, forKey: "latest_check_runs_count")
        self.checkRunsURL = try values.decode(String.self, forKey: "check_runs_url")
        self.isRerequestable = try values.decodeIfPresent(Bool.self, forKey: "rerequestable")
        self.isRunsRerequestable = try values.decodeIfPresent(Bool.self, forKey: "runs_rerequestable")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(headBranch, forKey: "head_branch")
        try values.encode(headSha, forKey: "head_sha")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(conclusion, forKey: "conclusion")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(before, forKey: "before")
        try values.encodeIfPresent(after, forKey: "after")
        try values.encodeIfPresent(pullRequests, forKey: "pull_requests")
        try values.encodeIfPresent(app, forKey: "app")
        try values.encode(repository, forKey: "repository")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(headCommit, forKey: "head_commit")
        try values.encode(latestCheckRunsCount, forKey: "latest_check_runs_count")
        try values.encode(checkRunsURL, forKey: "check_runs_url")
        try values.encodeIfPresent(isRerequestable, forKey: "rerequestable")
        try values.encodeIfPresent(isRunsRerequestable, forKey: "runs_rerequestable")
    }
}

/// Check suite configuration preferences for a repository.
public struct CheckSuitePreference: Codable {
    public var preferences: Preferences
    /// Minimal Repository
    public var repository: MinimalRepository

    public struct Preferences: Codable {
        public var autoTriggerChecks: [AutoTriggerCheck]?

        public struct AutoTriggerCheck: Codable {
            public var appID: Int
            public var isSetting: Bool

            public init(appID: Int, isSetting: Bool) {
                self.appID = appID
                self.isSetting = isSetting
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.appID = try values.decode(Int.self, forKey: "app_id")
                self.isSetting = try values.decode(Bool.self, forKey: "setting")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(appID, forKey: "app_id")
                try values.encode(isSetting, forKey: "setting")
            }
        }

        public init(autoTriggerChecks: [AutoTriggerCheck]? = nil) {
            self.autoTriggerChecks = autoTriggerChecks
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTriggerChecks = try values.decodeIfPresent([AutoTriggerCheck].self, forKey: "auto_trigger_checks")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(autoTriggerChecks, forKey: "auto_trigger_checks")
        }
    }

    public init(preferences: Preferences, repository: MinimalRepository) {
        self.preferences = preferences
        self.repository = repository
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.preferences = try values.decode(Preferences.self, forKey: "preferences")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(preferences, forKey: "preferences")
        try values.encode(repository, forKey: "repository")
    }
}

/// State of a code scanning alert.
public enum CodeScanningAlertState: String, Codable, CaseIterable {
    case `open`
    case closed
    case dismissed
    case fixed
}

/// **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
public enum CodeScanningAlertDismissedReason: String, Codable, CaseIterable {
    case falsePositive = "false positive"
    case wontFix = "won't fix"
    case usedInTests = "used in tests"
}

public struct CodeScanningAlertRuleSummary: Codable {
    /// A unique identifier for the rule used to detect the alert.
    public var id: String?
    /// The name of the rule used to detect the alert.
    public var name: String?
    /// The severity of the alert.
    public var severity: Severity?
    /// A short description of the rule used to detect the alert.
    public var description: String?

    /// The severity of the alert.
    public enum Severity: String, Codable, CaseIterable {
        case `none`
        case note
        case warning
        case error
    }

    public init(id: String? = nil, name: String? = nil, severity: Severity? = nil, description: String? = nil) {
        self.id = id
        self.name = name
        self.severity = severity
        self.description = description
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.severity = try values.decodeIfPresent(Severity.self, forKey: "severity")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(severity, forKey: "severity")
        try values.encodeIfPresent(description, forKey: "description")
    }
}

public struct CodeScanningAnalysisTool: Codable {
    /// The name of the tool used to generate the code scanning analysis.
    public var name: String?
    /// The version of the tool used to generate the code scanning analysis.
    public var version: String?
    /// The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
    public var guid: String?

    public init(name: String? = nil, version: String? = nil, guid: String? = nil) {
        self.name = name
        self.version = version
        self.guid = guid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.version = try values.decodeIfPresent(String.self, forKey: "version")
        self.guid = try values.decodeIfPresent(String.self, forKey: "guid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(version, forKey: "version")
        try values.encodeIfPresent(guid, forKey: "guid")
    }
}

/// Describe a region within a file for the alert.
public struct CodeScanningAlertLocation: Codable {
    public var path: String?
    public var startLine: Int?
    public var endLine: Int?
    public var startColumn: Int?
    public var endColumn: Int?

    public init(path: String? = nil, startLine: Int? = nil, endLine: Int? = nil, startColumn: Int? = nil, endColumn: Int? = nil) {
        self.path = path
        self.startLine = startLine
        self.endLine = endLine
        self.startColumn = startColumn
        self.endColumn = endColumn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.path = try values.decodeIfPresent(String.self, forKey: "path")
        self.startLine = try values.decodeIfPresent(Int.self, forKey: "start_line")
        self.endLine = try values.decodeIfPresent(Int.self, forKey: "end_line")
        self.startColumn = try values.decodeIfPresent(Int.self, forKey: "start_column")
        self.endColumn = try values.decodeIfPresent(Int.self, forKey: "end_column")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(path, forKey: "path")
        try values.encodeIfPresent(startLine, forKey: "start_line")
        try values.encodeIfPresent(endLine, forKey: "end_line")
        try values.encodeIfPresent(startColumn, forKey: "start_column")
        try values.encodeIfPresent(endColumn, forKey: "end_column")
    }
}

/// A classification of the file. For example to identify it as generated.
public enum CodeScanningAlertClassification: String, Codable, CaseIterable {
    case source
    case generated
    case test
    case library
}

public struct CodeScanningAlertInstance: Codable {
    /// The full Git reference, formatted as `refs/heads/<branch name>`,
    /// `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
    public var ref: String?
    /// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
    public var analysisKey: String?
    /// Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
    public var environment: String?
    /// Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
    public var category: String?
    /// State of a code scanning alert.
    public var state: CodeScanningAlertState?
    public var commitSha: String?
    public var message: Message?
    /// Describe a region within a file for the alert.
    public var location: CodeScanningAlertLocation?
    public var htmlURL: String?
    /// Classifications that have been applied to the file that triggered the alert.
    /// For example identifying it as documentation, or a generated file.
    public var classifications: [CodeScanningAlertClassification]?

    public struct Message: Codable {
        public var text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.text = try values.decodeIfPresent(String.self, forKey: "text")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(text, forKey: "text")
        }
    }

    public init(ref: String? = nil, analysisKey: String? = nil, environment: String? = nil, category: String? = nil, state: CodeScanningAlertState? = nil, commitSha: String? = nil, message: Message? = nil, location: CodeScanningAlertLocation? = nil, htmlURL: String? = nil, classifications: [CodeScanningAlertClassification]? = nil) {
        self.ref = ref
        self.analysisKey = analysisKey
        self.environment = environment
        self.category = category
        self.state = state
        self.commitSha = commitSha
        self.message = message
        self.location = location
        self.htmlURL = htmlURL
        self.classifications = classifications
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ref = try values.decodeIfPresent(String.self, forKey: "ref")
        self.analysisKey = try values.decodeIfPresent(String.self, forKey: "analysis_key")
        self.environment = try values.decodeIfPresent(String.self, forKey: "environment")
        self.category = try values.decodeIfPresent(String.self, forKey: "category")
        self.state = try values.decodeIfPresent(CodeScanningAlertState.self, forKey: "state")
        self.commitSha = try values.decodeIfPresent(String.self, forKey: "commit_sha")
        self.message = try values.decodeIfPresent(Message.self, forKey: "message")
        self.location = try values.decodeIfPresent(CodeScanningAlertLocation.self, forKey: "location")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.classifications = try values.decodeIfPresent([CodeScanningAlertClassification].self, forKey: "classifications")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(ref, forKey: "ref")
        try values.encodeIfPresent(analysisKey, forKey: "analysis_key")
        try values.encodeIfPresent(environment, forKey: "environment")
        try values.encodeIfPresent(category, forKey: "category")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(commitSha, forKey: "commit_sha")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(classifications, forKey: "classifications")
    }
}

public struct CodeScanningAlertItems: Codable {
    /// The security alert number.
    public var number: Int
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var createdAt: Date
    /// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var updatedAt: Date?
    /// The REST API URL of the alert resource.
    public var url: URL
    /// The GitHub URL of the alert resource.
    public var htmlURL: URL
    /// The REST API URL for fetching the list of instances for an alert.
    public var instancesURL: URL
    /// State of a code scanning alert.
    public var state: CodeScanningAlertState
    /// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var fixedAt: Date?
    /// Simple User
    public var dismissedBy: SimpleUser?
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var dismissedAt: Date?
    /// **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
    public var dismissedReason: CodeScanningAlertDismissedReason?
    public var rule: CodeScanningAlertRuleSummary
    public var tool: CodeScanningAnalysisTool
    public var mostRecentInstance: CodeScanningAlertInstance

    public init(number: Int, createdAt: Date, updatedAt: Date? = nil, url: URL, htmlURL: URL, instancesURL: URL, state: CodeScanningAlertState, fixedAt: Date? = nil, dismissedBy: SimpleUser? = nil, dismissedAt: Date? = nil, dismissedReason: CodeScanningAlertDismissedReason? = nil, rule: CodeScanningAlertRuleSummary, tool: CodeScanningAnalysisTool, mostRecentInstance: CodeScanningAlertInstance) {
        self.number = number
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.url = url
        self.htmlURL = htmlURL
        self.instancesURL = instancesURL
        self.state = state
        self.fixedAt = fixedAt
        self.dismissedBy = dismissedBy
        self.dismissedAt = dismissedAt
        self.dismissedReason = dismissedReason
        self.rule = rule
        self.tool = tool
        self.mostRecentInstance = mostRecentInstance
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.number = try values.decode(Int.self, forKey: "number")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.instancesURL = try values.decode(URL.self, forKey: "instances_url")
        self.state = try values.decode(CodeScanningAlertState.self, forKey: "state")
        self.fixedAt = try values.decodeIfPresent(Date.self, forKey: "fixed_at")
        self.dismissedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "dismissed_by")
        self.dismissedAt = try values.decodeIfPresent(Date.self, forKey: "dismissed_at")
        self.dismissedReason = try values.decodeIfPresent(CodeScanningAlertDismissedReason.self, forKey: "dismissed_reason")
        self.rule = try values.decode(CodeScanningAlertRuleSummary.self, forKey: "rule")
        self.tool = try values.decode(CodeScanningAnalysisTool.self, forKey: "tool")
        self.mostRecentInstance = try values.decode(CodeScanningAlertInstance.self, forKey: "most_recent_instance")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(number, forKey: "number")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(instancesURL, forKey: "instances_url")
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(fixedAt, forKey: "fixed_at")
        try values.encodeIfPresent(dismissedBy, forKey: "dismissed_by")
        try values.encodeIfPresent(dismissedAt, forKey: "dismissed_at")
        try values.encodeIfPresent(dismissedReason, forKey: "dismissed_reason")
        try values.encode(rule, forKey: "rule")
        try values.encode(tool, forKey: "tool")
        try values.encode(mostRecentInstance, forKey: "most_recent_instance")
    }
}

public struct CodeScanningAlertRule: Codable {
    /// A unique identifier for the rule used to detect the alert.
    public var id: String?
    /// The name of the rule used to detect the alert.
    public var name: String?
    /// The severity of the alert.
    public var severity: Severity?
    /// The security severity of the alert.
    public var securitySeverityLevel: SecuritySeverityLevel?
    /// A short description of the rule used to detect the alert.
    public var description: String?
    /// Description of the rule used to detect the alert.
    public var fullDescription: String?
    /// A set of tags applicable for the rule.
    public var tags: [String]?
    /// Detailed documentation for the rule as GitHub Flavored Markdown.
    public var help: String?

    /// The severity of the alert.
    public enum Severity: String, Codable, CaseIterable {
        case `none`
        case note
        case warning
        case error
    }

    /// The security severity of the alert.
    public enum SecuritySeverityLevel: String, Codable, CaseIterable {
        case low
        case medium
        case high
        case critical
    }

    public init(id: String? = nil, name: String? = nil, severity: Severity? = nil, securitySeverityLevel: SecuritySeverityLevel? = nil, description: String? = nil, fullDescription: String? = nil, tags: [String]? = nil, help: String? = nil) {
        self.id = id
        self.name = name
        self.severity = severity
        self.securitySeverityLevel = securitySeverityLevel
        self.description = description
        self.fullDescription = fullDescription
        self.tags = tags
        self.help = help
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.severity = try values.decodeIfPresent(Severity.self, forKey: "severity")
        self.securitySeverityLevel = try values.decodeIfPresent(SecuritySeverityLevel.self, forKey: "security_severity_level")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.fullDescription = try values.decodeIfPresent(String.self, forKey: "full_description")
        self.tags = try values.decodeIfPresent([String].self, forKey: "tags")
        self.help = try values.decodeIfPresent(String.self, forKey: "help")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(severity, forKey: "severity")
        try values.encodeIfPresent(securitySeverityLevel, forKey: "security_severity_level")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(fullDescription, forKey: "full_description")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(help, forKey: "help")
    }
}

public struct CodeScanningAlert: Codable {
    /// The security alert number.
    public var number: Int
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var createdAt: Date
    /// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var updatedAt: Date?
    /// The REST API URL of the alert resource.
    public var url: URL
    /// The GitHub URL of the alert resource.
    public var htmlURL: URL
    /// The REST API URL for fetching the list of instances for an alert.
    public var instancesURL: URL
    /// State of a code scanning alert.
    public var state: CodeScanningAlertState
    /// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var fixedAt: Date?
    /// Simple User
    public var dismissedBy: SimpleUser?
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var dismissedAt: Date?
    /// **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
    public var dismissedReason: CodeScanningAlertDismissedReason?
    public var rule: CodeScanningAlertRule
    public var tool: CodeScanningAnalysisTool
    public var mostRecentInstance: CodeScanningAlertInstance

    public init(number: Int, createdAt: Date, updatedAt: Date? = nil, url: URL, htmlURL: URL, instancesURL: URL, state: CodeScanningAlertState, fixedAt: Date? = nil, dismissedBy: SimpleUser? = nil, dismissedAt: Date? = nil, dismissedReason: CodeScanningAlertDismissedReason? = nil, rule: CodeScanningAlertRule, tool: CodeScanningAnalysisTool, mostRecentInstance: CodeScanningAlertInstance) {
        self.number = number
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.url = url
        self.htmlURL = htmlURL
        self.instancesURL = instancesURL
        self.state = state
        self.fixedAt = fixedAt
        self.dismissedBy = dismissedBy
        self.dismissedAt = dismissedAt
        self.dismissedReason = dismissedReason
        self.rule = rule
        self.tool = tool
        self.mostRecentInstance = mostRecentInstance
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.number = try values.decode(Int.self, forKey: "number")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.instancesURL = try values.decode(URL.self, forKey: "instances_url")
        self.state = try values.decode(CodeScanningAlertState.self, forKey: "state")
        self.fixedAt = try values.decodeIfPresent(Date.self, forKey: "fixed_at")
        self.dismissedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "dismissed_by")
        self.dismissedAt = try values.decodeIfPresent(Date.self, forKey: "dismissed_at")
        self.dismissedReason = try values.decodeIfPresent(CodeScanningAlertDismissedReason.self, forKey: "dismissed_reason")
        self.rule = try values.decode(CodeScanningAlertRule.self, forKey: "rule")
        self.tool = try values.decode(CodeScanningAnalysisTool.self, forKey: "tool")
        self.mostRecentInstance = try values.decode(CodeScanningAlertInstance.self, forKey: "most_recent_instance")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(number, forKey: "number")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(instancesURL, forKey: "instances_url")
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(fixedAt, forKey: "fixed_at")
        try values.encodeIfPresent(dismissedBy, forKey: "dismissed_by")
        try values.encodeIfPresent(dismissedAt, forKey: "dismissed_at")
        try values.encodeIfPresent(dismissedReason, forKey: "dismissed_reason")
        try values.encode(rule, forKey: "rule")
        try values.encode(tool, forKey: "tool")
        try values.encode(mostRecentInstance, forKey: "most_recent_instance")
    }
}

/// Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`.
public enum CodeScanningAlertSetState: String, Codable, CaseIterable {
    case `open`
    case dismissed
}

public struct CodeScanningAnalysis: Codable {
    /// The full Git reference, formatted as `refs/heads/<branch name>`,
    /// `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
    public var ref: String
    /// The SHA of the commit to which the analysis you are uploading relates.
    public var commitSha: String
    /// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
    public var analysisKey: String
    /// Identifies the variable values associated with the environment in which this analysis was performed.
    public var environment: String
    /// Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
    public var category: String?
    /// Example: "error reading field xyz"
    public var error: String
    /// The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var createdAt: Date
    /// The total number of results in the analysis.
    public var resultsCount: Int
    /// The total number of rules used in the analysis.
    public var rulesCount: Int
    /// Unique identifier for this analysis.
    public var id: Int
    /// The REST API URL of the analysis resource.
    public var url: URL
    /// An identifier for the upload.
    ///
    /// Example: "6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53"
    public var sarifID: String
    public var tool: CodeScanningAnalysisTool
    public var isDeletable: Bool
    /// Warning generated when processing the analysis
    ///
    /// Example: "123 results were ignored"
    public var warning: String

    public init(ref: String, commitSha: String, analysisKey: String, environment: String, category: String? = nil, error: String, createdAt: Date, resultsCount: Int, rulesCount: Int, id: Int, url: URL, sarifID: String, tool: CodeScanningAnalysisTool, isDeletable: Bool, warning: String) {
        self.ref = ref
        self.commitSha = commitSha
        self.analysisKey = analysisKey
        self.environment = environment
        self.category = category
        self.error = error
        self.createdAt = createdAt
        self.resultsCount = resultsCount
        self.rulesCount = rulesCount
        self.id = id
        self.url = url
        self.sarifID = sarifID
        self.tool = tool
        self.isDeletable = isDeletable
        self.warning = warning
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ref = try values.decode(String.self, forKey: "ref")
        self.commitSha = try values.decode(String.self, forKey: "commit_sha")
        self.analysisKey = try values.decode(String.self, forKey: "analysis_key")
        self.environment = try values.decode(String.self, forKey: "environment")
        self.category = try values.decodeIfPresent(String.self, forKey: "category")
        self.error = try values.decode(String.self, forKey: "error")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.resultsCount = try values.decode(Int.self, forKey: "results_count")
        self.rulesCount = try values.decode(Int.self, forKey: "rules_count")
        self.id = try values.decode(Int.self, forKey: "id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.sarifID = try values.decode(String.self, forKey: "sarif_id")
        self.tool = try values.decode(CodeScanningAnalysisTool.self, forKey: "tool")
        self.isDeletable = try values.decode(Bool.self, forKey: "deletable")
        self.warning = try values.decode(String.self, forKey: "warning")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ref, forKey: "ref")
        try values.encode(commitSha, forKey: "commit_sha")
        try values.encode(analysisKey, forKey: "analysis_key")
        try values.encode(environment, forKey: "environment")
        try values.encodeIfPresent(category, forKey: "category")
        try values.encode(error, forKey: "error")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(resultsCount, forKey: "results_count")
        try values.encode(rulesCount, forKey: "rules_count")
        try values.encode(id, forKey: "id")
        try values.encode(url, forKey: "url")
        try values.encode(sarifID, forKey: "sarif_id")
        try values.encode(tool, forKey: "tool")
        try values.encode(isDeletable, forKey: "deletable")
        try values.encode(warning, forKey: "warning")
    }
}

/// Analysis deletion
///
/// Successful deletion of a code scanning analysis
public struct CodeScanningAnalysisDeletion: Codable {
    /// Next deletable analysis in chain, without last analysis deletion confirmation
    public var nextAnalysisURL: URL?
    /// Next deletable analysis in chain, with last analysis deletion confirmation
    public var confirmDeleteURL: URL?

    public init(nextAnalysisURL: URL? = nil, confirmDeleteURL: URL? = nil) {
        self.nextAnalysisURL = nextAnalysisURL
        self.confirmDeleteURL = confirmDeleteURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.nextAnalysisURL = try values.decodeIfPresent(URL.self, forKey: "next_analysis_url")
        self.confirmDeleteURL = try values.decodeIfPresent(URL.self, forKey: "confirm_delete_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(nextAnalysisURL, forKey: "next_analysis_url")
        try values.encodeIfPresent(confirmDeleteURL, forKey: "confirm_delete_url")
    }
}

public struct CodeScanningSarifsReceipt: Codable {
    /// An identifier for the upload.
    ///
    /// Example: "6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53"
    public var id: String?
    /// The REST API URL for checking the status of the upload.
    public var url: URL?

    public init(id: String? = nil, url: URL? = nil) {
        self.id = id
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

public struct CodeScanningSarifsStatus: Codable {
    /// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
    public var processingStatus: ProcessingStatus?
    /// The REST API URL for getting the analyses associated with the upload.
    public var analysesURL: URL?
    /// Any errors that ocurred during processing of the delivery.
    public var errors: [String]?

    /// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
    public enum ProcessingStatus: String, Codable, CaseIterable {
        case pending
        case complete
        case failed
    }

    public init(processingStatus: ProcessingStatus? = nil, analysesURL: URL? = nil, errors: [String]? = nil) {
        self.processingStatus = processingStatus
        self.analysesURL = analysesURL
        self.errors = errors
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.processingStatus = try values.decodeIfPresent(ProcessingStatus.self, forKey: "processing_status")
        self.analysesURL = try values.decodeIfPresent(URL.self, forKey: "analyses_url")
        self.errors = try values.decodeIfPresent([String].self, forKey: "errors")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(processingStatus, forKey: "processing_status")
        try values.encodeIfPresent(analysesURL, forKey: "analyses_url")
        try values.encodeIfPresent(errors, forKey: "errors")
    }
}

/// A codespace.
public struct Codespace: Codable {
    public var id: Int
    /// Automatically generated name of this codespace.
    ///
    /// Example: "monalisa-octocat-hello-world-g4wpq6h95q"
    public var name: String
    /// UUID identifying this codespace's environment.
    ///
    /// Example: "26a7c758-7299-4a73-b978-5a92a7ae98a0"
    public var environmentID: String?
    /// Simple User
    public var owner: SimpleUser
    /// Simple User
    public var billableOwner: SimpleUser
    /// Minimal Repository
    public var repository: MinimalRepository
    /// Codespace machine
    ///
    /// A description of the machine powering a codespace.
    public var machine: CodespaceMachine?
    /// Whether the codespace was created from a prebuild.
    ///
    /// Example: false
    public var isPrebuild: Bool?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var updatedAt: Date
    /// Last known time this codespace was started.
    ///
    /// Example: "2011-01-26T19:01:12Z"
    public var lastUsedAt: Date
    /// State of this codespace.
    ///
    /// Example: "Available"
    public var state: State
    /// API URL for this codespace.
    public var url: URL
    /// Details about the codespace's git repository.
    public var gitStatus: GitStatus
    /// The Azure region where this codespace is located.
    ///
    /// Example: "WestUs2"
    public var location: Location
    /// The number of minutes of inactivity after which this codespace will be automatically stopped.
    ///
    /// Example: 60
    public var idleTimeoutMinutes: Int?
    /// URL to access this codespace on the web.
    public var webURL: URL
    /// API URL to access available alternate machine types for this codespace.
    public var machinesURL: URL
    /// API URL to start this codespace.
    public var startURL: URL
    /// API URL to stop this codespace.
    public var stopURL: URL
    /// API URL for the Pull Request associated with this codespace, if any.
    public var pullsURL: URL?
    public var recentFolders: [String]
    public var runtimeConstraints: RuntimeConstraints?

    /// State of this codespace.
    ///
    /// Example: "Available"
    public enum State: String, Codable, CaseIterable {
        case `none` = "None"
        case created = "Created"
        case queued = "Queued"
        case provisioning = "Provisioning"
        case available = "Available"
        case awaiting = "Awaiting"
        case unavailable = "Unavailable"
        case deleted = "Deleted"
        case moved = "Moved"
        case shutdown = "Shutdown"
        case archived = "Archived"
        case starting = "Starting"
        case shuttingDown = "ShuttingDown"
        case failed = "Failed"
        case exporting = "Exporting"
        case updating = "Updating"
        case rebuilding = "Rebuilding"
    }

    /// Details about the codespace's git repository.
    public struct GitStatus: Codable {
        /// The number of commits the local repository is ahead of the remote.
        public var ahead: Int?
        /// The number of commits the local repository is behind the remote.
        public var behind: Int?
        /// Whether the local repository has unpushed changes.
        public var hasUnpushedChanges: Bool?
        /// Whether the local repository has uncommitted changes.
        public var hasUncommittedChanges: Bool?
        /// The current branch (or SHA if in detached HEAD state) of the local repository.
        ///
        /// Example: "main"
        public var ref: String?

        public init(ahead: Int? = nil, behind: Int? = nil, hasUnpushedChanges: Bool? = nil, hasUncommittedChanges: Bool? = nil, ref: String? = nil) {
            self.ahead = ahead
            self.behind = behind
            self.hasUnpushedChanges = hasUnpushedChanges
            self.hasUncommittedChanges = hasUncommittedChanges
            self.ref = ref
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.ahead = try values.decodeIfPresent(Int.self, forKey: "ahead")
            self.behind = try values.decodeIfPresent(Int.self, forKey: "behind")
            self.hasUnpushedChanges = try values.decodeIfPresent(Bool.self, forKey: "has_unpushed_changes")
            self.hasUncommittedChanges = try values.decodeIfPresent(Bool.self, forKey: "has_uncommitted_changes")
            self.ref = try values.decodeIfPresent(String.self, forKey: "ref")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(ahead, forKey: "ahead")
            try values.encodeIfPresent(behind, forKey: "behind")
            try values.encodeIfPresent(hasUnpushedChanges, forKey: "has_unpushed_changes")
            try values.encodeIfPresent(hasUncommittedChanges, forKey: "has_uncommitted_changes")
            try values.encodeIfPresent(ref, forKey: "ref")
        }
    }

    /// The Azure region where this codespace is located.
    ///
    /// Example: "WestUs2"
    public enum Location: String, Codable, CaseIterable {
        case eastUs = "EastUs"
        case southEastAsia = "SouthEastAsia"
        case westEurope = "WestEurope"
        case westUs2 = "WestUs2"
    }

    public struct RuntimeConstraints: Codable {
        /// The privacy settings a user can select from when forwarding a port.
        public var allowedPortPrivacySettings: [String]?

        public init(allowedPortPrivacySettings: [String]? = nil) {
            self.allowedPortPrivacySettings = allowedPortPrivacySettings
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.allowedPortPrivacySettings = try values.decodeIfPresent([String].self, forKey: "allowed_port_privacy_settings")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(allowedPortPrivacySettings, forKey: "allowed_port_privacy_settings")
        }
    }

    public init(id: Int, name: String, environmentID: String? = nil, owner: SimpleUser, billableOwner: SimpleUser, repository: MinimalRepository, machine: CodespaceMachine? = nil, isPrebuild: Bool? = nil, createdAt: Date, updatedAt: Date, lastUsedAt: Date, state: State, url: URL, gitStatus: GitStatus, location: Location, idleTimeoutMinutes: Int? = nil, webURL: URL, machinesURL: URL, startURL: URL, stopURL: URL, pullsURL: URL? = nil, recentFolders: [String], runtimeConstraints: RuntimeConstraints? = nil) {
        self.id = id
        self.name = name
        self.environmentID = environmentID
        self.owner = owner
        self.billableOwner = billableOwner
        self.repository = repository
        self.machine = machine
        self.isPrebuild = isPrebuild
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.lastUsedAt = lastUsedAt
        self.state = state
        self.url = url
        self.gitStatus = gitStatus
        self.location = location
        self.idleTimeoutMinutes = idleTimeoutMinutes
        self.webURL = webURL
        self.machinesURL = machinesURL
        self.startURL = startURL
        self.stopURL = stopURL
        self.pullsURL = pullsURL
        self.recentFolders = recentFolders
        self.runtimeConstraints = runtimeConstraints
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.environmentID = try values.decodeIfPresent(String.self, forKey: "environment_id")
        self.owner = try values.decode(SimpleUser.self, forKey: "owner")
        self.billableOwner = try values.decode(SimpleUser.self, forKey: "billable_owner")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.machine = try values.decodeIfPresent(CodespaceMachine.self, forKey: "machine")
        self.isPrebuild = try values.decodeIfPresent(Bool.self, forKey: "prebuild")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.lastUsedAt = try values.decode(Date.self, forKey: "last_used_at")
        self.state = try values.decode(State.self, forKey: "state")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitStatus = try values.decode(GitStatus.self, forKey: "git_status")
        self.location = try values.decode(Location.self, forKey: "location")
        self.idleTimeoutMinutes = try values.decodeIfPresent(Int.self, forKey: "idle_timeout_minutes")
        self.webURL = try values.decode(URL.self, forKey: "web_url")
        self.machinesURL = try values.decode(URL.self, forKey: "machines_url")
        self.startURL = try values.decode(URL.self, forKey: "start_url")
        self.stopURL = try values.decode(URL.self, forKey: "stop_url")
        self.pullsURL = try values.decodeIfPresent(URL.self, forKey: "pulls_url")
        self.recentFolders = try values.decode([String].self, forKey: "recent_folders")
        self.runtimeConstraints = try values.decodeIfPresent(RuntimeConstraints.self, forKey: "runtime_constraints")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(environmentID, forKey: "environment_id")
        try values.encode(owner, forKey: "owner")
        try values.encode(billableOwner, forKey: "billable_owner")
        try values.encode(repository, forKey: "repository")
        try values.encodeIfPresent(machine, forKey: "machine")
        try values.encodeIfPresent(isPrebuild, forKey: "prebuild")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(lastUsedAt, forKey: "last_used_at")
        try values.encode(state, forKey: "state")
        try values.encode(url, forKey: "url")
        try values.encode(gitStatus, forKey: "git_status")
        try values.encode(location, forKey: "location")
        try values.encodeIfPresent(idleTimeoutMinutes, forKey: "idle_timeout_minutes")
        try values.encode(webURL, forKey: "web_url")
        try values.encode(machinesURL, forKey: "machines_url")
        try values.encode(startURL, forKey: "start_url")
        try values.encode(stopURL, forKey: "stop_url")
        try values.encodeIfPresent(pullsURL, forKey: "pulls_url")
        try values.encode(recentFolders, forKey: "recent_folders")
        try values.encodeIfPresent(runtimeConstraints, forKey: "runtime_constraints")
    }
}

/// A description of the machine powering a codespace.
public struct CodespaceMachine: Codable {
    /// The name of the machine.
    ///
    /// Example: "standardLinux"
    public var name: String
    /// The display name of the machine includes cores, memory, and storage.
    ///
    /// Example: "4 cores, 8 GB RAM, 64 GB storage"
    public var displayName: String
    /// The operating system of the machine.
    ///
    /// Example: "linux"
    public var operatingSystem: String
    /// How much storage is available to the codespace.
    ///
    /// Example: 68719476736
    public var storageInBytes: Int
    /// How much memory is available to the codespace.
    ///
    /// Example: 8589934592
    public var memoryInBytes: Int
    /// How many cores are available to the codespace.
    public var cpus: Int
    /// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value is the type of prebuild available, or "none" if none are available.
    ///
    /// Example: "blob"
    public var prebuildAvailability: PrebuildAvailability?

    /// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be "null" if prebuilds are not supported or prebuild availability could not be determined. Value is the type of prebuild available, or "none" if none are available.
    ///
    /// Example: "blob"
    public enum PrebuildAvailability: String, Codable, CaseIterable {
        case `none`
        case blob
        case pool
    }

    public init(name: String, displayName: String, operatingSystem: String, storageInBytes: Int, memoryInBytes: Int, cpus: Int, prebuildAvailability: PrebuildAvailability? = nil) {
        self.name = name
        self.displayName = displayName
        self.operatingSystem = operatingSystem
        self.storageInBytes = storageInBytes
        self.memoryInBytes = memoryInBytes
        self.cpus = cpus
        self.prebuildAvailability = prebuildAvailability
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.operatingSystem = try values.decode(String.self, forKey: "operating_system")
        self.storageInBytes = try values.decode(Int.self, forKey: "storage_in_bytes")
        self.memoryInBytes = try values.decode(Int.self, forKey: "memory_in_bytes")
        self.cpus = try values.decode(Int.self, forKey: "cpus")
        self.prebuildAvailability = try values.decodeIfPresent(PrebuildAvailability.self, forKey: "prebuild_availability")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(displayName, forKey: "display_name")
        try values.encode(operatingSystem, forKey: "operating_system")
        try values.encode(storageInBytes, forKey: "storage_in_bytes")
        try values.encode(memoryInBytes, forKey: "memory_in_bytes")
        try values.encode(cpus, forKey: "cpus")
        try values.encodeIfPresent(prebuildAvailability, forKey: "prebuild_availability")
    }
}

public struct Collaborator: Codable {
    /// Example: "octocat"
    public var login: String
    public var id: Int
    public var email: String?
    public var name: String?
    /// Example: "MDQ6VXNlcjE="
    public var nodeID: String
    /// Example: "https://github.com/images/error/octocat_happy.gif"
    public var avatarURL: URL
    /// Example: "41d064eb2195891e12d0413f63227ea7"
    public var gravatarID: String?
    /// Example: "https://api.github.com/users/octocat"
    public var url: URL
    /// Example: "https://github.com/octocat"
    public var htmlURL: URL
    /// Example: "https://api.github.com/users/octocat/followers"
    public var followersURL: URL
    /// Example: "https://api.github.com/users/octocat/following{/other_user}"
    public var followingURL: String
    /// Example: "https://api.github.com/users/octocat/gists{/gist_id}"
    public var gistsURL: String
    /// Example: "https://api.github.com/users/octocat/starred{/owner}{/repo}"
    public var starredURL: String
    /// Example: "https://api.github.com/users/octocat/subscriptions"
    public var subscriptionsURL: URL
    /// Example: "https://api.github.com/users/octocat/orgs"
    public var organizationsURL: URL
    /// Example: "https://api.github.com/users/octocat/repos"
    public var reposURL: URL
    /// Example: "https://api.github.com/users/octocat/events{/privacy}"
    public var eventsURL: String
    /// Example: "https://api.github.com/users/octocat/received_events"
    public var receivedEventsURL: URL
    /// Example: "User"
    public var type: String
    public var isSiteAdmin: Bool
    public var permissions: Permissions?
    /// Example: "admin"
    public var roleName: String

    public struct Permissions: Codable {
        public var isPull: Bool
        public var isTriage: Bool?
        public var isPush: Bool
        public var isMaintain: Bool?
        public var isAdmin: Bool

        public init(isPull: Bool, isTriage: Bool? = nil, isPush: Bool, isMaintain: Bool? = nil, isAdmin: Bool) {
            self.isPull = isPull
            self.isTriage = isTriage
            self.isPush = isPush
            self.isMaintain = isMaintain
            self.isAdmin = isAdmin
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isPull = try values.decode(Bool.self, forKey: "pull")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isPull, forKey: "pull")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encode(isPush, forKey: "push")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
            try values.encode(isAdmin, forKey: "admin")
        }
    }

    public init(login: String, id: Int, email: String? = nil, name: String? = nil, nodeID: String, avatarURL: URL, gravatarID: String? = nil, url: URL, htmlURL: URL, followersURL: URL, followingURL: String, gistsURL: String, starredURL: String, subscriptionsURL: URL, organizationsURL: URL, reposURL: URL, eventsURL: String, receivedEventsURL: URL, type: String, isSiteAdmin: Bool, permissions: Permissions? = nil, roleName: String) {
        self.login = login
        self.id = id
        self.email = email
        self.name = name
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.isSiteAdmin = isSiteAdmin
        self.permissions = permissions
        self.roleName = roleName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.followersURL = try values.decode(URL.self, forKey: "followers_url")
        self.followingURL = try values.decode(String.self, forKey: "following_url")
        self.gistsURL = try values.decode(String.self, forKey: "gists_url")
        self.starredURL = try values.decode(String.self, forKey: "starred_url")
        self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(String.self, forKey: "events_url")
        self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.roleName = try values.decode(String.self, forKey: "role_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(followersURL, forKey: "followers_url")
        try values.encode(followingURL, forKey: "following_url")
        try values.encode(gistsURL, forKey: "gists_url")
        try values.encode(starredURL, forKey: "starred_url")
        try values.encode(subscriptionsURL, forKey: "subscriptions_url")
        try values.encode(organizationsURL, forKey: "organizations_url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encode(isSiteAdmin, forKey: "site_admin")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encode(roleName, forKey: "role_name")
    }
}

/// Repository invitations let you manage who you collaborate with.
public struct RepositoryInvitation: Codable {
    /// Unique identifier of the repository invitation.
    ///
    /// Example: 42
    public var id: Int
    /// Minimal Repository
    public var repository: MinimalRepository
    /// Simple User
    public var invitee: SimpleUser?
    /// Simple User
    public var inviter: SimpleUser?
    /// The permission associated with the invitation.
    ///
    /// Example: "read"
    public var permissions: Permissions
    /// Example: "2016-06-13T14:52:50-05:00"
    public var createdAt: Date
    /// Whether or not the invitation has expired
    public var isExpired: Bool?
    /// URL for the repository invitation
    ///
    /// Example: "https://api.github.com/user/repository-invitations/1"
    public var url: String
    /// Example: "https://github.com/octocat/Hello-World/invitations"
    public var htmlURL: String
    public var nodeID: String

    /// The permission associated with the invitation.
    ///
    /// Example: "read"
    public enum Permissions: String, Codable, CaseIterable {
        case read
        case write
        case admin
        case triage
        case maintain
    }

    public init(id: Int, repository: MinimalRepository, invitee: SimpleUser? = nil, inviter: SimpleUser? = nil, permissions: Permissions, createdAt: Date, isExpired: Bool? = nil, url: String, htmlURL: String, nodeID: String) {
        self.id = id
        self.repository = repository
        self.invitee = invitee
        self.inviter = inviter
        self.permissions = permissions
        self.createdAt = createdAt
        self.isExpired = isExpired
        self.url = url
        self.htmlURL = htmlURL
        self.nodeID = nodeID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.invitee = try values.decodeIfPresent(SimpleUser.self, forKey: "invitee")
        self.inviter = try values.decodeIfPresent(SimpleUser.self, forKey: "inviter")
        self.permissions = try values.decode(Permissions.self, forKey: "permissions")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.isExpired = try values.decodeIfPresent(Bool.self, forKey: "expired")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(repository, forKey: "repository")
        try values.encodeIfPresent(invitee, forKey: "invitee")
        try values.encodeIfPresent(inviter, forKey: "inviter")
        try values.encode(permissions, forKey: "permissions")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(isExpired, forKey: "expired")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(nodeID, forKey: "node_id")
    }
}

public struct RepositoryCollaboratorPermission: Codable {
    public var permission: String
    /// Example: "admin"
    public var roleName: String
    /// Collaborator
    public var user: Collaborator?

    public init(permission: String, roleName: String, user: Collaborator? = nil) {
        self.permission = permission
        self.roleName = roleName
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.permission = try values.decode(String.self, forKey: "permission")
        self.roleName = try values.decode(String.self, forKey: "role_name")
        self.user = try values.decodeIfPresent(Collaborator.self, forKey: "user")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(permission, forKey: "permission")
        try values.encode(roleName, forKey: "role_name")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct CommitComment: Codable {
    public var htmlURL: URL
    public var url: URL
    public var id: Int
    public var nodeID: String
    public var body: String
    public var path: String?
    public var position: Int?
    public var line: Int?
    public var commitID: String
    /// Simple User
    public var user: SimpleUser?
    public var createdAt: Date
    public var updatedAt: Date
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(htmlURL: URL, url: URL, id: Int, nodeID: String, body: String, path: String? = nil, position: Int? = nil, line: Int? = nil, commitID: String, user: SimpleUser? = nil, createdAt: Date, updatedAt: Date, authorAssociation: AuthorAssociation, reactions: ReactionRollup? = nil) {
        self.htmlURL = htmlURL
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.body = body
        self.path = path
        self.position = position
        self.line = line
        self.commitID = commitID
        self.user = user
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.authorAssociation = authorAssociation
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.body = try values.decode(String.self, forKey: "body")
        self.path = try values.decodeIfPresent(String.self, forKey: "path")
        self.position = try values.decodeIfPresent(Int.self, forKey: "position")
        self.line = try values.decodeIfPresent(Int.self, forKey: "line")
        self.commitID = try values.decode(String.self, forKey: "commit_id")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(body, forKey: "body")
        try values.encodeIfPresent(path, forKey: "path")
        try values.encodeIfPresent(position, forKey: "position")
        try values.encodeIfPresent(line, forKey: "line")
        try values.encode(commitID, forKey: "commit_id")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

public struct BranchShort: Codable {
    public var name: String
    public var commit: Commit
    public var isProtected: Bool

    public struct Commit: Codable {
        public var sha: String
        public var url: String

        public init(sha: String, url: String) {
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public init(name: String, commit: Commit, isProtected: Bool) {
        self.name = name
        self.commit = commit
        self.isProtected = isProtected
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.isProtected = try values.decode(Bool.self, forKey: "protected")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(commit, forKey: "commit")
        try values.encode(isProtected, forKey: "protected")
    }
}

/// Hypermedia Link
public struct Link: Codable {
    public var href: String

    public init(href: String) {
        self.href = href
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.href = try values.decode(String.self, forKey: "href")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(href, forKey: "href")
    }
}

/// The status of auto merging a pull request.
public struct AutoMerge: Codable {
    /// Simple User
    public var enabledBy: SimpleUser
    /// The merge method to use.
    public var mergeMethod: MergeMethod
    /// Title for the merge commit message.
    public var commitTitle: String
    /// Commit message for the merge commit.
    public var commitMessage: String

    /// The merge method to use.
    public enum MergeMethod: String, Codable, CaseIterable {
        case merge
        case squash
        case rebase
    }

    public init(enabledBy: SimpleUser, mergeMethod: MergeMethod, commitTitle: String, commitMessage: String) {
        self.enabledBy = enabledBy
        self.mergeMethod = mergeMethod
        self.commitTitle = commitTitle
        self.commitMessage = commitMessage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.enabledBy = try values.decode(SimpleUser.self, forKey: "enabled_by")
        self.mergeMethod = try values.decode(MergeMethod.self, forKey: "merge_method")
        self.commitTitle = try values.decode(String.self, forKey: "commit_title")
        self.commitMessage = try values.decode(String.self, forKey: "commit_message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(enabledBy, forKey: "enabled_by")
        try values.encode(mergeMethod, forKey: "merge_method")
        try values.encode(commitTitle, forKey: "commit_title")
        try values.encode(commitMessage, forKey: "commit_message")
    }
}

public struct PullRequestSimple: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347"
    public var url: URL
    public var id: Int
    /// Example: "MDExOlB1bGxSZXF1ZXN0MQ=="
    public var nodeID: String
    /// Example: "https://github.com/octocat/Hello-World/pull/1347"
    public var htmlURL: URL
    /// Example: "https://github.com/octocat/Hello-World/pull/1347.diff"
    public var diffURL: URL
    /// Example: "https://github.com/octocat/Hello-World/pull/1347.patch"
    public var patchURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/issues/1347"
    public var issueURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits"
    public var commitsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments"
    public var reviewCommentsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}"
    public var reviewCommentURL: String
    /// Example: "https://api.github.com/repos/octocat/Hello-World/issues/1347/comments"
    public var commentsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var statusesURL: URL
    /// Example: 1347
    public var number: Int
    /// Example: "open"
    public var state: String
    /// Example: true
    public var isLocked: Bool
    /// Example: "new-feature"
    public var title: String
    /// Simple User
    public var user: SimpleUser?
    /// Example: "Please pull these awesome changes"
    public var body: String?
    public var labels: [Label]
    /// A collection of related issues and pull requests.
    public var milestone: Milestone?
    /// Example: "too heated"
    public var activeLockReason: String?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var updatedAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var closedAt: Date?
    /// Example: "2011-01-26T19:01:12Z"
    public var mergedAt: Date?
    /// Example: "e5bd3914e2e596debea16f433f57875b5b90bcd6"
    public var mergeCommitSha: String?
    /// Simple User
    public var assignee: SimpleUser?
    public var assignees: [SimpleUser]?
    public var requestedReviewers: [SimpleUser]?
    public var requestedTeams: [Team]?
    public var head: Head
    public var base: Base
    public var links: Links
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// The status of auto merging a pull request.
    public var autoMerge: AutoMerge?
    /// Indicates whether or not the pull request is a draft.
    ///
    /// Example: false
    public var isDraft: Bool?

    public struct Label: Codable {
        public var id: Int
        public var nodeID: String
        public var url: String
        public var name: String
        public var description: String
        public var color: String
        public var isDefault: Bool

        public init(id: Int, nodeID: String, url: String, name: String, description: String, color: String, isDefault: Bool) {
            self.id = id
            self.nodeID = nodeID
            self.url = url
            self.name = name
            self.description = description
            self.color = color
            self.isDefault = isDefault
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.nodeID = try values.decode(String.self, forKey: "node_id")
            self.url = try values.decode(String.self, forKey: "url")
            self.name = try values.decode(String.self, forKey: "name")
            self.description = try values.decode(String.self, forKey: "description")
            self.color = try values.decode(String.self, forKey: "color")
            self.isDefault = try values.decode(Bool.self, forKey: "default")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(nodeID, forKey: "node_id")
            try values.encode(url, forKey: "url")
            try values.encode(name, forKey: "name")
            try values.encode(description, forKey: "description")
            try values.encode(color, forKey: "color")
            try values.encode(isDefault, forKey: "default")
        }
    }

    public struct Head: Codable {
        public var label: String
        public var ref: String
        /// Repository
        ///
        /// A git repository
        public var repo: Repository
        public var sha: String
        /// Simple User
        public var user: SimpleUser?

        public init(label: String, ref: String, repo: Repository, sha: String, user: SimpleUser? = nil) {
            self.label = label
            self.ref = ref
            self.repo = repo
            self.sha = sha
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.label = try values.decode(String.self, forKey: "label")
            self.ref = try values.decode(String.self, forKey: "ref")
            self.repo = try values.decode(Repository.self, forKey: "repo")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(label, forKey: "label")
            try values.encode(ref, forKey: "ref")
            try values.encode(repo, forKey: "repo")
            try values.encode(sha, forKey: "sha")
            try values.encodeIfPresent(user, forKey: "user")
        }
    }

    public struct Base: Codable {
        public var label: String
        public var ref: String
        /// Repository
        ///
        /// A git repository
        public var repo: Repository
        public var sha: String
        /// Simple User
        public var user: SimpleUser?

        public init(label: String, ref: String, repo: Repository, sha: String, user: SimpleUser? = nil) {
            self.label = label
            self.ref = ref
            self.repo = repo
            self.sha = sha
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.label = try values.decode(String.self, forKey: "label")
            self.ref = try values.decode(String.self, forKey: "ref")
            self.repo = try values.decode(Repository.self, forKey: "repo")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(label, forKey: "label")
            try values.encode(ref, forKey: "ref")
            try values.encode(repo, forKey: "repo")
            try values.encode(sha, forKey: "sha")
            try values.encodeIfPresent(user, forKey: "user")
        }
    }

    public struct Links: Codable {
        /// Link
        ///
        /// Hypermedia Link
        public var comments: Link
        /// Link
        ///
        /// Hypermedia Link
        public var commits: Link
        /// Link
        ///
        /// Hypermedia Link
        public var statuses: Link
        /// Link
        ///
        /// Hypermedia Link
        public var html: Link
        /// Link
        ///
        /// Hypermedia Link
        public var issue: Link
        /// Link
        ///
        /// Hypermedia Link
        public var reviewComments: Link
        /// Link
        ///
        /// Hypermedia Link
        public var reviewComment: Link
        /// Link
        ///
        /// Hypermedia Link
        public var this: Link

        public init(comments: Link, commits: Link, statuses: Link, html: Link, issue: Link, reviewComments: Link, reviewComment: Link, this: Link) {
            self.comments = comments
            self.commits = commits
            self.statuses = statuses
            self.html = html
            self.issue = issue
            self.reviewComments = reviewComments
            self.reviewComment = reviewComment
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.comments = try values.decode(Link.self, forKey: "comments")
            self.commits = try values.decode(Link.self, forKey: "commits")
            self.statuses = try values.decode(Link.self, forKey: "statuses")
            self.html = try values.decode(Link.self, forKey: "html")
            self.issue = try values.decode(Link.self, forKey: "issue")
            self.reviewComments = try values.decode(Link.self, forKey: "review_comments")
            self.reviewComment = try values.decode(Link.self, forKey: "review_comment")
            self.this = try values.decode(Link.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(comments, forKey: "comments")
            try values.encode(commits, forKey: "commits")
            try values.encode(statuses, forKey: "statuses")
            try values.encode(html, forKey: "html")
            try values.encode(issue, forKey: "issue")
            try values.encode(reviewComments, forKey: "review_comments")
            try values.encode(reviewComment, forKey: "review_comment")
            try values.encode(this, forKey: "self")
        }
    }

    public init(url: URL, id: Int, nodeID: String, htmlURL: URL, diffURL: URL, patchURL: URL, issueURL: URL, commitsURL: URL, reviewCommentsURL: URL, reviewCommentURL: String, commentsURL: URL, statusesURL: URL, number: Int, state: String, isLocked: Bool, title: String, user: SimpleUser? = nil, body: String? = nil, labels: [Label], milestone: Milestone? = nil, activeLockReason: String? = nil, createdAt: Date, updatedAt: Date, closedAt: Date? = nil, mergedAt: Date? = nil, mergeCommitSha: String? = nil, assignee: SimpleUser? = nil, assignees: [SimpleUser]? = nil, requestedReviewers: [SimpleUser]? = nil, requestedTeams: [Team]? = nil, head: Head, base: Base, links: Links, authorAssociation: AuthorAssociation, autoMerge: AutoMerge? = nil, isDraft: Bool? = nil) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.htmlURL = htmlURL
        self.diffURL = diffURL
        self.patchURL = patchURL
        self.issueURL = issueURL
        self.commitsURL = commitsURL
        self.reviewCommentsURL = reviewCommentsURL
        self.reviewCommentURL = reviewCommentURL
        self.commentsURL = commentsURL
        self.statusesURL = statusesURL
        self.number = number
        self.state = state
        self.isLocked = isLocked
        self.title = title
        self.user = user
        self.body = body
        self.labels = labels
        self.milestone = milestone
        self.activeLockReason = activeLockReason
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.closedAt = closedAt
        self.mergedAt = mergedAt
        self.mergeCommitSha = mergeCommitSha
        self.assignee = assignee
        self.assignees = assignees
        self.requestedReviewers = requestedReviewers
        self.requestedTeams = requestedTeams
        self.head = head
        self.base = base
        self.links = links
        self.authorAssociation = authorAssociation
        self.autoMerge = autoMerge
        self.isDraft = isDraft
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.diffURL = try values.decode(URL.self, forKey: "diff_url")
        self.patchURL = try values.decode(URL.self, forKey: "patch_url")
        self.issueURL = try values.decode(URL.self, forKey: "issue_url")
        self.commitsURL = try values.decode(URL.self, forKey: "commits_url")
        self.reviewCommentsURL = try values.decode(URL.self, forKey: "review_comments_url")
        self.reviewCommentURL = try values.decode(String.self, forKey: "review_comment_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.statusesURL = try values.decode(URL.self, forKey: "statuses_url")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(String.self, forKey: "state")
        self.isLocked = try values.decode(Bool.self, forKey: "locked")
        self.title = try values.decode(String.self, forKey: "title")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.labels = try values.decode([Label].self, forKey: "labels")
        self.milestone = try values.decodeIfPresent(Milestone.self, forKey: "milestone")
        self.activeLockReason = try values.decodeIfPresent(String.self, forKey: "active_lock_reason")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.closedAt = try values.decodeIfPresent(Date.self, forKey: "closed_at")
        self.mergedAt = try values.decodeIfPresent(Date.self, forKey: "merged_at")
        self.mergeCommitSha = try values.decodeIfPresent(String.self, forKey: "merge_commit_sha")
        self.assignee = try values.decodeIfPresent(SimpleUser.self, forKey: "assignee")
        self.assignees = try values.decodeIfPresent([SimpleUser].self, forKey: "assignees")
        self.requestedReviewers = try values.decodeIfPresent([SimpleUser].self, forKey: "requested_reviewers")
        self.requestedTeams = try values.decodeIfPresent([Team].self, forKey: "requested_teams")
        self.head = try values.decode(Head.self, forKey: "head")
        self.base = try values.decode(Base.self, forKey: "base")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.autoMerge = try values.decodeIfPresent(AutoMerge.self, forKey: "auto_merge")
        self.isDraft = try values.decodeIfPresent(Bool.self, forKey: "draft")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(diffURL, forKey: "diff_url")
        try values.encode(patchURL, forKey: "patch_url")
        try values.encode(issueURL, forKey: "issue_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(reviewCommentsURL, forKey: "review_comments_url")
        try values.encode(reviewCommentURL, forKey: "review_comment_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encode(isLocked, forKey: "locked")
        try values.encode(title, forKey: "title")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(labels, forKey: "labels")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encodeIfPresent(activeLockReason, forKey: "active_lock_reason")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(closedAt, forKey: "closed_at")
        try values.encodeIfPresent(mergedAt, forKey: "merged_at")
        try values.encodeIfPresent(mergeCommitSha, forKey: "merge_commit_sha")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(assignees, forKey: "assignees")
        try values.encodeIfPresent(requestedReviewers, forKey: "requested_reviewers")
        try values.encodeIfPresent(requestedTeams, forKey: "requested_teams")
        try values.encode(head, forKey: "head")
        try values.encode(base, forKey: "base")
        try values.encode(links, forKey: "_links")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(autoMerge, forKey: "auto_merge")
        try values.encodeIfPresent(isDraft, forKey: "draft")
    }
}

public struct SimpleCommitStatus: Codable {
    public var description: String?
    public var id: Int
    public var nodeID: String
    public var state: String
    public var context: String
    public var targetURL: URL
    public var isRequired: Bool?
    public var avatarURL: URL?
    public var url: URL
    public var createdAt: Date
    public var updatedAt: Date

    public init(description: String? = nil, id: Int, nodeID: String, state: String, context: String, targetURL: URL, isRequired: Bool? = nil, avatarURL: URL? = nil, url: URL, createdAt: Date, updatedAt: Date) {
        self.description = description
        self.id = id
        self.nodeID = nodeID
        self.state = state
        self.context = context
        self.targetURL = targetURL
        self.isRequired = isRequired
        self.avatarURL = avatarURL
        self.url = url
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.state = try values.decode(String.self, forKey: "state")
        self.context = try values.decode(String.self, forKey: "context")
        self.targetURL = try values.decode(URL.self, forKey: "target_url")
        self.isRequired = try values.decodeIfPresent(Bool.self, forKey: "required")
        self.avatarURL = try values.decodeIfPresent(URL.self, forKey: "avatar_url")
        self.url = try values.decode(URL.self, forKey: "url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(state, forKey: "state")
        try values.encode(context, forKey: "context")
        try values.encode(targetURL, forKey: "target_url")
        try values.encodeIfPresent(isRequired, forKey: "required")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encode(url, forKey: "url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

public struct CombinedCommitStatus: Codable {
    public var state: String
    public var statuses: [SimpleCommitStatus]
    public var sha: String
    public var totalCount: Int
    /// Minimal Repository
    public var repository: MinimalRepository
    public var commitURL: URL
    public var url: URL

    public init(state: String, statuses: [SimpleCommitStatus], sha: String, totalCount: Int, repository: MinimalRepository, commitURL: URL, url: URL) {
        self.state = state
        self.statuses = statuses
        self.sha = sha
        self.totalCount = totalCount
        self.repository = repository
        self.commitURL = commitURL
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.state = try values.decode(String.self, forKey: "state")
        self.statuses = try values.decode([SimpleCommitStatus].self, forKey: "statuses")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.totalCount = try values.decode(Int.self, forKey: "total_count")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.commitURL = try values.decode(URL.self, forKey: "commit_url")
        self.url = try values.decode(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(state, forKey: "state")
        try values.encode(statuses, forKey: "statuses")
        try values.encode(sha, forKey: "sha")
        try values.encode(totalCount, forKey: "total_count")
        try values.encode(repository, forKey: "repository")
        try values.encode(commitURL, forKey: "commit_url")
        try values.encode(url, forKey: "url")
    }
}

/// The status of a commit.
public struct Status: Codable {
    public var url: String
    public var avatarURL: String?
    public var id: Int
    public var nodeID: String
    public var state: String
    public var description: String
    public var targetURL: String
    public var context: String
    public var createdAt: String
    public var updatedAt: String
    /// Simple User
    public var creator: SimpleUser?

    public init(url: String, avatarURL: String? = nil, id: Int, nodeID: String, state: String, description: String, targetURL: String, context: String, createdAt: String, updatedAt: String, creator: SimpleUser? = nil) {
        self.url = url
        self.avatarURL = avatarURL
        self.id = id
        self.nodeID = nodeID
        self.state = state
        self.description = description
        self.targetURL = targetURL
        self.context = context
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.creator = creator
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(String.self, forKey: "url")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.state = try values.decode(String.self, forKey: "state")
        self.description = try values.decode(String.self, forKey: "description")
        self.targetURL = try values.decode(String.self, forKey: "target_url")
        self.context = try values.decode(String.self, forKey: "context")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(state, forKey: "state")
        try values.encode(description, forKey: "description")
        try values.encode(targetURL, forKey: "target_url")
        try values.encode(context, forKey: "context")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(creator, forKey: "creator")
    }
}

public struct CommunityHealthFile: Codable {
    public var url: URL
    public var htmlURL: URL

    public init(url: URL, htmlURL: URL) {
        self.url = url
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
    }
}

public struct CommunityProfile: Codable {
    /// Example: 100
    public var healthPercentage: Int
    /// Example: "My first repository on GitHub!"
    public var description: String?
    /// Example: "example.com"
    public var documentation: String?
    public var files: Files
    /// Example: "2017-02-28T19:09:29Z"
    public var updatedAt: Date?
    /// Example: true
    public var isContentReportsEnabled: Bool?

    public struct Files: Codable {
        /// Code Of Conduct Simple
        ///
        /// Code of Conduct Simple
        public var codeOfConduct: CodeOfConductSimple?
        /// Community Health File
        public var codeOfConductFile: CommunityHealthFile?
        /// License Simple
        public var license: LicenseSimple?
        /// Community Health File
        public var contributing: CommunityHealthFile?
        /// Community Health File
        public var readme: CommunityHealthFile?
        /// Community Health File
        public var issueTemplate: CommunityHealthFile?
        /// Community Health File
        public var pullRequestTemplate: CommunityHealthFile?

        public init(codeOfConduct: CodeOfConductSimple? = nil, codeOfConductFile: CommunityHealthFile? = nil, license: LicenseSimple? = nil, contributing: CommunityHealthFile? = nil, readme: CommunityHealthFile? = nil, issueTemplate: CommunityHealthFile? = nil, pullRequestTemplate: CommunityHealthFile? = nil) {
            self.codeOfConduct = codeOfConduct
            self.codeOfConductFile = codeOfConductFile
            self.license = license
            self.contributing = contributing
            self.readme = readme
            self.issueTemplate = issueTemplate
            self.pullRequestTemplate = pullRequestTemplate
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.codeOfConduct = try values.decodeIfPresent(CodeOfConductSimple.self, forKey: "code_of_conduct")
            self.codeOfConductFile = try values.decodeIfPresent(CommunityHealthFile.self, forKey: "code_of_conduct_file")
            self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
            self.contributing = try values.decodeIfPresent(CommunityHealthFile.self, forKey: "contributing")
            self.readme = try values.decodeIfPresent(CommunityHealthFile.self, forKey: "readme")
            self.issueTemplate = try values.decodeIfPresent(CommunityHealthFile.self, forKey: "issue_template")
            self.pullRequestTemplate = try values.decodeIfPresent(CommunityHealthFile.self, forKey: "pull_request_template")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(codeOfConduct, forKey: "code_of_conduct")
            try values.encodeIfPresent(codeOfConductFile, forKey: "code_of_conduct_file")
            try values.encodeIfPresent(license, forKey: "license")
            try values.encodeIfPresent(contributing, forKey: "contributing")
            try values.encodeIfPresent(readme, forKey: "readme")
            try values.encodeIfPresent(issueTemplate, forKey: "issue_template")
            try values.encodeIfPresent(pullRequestTemplate, forKey: "pull_request_template")
        }
    }

    public init(healthPercentage: Int, description: String? = nil, documentation: String? = nil, files: Files, updatedAt: Date? = nil, isContentReportsEnabled: Bool? = nil) {
        self.healthPercentage = healthPercentage
        self.description = description
        self.documentation = documentation
        self.files = files
        self.updatedAt = updatedAt
        self.isContentReportsEnabled = isContentReportsEnabled
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.healthPercentage = try values.decode(Int.self, forKey: "health_percentage")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.documentation = try values.decodeIfPresent(String.self, forKey: "documentation")
        self.files = try values.decode(Files.self, forKey: "files")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.isContentReportsEnabled = try values.decodeIfPresent(Bool.self, forKey: "content_reports_enabled")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(healthPercentage, forKey: "health_percentage")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(documentation, forKey: "documentation")
        try values.encode(files, forKey: "files")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(isContentReportsEnabled, forKey: "content_reports_enabled")
    }
}

public struct CommitComparison: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/compare/master...topic"
    public var url: URL
    /// Example: "https://github.com/octocat/Hello-World/compare/master...topic"
    public var htmlURL: URL
    /// Example: "https://github.com/octocat/Hello-World/compare/octocat:bbcd538c8e72b8c175046e27cc8f907076331401...octocat:0328041d1152db8ae77652d1618a02e57f745f17"
    public var permalinkURL: URL
    /// Example: "https://github.com/octocat/Hello-World/compare/master...topic.diff"
    public var diffURL: URL
    /// Example: "https://github.com/octocat/Hello-World/compare/master...topic.patch"
    public var patchURL: URL
    /// Commit
    public var baseCommit: Commit
    /// Commit
    public var mergeBaseCommit: Commit
    /// Example: "ahead"
    public var status: Status
    public var aheadBy: Int
    public var behindBy: Int
    public var totalCommits: Int
    public var commits: [Commit]
    public var files: [DiffEntry]?

    /// Example: "ahead"
    public enum Status: String, Codable, CaseIterable {
        case diverged
        case ahead
        case behind
        case identical
    }

    public init(url: URL, htmlURL: URL, permalinkURL: URL, diffURL: URL, patchURL: URL, baseCommit: Commit, mergeBaseCommit: Commit, status: Status, aheadBy: Int, behindBy: Int, totalCommits: Int, commits: [Commit], files: [DiffEntry]? = nil) {
        self.url = url
        self.htmlURL = htmlURL
        self.permalinkURL = permalinkURL
        self.diffURL = diffURL
        self.patchURL = patchURL
        self.baseCommit = baseCommit
        self.mergeBaseCommit = mergeBaseCommit
        self.status = status
        self.aheadBy = aheadBy
        self.behindBy = behindBy
        self.totalCommits = totalCommits
        self.commits = commits
        self.files = files
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.permalinkURL = try values.decode(URL.self, forKey: "permalink_url")
        self.diffURL = try values.decode(URL.self, forKey: "diff_url")
        self.patchURL = try values.decode(URL.self, forKey: "patch_url")
        self.baseCommit = try values.decode(Commit.self, forKey: "base_commit")
        self.mergeBaseCommit = try values.decode(Commit.self, forKey: "merge_base_commit")
        self.status = try values.decode(Status.self, forKey: "status")
        self.aheadBy = try values.decode(Int.self, forKey: "ahead_by")
        self.behindBy = try values.decode(Int.self, forKey: "behind_by")
        self.totalCommits = try values.decode(Int.self, forKey: "total_commits")
        self.commits = try values.decode([Commit].self, forKey: "commits")
        self.files = try values.decodeIfPresent([DiffEntry].self, forKey: "files")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(permalinkURL, forKey: "permalink_url")
        try values.encode(diffURL, forKey: "diff_url")
        try values.encode(patchURL, forKey: "patch_url")
        try values.encode(baseCommit, forKey: "base_commit")
        try values.encode(mergeBaseCommit, forKey: "merge_base_commit")
        try values.encode(status, forKey: "status")
        try values.encode(aheadBy, forKey: "ahead_by")
        try values.encode(behindBy, forKey: "behind_by")
        try values.encode(totalCommits, forKey: "total_commits")
        try values.encode(commits, forKey: "commits")
        try values.encodeIfPresent(files, forKey: "files")
    }
}

public struct ContentTree: Codable {
    public var type: String
    public var size: Int
    public var name: String
    public var path: String
    public var sha: String
    public var url: URL
    public var gitURL: URL?
    public var htmlURL: URL?
    public var downloadURL: URL?
    public var entries: [Entry]?
    public var links: Links
    public var content: AnyJSON
    public var encoding: AnyJSON

    public struct Entry: Codable {
        public var type: String
        public var size: Int
        public var name: String
        public var path: String
        public var content: String?
        public var sha: String
        public var url: URL
        public var gitURL: URL?
        public var htmlURL: URL?
        public var downloadURL: URL?
        public var links: Links

        public struct Links: Codable {
            public var git: URL?
            public var html: URL?
            public var this: URL

            public init(git: URL? = nil, html: URL? = nil, this: URL) {
                self.git = git
                self.html = html
                self.this = this
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.git = try values.decodeIfPresent(URL.self, forKey: "git")
                self.html = try values.decodeIfPresent(URL.self, forKey: "html")
                self.this = try values.decode(URL.self, forKey: "self")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(git, forKey: "git")
                try values.encodeIfPresent(html, forKey: "html")
                try values.encode(this, forKey: "self")
            }
        }

        public init(type: String, size: Int, name: String, path: String, content: String? = nil, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, links: Links) {
            self.type = type
            self.size = size
            self.name = name
            self.path = path
            self.content = content
            self.sha = sha
            self.url = url
            self.gitURL = gitURL
            self.htmlURL = htmlURL
            self.downloadURL = downloadURL
            self.links = links
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decode(String.self, forKey: "type")
            self.size = try values.decode(Int.self, forKey: "size")
            self.name = try values.decode(String.self, forKey: "name")
            self.path = try values.decode(String.self, forKey: "path")
            self.content = try values.decodeIfPresent(String.self, forKey: "content")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
            self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
            self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
            self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
            self.links = try values.decode(Links.self, forKey: "_links")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(type, forKey: "type")
            try values.encode(size, forKey: "size")
            try values.encode(name, forKey: "name")
            try values.encode(path, forKey: "path")
            try values.encodeIfPresent(content, forKey: "content")
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
            try values.encodeIfPresent(gitURL, forKey: "git_url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encode(links, forKey: "_links")
        }
    }

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(type: String, size: Int, name: String, path: String, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, entries: [Entry]? = nil, links: Links, content: AnyJSON, encoding: AnyJSON) {
        self.type = type
        self.size = size
        self.name = name
        self.path = path
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.downloadURL = downloadURL
        self.entries = entries
        self.links = links
        self.content = content
        self.encoding = encoding
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.size = try values.decode(Int.self, forKey: "size")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.entries = try values.decodeIfPresent([Entry].self, forKey: "entries")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.content = try values.decode(AnyJSON.self, forKey: "content")
        self.encoding = try values.decode(AnyJSON.self, forKey: "encoding")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(size, forKey: "size")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encodeIfPresent(entries, forKey: "entries")
        try values.encode(links, forKey: "_links")
        try values.encode(content, forKey: "content")
        try values.encode(encoding, forKey: "encoding")
    }
}

public struct ContentDirectoryItem: Codable {
    public var type: String
    public var size: Int
    public var name: String
    public var path: String
    public var content: String?
    public var sha: String
    public var url: URL
    public var gitURL: URL?
    public var htmlURL: URL?
    public var downloadURL: URL?
    public var links: Links

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(type: String, size: Int, name: String, path: String, content: String? = nil, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, links: Links) {
        self.type = type
        self.size = size
        self.name = name
        self.path = path
        self.content = content
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.downloadURL = downloadURL
        self.links = links
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.size = try values.decode(Int.self, forKey: "size")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.content = try values.decodeIfPresent(String.self, forKey: "content")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.links = try values.decode(Links.self, forKey: "_links")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(size, forKey: "size")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encodeIfPresent(content, forKey: "content")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encode(links, forKey: "_links")
    }
}

public struct ContentFile: Codable {
    public var type: String
    public var encoding: String
    public var size: Int
    public var name: String
    public var path: String
    public var content: String
    public var sha: String
    public var url: URL
    public var gitURL: URL?
    public var htmlURL: URL?
    public var downloadURL: URL?
    public var links: Links
    /// Example: "actual/actual.md"
    public var target: String?
    /// Example: "git://example.com/defunkt/dotjs.git"
    public var submoduleGitURL: String?

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(type: String, encoding: String, size: Int, name: String, path: String, content: String, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, links: Links, target: String? = nil, submoduleGitURL: String? = nil) {
        self.type = type
        self.encoding = encoding
        self.size = size
        self.name = name
        self.path = path
        self.content = content
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.downloadURL = downloadURL
        self.links = links
        self.target = target
        self.submoduleGitURL = submoduleGitURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.encoding = try values.decode(String.self, forKey: "encoding")
        self.size = try values.decode(Int.self, forKey: "size")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.content = try values.decode(String.self, forKey: "content")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.target = try values.decodeIfPresent(String.self, forKey: "target")
        self.submoduleGitURL = try values.decodeIfPresent(String.self, forKey: "submodule_git_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(encoding, forKey: "encoding")
        try values.encode(size, forKey: "size")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(content, forKey: "content")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(target, forKey: "target")
        try values.encodeIfPresent(submoduleGitURL, forKey: "submodule_git_url")
    }
}

/// Symlink Content
///
/// An object describing a symlink
public struct ContentSymlink: Codable {
    public var type: String
    public var target: String
    public var size: Int
    public var name: String
    public var path: String
    public var sha: String
    public var url: URL
    public var gitURL: URL?
    public var htmlURL: URL?
    public var downloadURL: URL?
    public var links: Links

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(type: String, target: String, size: Int, name: String, path: String, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, links: Links) {
        self.type = type
        self.target = target
        self.size = size
        self.name = name
        self.path = path
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.downloadURL = downloadURL
        self.links = links
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.target = try values.decode(String.self, forKey: "target")
        self.size = try values.decode(Int.self, forKey: "size")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.links = try values.decode(Links.self, forKey: "_links")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(target, forKey: "target")
        try values.encode(size, forKey: "size")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encode(links, forKey: "_links")
    }
}

/// Symlink Content
///
/// An object describing a symlink
public struct ContentSubmodule: Codable {
    public var type: String
    public var submoduleGitURL: URL
    public var size: Int
    public var name: String
    public var path: String
    public var sha: String
    public var url: URL
    public var gitURL: URL?
    public var htmlURL: URL?
    public var downloadURL: URL?
    public var links: Links

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(type: String, submoduleGitURL: URL, size: Int, name: String, path: String, sha: String, url: URL, gitURL: URL? = nil, htmlURL: URL? = nil, downloadURL: URL? = nil, links: Links) {
        self.type = type
        self.submoduleGitURL = submoduleGitURL
        self.size = size
        self.name = name
        self.path = path
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.downloadURL = downloadURL
        self.links = links
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.submoduleGitURL = try values.decode(URL.self, forKey: "submodule_git_url")
        self.size = try values.decode(Int.self, forKey: "size")
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.links = try values.decode(Links.self, forKey: "_links")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(submoduleGitURL, forKey: "submodule_git_url")
        try values.encode(size, forKey: "size")
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encode(links, forKey: "_links")
    }
}

public struct FileCommit: Codable {
    public var content: Content?
    public var commit: Commit

    public struct Content: Codable {
        public var name: String?
        public var path: String?
        public var sha: String?
        public var size: Int?
        public var url: String?
        public var htmlURL: String?
        public var gitURL: String?
        public var downloadURL: String?
        public var type: String?
        public var links: Links?

        public struct Links: Codable {
            public var this: String?
            public var git: String?
            public var html: String?

            public init(this: String? = nil, git: String? = nil, html: String? = nil) {
                self.this = this
                self.git = git
                self.html = html
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.this = try values.decodeIfPresent(String.self, forKey: "self")
                self.git = try values.decodeIfPresent(String.self, forKey: "git")
                self.html = try values.decodeIfPresent(String.self, forKey: "html")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(this, forKey: "self")
                try values.encodeIfPresent(git, forKey: "git")
                try values.encodeIfPresent(html, forKey: "html")
            }
        }

        public init(name: String? = nil, path: String? = nil, sha: String? = nil, size: Int? = nil, url: String? = nil, htmlURL: String? = nil, gitURL: String? = nil, downloadURL: String? = nil, type: String? = nil, links: Links? = nil) {
            self.name = name
            self.path = path
            self.sha = sha
            self.size = size
            self.url = url
            self.htmlURL = htmlURL
            self.gitURL = gitURL
            self.downloadURL = downloadURL
            self.type = type
            self.links = links
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.path = try values.decodeIfPresent(String.self, forKey: "path")
            self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
            self.size = try values.decodeIfPresent(Int.self, forKey: "size")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.gitURL = try values.decodeIfPresent(String.self, forKey: "git_url")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.links = try values.decodeIfPresent(Links.self, forKey: "_links")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(path, forKey: "path")
            try values.encodeIfPresent(sha, forKey: "sha")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(gitURL, forKey: "git_url")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(links, forKey: "_links")
        }
    }

    public struct Commit: Codable {
        public var sha: String?
        public var nodeID: String?
        public var url: String?
        public var htmlURL: String?
        public var author: Author?
        public var committer: Committer?
        public var message: String?
        public var tree: Tree?
        public var parents: [Parent]?
        public var verification: Verification?

        public struct Author: Codable {
            public var date: String?
            public var name: String?
            public var email: String?

            public init(date: String? = nil, name: String? = nil, email: String? = nil) {
                self.date = date
                self.name = name
                self.email = email
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.date = try values.decodeIfPresent(String.self, forKey: "date")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.email = try values.decodeIfPresent(String.self, forKey: "email")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(date, forKey: "date")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(email, forKey: "email")
            }
        }

        public struct Committer: Codable {
            public var date: String?
            public var name: String?
            public var email: String?

            public init(date: String? = nil, name: String? = nil, email: String? = nil) {
                self.date = date
                self.name = name
                self.email = email
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.date = try values.decodeIfPresent(String.self, forKey: "date")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.email = try values.decodeIfPresent(String.self, forKey: "email")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(date, forKey: "date")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(email, forKey: "email")
            }
        }

        public struct Tree: Codable {
            public var url: String?
            public var sha: String?

            public init(url: String? = nil, sha: String? = nil) {
                self.url = url
                self.sha = sha
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
                self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(url, forKey: "url")
                try values.encodeIfPresent(sha, forKey: "sha")
            }
        }

        public struct Parent: Codable {
            public var url: String?
            public var htmlURL: String?
            public var sha: String?

            public init(url: String? = nil, htmlURL: String? = nil, sha: String? = nil) {
                self.url = url
                self.htmlURL = htmlURL
                self.sha = sha
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
                self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
                self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(url, forKey: "url")
                try values.encodeIfPresent(htmlURL, forKey: "html_url")
                try values.encodeIfPresent(sha, forKey: "sha")
            }
        }

        public struct Verification: Codable {
            public var isVerified: Bool?
            public var reason: String?
            public var signature: String?
            public var payload: String?

            public init(isVerified: Bool? = nil, reason: String? = nil, signature: String? = nil, payload: String? = nil) {
                self.isVerified = isVerified
                self.reason = reason
                self.signature = signature
                self.payload = payload
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.isVerified = try values.decodeIfPresent(Bool.self, forKey: "verified")
                self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
                self.signature = try values.decodeIfPresent(String.self, forKey: "signature")
                self.payload = try values.decodeIfPresent(String.self, forKey: "payload")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(isVerified, forKey: "verified")
                try values.encodeIfPresent(reason, forKey: "reason")
                try values.encodeIfPresent(signature, forKey: "signature")
                try values.encodeIfPresent(payload, forKey: "payload")
            }
        }

        public init(sha: String? = nil, nodeID: String? = nil, url: String? = nil, htmlURL: String? = nil, author: Author? = nil, committer: Committer? = nil, message: String? = nil, tree: Tree? = nil, parents: [Parent]? = nil, verification: Verification? = nil) {
            self.sha = sha
            self.nodeID = nodeID
            self.url = url
            self.htmlURL = htmlURL
            self.author = author
            self.committer = committer
            self.message = message
            self.tree = tree
            self.parents = parents
            self.verification = verification
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.author = try values.decodeIfPresent(Author.self, forKey: "author")
            self.committer = try values.decodeIfPresent(Committer.self, forKey: "committer")
            self.message = try values.decodeIfPresent(String.self, forKey: "message")
            self.tree = try values.decodeIfPresent(Tree.self, forKey: "tree")
            self.parents = try values.decodeIfPresent([Parent].self, forKey: "parents")
            self.verification = try values.decodeIfPresent(Verification.self, forKey: "verification")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(sha, forKey: "sha")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(author, forKey: "author")
            try values.encodeIfPresent(committer, forKey: "committer")
            try values.encodeIfPresent(message, forKey: "message")
            try values.encodeIfPresent(tree, forKey: "tree")
            try values.encodeIfPresent(parents, forKey: "parents")
            try values.encodeIfPresent(verification, forKey: "verification")
        }
    }

    public init(content: Content? = nil, commit: Commit) {
        self.content = content
        self.commit = commit
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.content = try values.decodeIfPresent(Content.self, forKey: "content")
        self.commit = try values.decode(Commit.self, forKey: "commit")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(content, forKey: "content")
        try values.encode(commit, forKey: "commit")
    }
}

public struct Contributor: Codable {
    public var login: String?
    public var id: Int?
    public var nodeID: String?
    public var avatarURL: URL?
    public var gravatarID: String?
    public var url: URL?
    public var htmlURL: URL?
    public var followersURL: URL?
    public var followingURL: String?
    public var gistsURL: String?
    public var starredURL: String?
    public var subscriptionsURL: URL?
    public var organizationsURL: URL?
    public var reposURL: URL?
    public var eventsURL: String?
    public var receivedEventsURL: URL?
    public var type: String
    public var isSiteAdmin: Bool?
    public var contributions: Int
    public var email: String?
    public var name: String?

    public init(login: String? = nil, id: Int? = nil, nodeID: String? = nil, avatarURL: URL? = nil, gravatarID: String? = nil, url: URL? = nil, htmlURL: URL? = nil, followersURL: URL? = nil, followingURL: String? = nil, gistsURL: String? = nil, starredURL: String? = nil, subscriptionsURL: URL? = nil, organizationsURL: URL? = nil, reposURL: URL? = nil, eventsURL: String? = nil, receivedEventsURL: URL? = nil, type: String, isSiteAdmin: Bool? = nil, contributions: Int, email: String? = nil, name: String? = nil) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.isSiteAdmin = isSiteAdmin
        self.contributions = contributions
        self.email = email
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decodeIfPresent(String.self, forKey: "login")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        self.avatarURL = try values.decodeIfPresent(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.followersURL = try values.decodeIfPresent(URL.self, forKey: "followers_url")
        self.followingURL = try values.decodeIfPresent(String.self, forKey: "following_url")
        self.gistsURL = try values.decodeIfPresent(String.self, forKey: "gists_url")
        self.starredURL = try values.decodeIfPresent(String.self, forKey: "starred_url")
        self.subscriptionsURL = try values.decodeIfPresent(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decodeIfPresent(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decodeIfPresent(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decodeIfPresent(String.self, forKey: "events_url")
        self.receivedEventsURL = try values.decodeIfPresent(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.isSiteAdmin = try values.decodeIfPresent(Bool.self, forKey: "site_admin")
        self.contributions = try values.decode(Int.self, forKey: "contributions")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(login, forKey: "login")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(nodeID, forKey: "node_id")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(followersURL, forKey: "followers_url")
        try values.encodeIfPresent(followingURL, forKey: "following_url")
        try values.encodeIfPresent(gistsURL, forKey: "gists_url")
        try values.encodeIfPresent(starredURL, forKey: "starred_url")
        try values.encodeIfPresent(subscriptionsURL, forKey: "subscriptions_url")
        try values.encodeIfPresent(organizationsURL, forKey: "organizations_url")
        try values.encodeIfPresent(reposURL, forKey: "repos_url")
        try values.encodeIfPresent(eventsURL, forKey: "events_url")
        try values.encodeIfPresent(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(isSiteAdmin, forKey: "site_admin")
        try values.encode(contributions, forKey: "contributions")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// The status of a deployment.
public struct DeploymentStatus: Codable {
    /// Example: "https://api.github.com/repos/octocat/example/deployments/42/statuses/1"
    public var url: URL
    public var id: Int
    /// Example: "MDE2OkRlcGxveW1lbnRTdGF0dXMx"
    public var nodeID: String
    /// The state of the status.
    ///
    /// Example: "success"
    public var state: State
    /// Simple User
    public var creator: SimpleUser?
    /// A short description of the status.
    ///
    /// Example: "Deployment finished successfully."
    public var description: String
    /// The environment of the deployment that the status is for.
    ///
    /// Example: "production"
    public var environment: String?
    /// Deprecated: the URL to associate with this status.
    ///
    /// Example: "https://example.com/deployment/42/output"
    public var targetURL: URL
    /// Example: "2012-07-20T01:19:13Z"
    public var createdAt: Date
    /// Example: "2012-07-20T01:19:13Z"
    public var updatedAt: Date
    /// Example: "https://api.github.com/repos/octocat/example/deployments/42"
    public var deploymentURL: URL
    /// Example: "https://api.github.com/repos/octocat/example"
    public var repositoryURL: URL
    /// The URL for accessing your environment.
    ///
    /// Example: "https://staging.example.com/"
    public var environmentURL: URL?
    /// The URL to associate with this status.
    ///
    /// Example: "https://example.com/deployment/42/output"
    public var logURL: URL?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?

    /// The state of the status.
    ///
    /// Example: "success"
    public enum State: String, Codable, CaseIterable {
        case error
        case failure
        case inactive
        case pending
        case success
        case queued
        case inProgress = "in_progress"
    }

    public init(url: URL, id: Int, nodeID: String, state: State, creator: SimpleUser? = nil, description: String, environment: String? = nil, targetURL: URL, createdAt: Date, updatedAt: Date, deploymentURL: URL, repositoryURL: URL, environmentURL: URL? = nil, logURL: URL? = nil, performedViaGithubApp: Integration? = nil) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.state = state
        self.creator = creator
        self.description = description
        self.environment = environment
        self.targetURL = targetURL
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deploymentURL = deploymentURL
        self.repositoryURL = repositoryURL
        self.environmentURL = environmentURL
        self.logURL = logURL
        self.performedViaGithubApp = performedViaGithubApp
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.state = try values.decode(State.self, forKey: "state")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
        self.description = try values.decode(String.self, forKey: "description")
        self.environment = try values.decodeIfPresent(String.self, forKey: "environment")
        self.targetURL = try values.decode(URL.self, forKey: "target_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.deploymentURL = try values.decode(URL.self, forKey: "deployment_url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.environmentURL = try values.decodeIfPresent(URL.self, forKey: "environment_url")
        self.logURL = try values.decodeIfPresent(URL.self, forKey: "log_url")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encode(description, forKey: "description")
        try values.encodeIfPresent(environment, forKey: "environment")
        try values.encode(targetURL, forKey: "target_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(deploymentURL, forKey: "deployment_url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encodeIfPresent(environmentURL, forKey: "environment_url")
        try values.encodeIfPresent(logURL, forKey: "log_url")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
    }
}

/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
public struct DeploymentBranchPolicy: Codable {
    /// Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
    public var isProtectedBranches: Bool
    /// Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
    public var isCustomBranchPolicies: Bool

    public init(isProtectedBranches: Bool, isCustomBranchPolicies: Bool) {
        self.isProtectedBranches = isProtectedBranches
        self.isCustomBranchPolicies = isCustomBranchPolicies
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isProtectedBranches = try values.decode(Bool.self, forKey: "protected_branches")
        self.isCustomBranchPolicies = try values.decode(Bool.self, forKey: "custom_branch_policies")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isProtectedBranches, forKey: "protected_branches")
        try values.encode(isCustomBranchPolicies, forKey: "custom_branch_policies")
    }
}

/// Details of a deployment environment
public struct Environment: Codable {
    /// The id of the environment.
    ///
    /// Example: 56780428
    public var id: Int
    /// Example: "MDExOkVudmlyb25tZW50NTY3ODA0Mjg="
    public var nodeID: String
    /// The name of the environment.
    ///
    /// Example: "staging"
    public var name: String
    /// Example: "https://api.github.com/repos/github/hello-world/environments/staging"
    public var url: String
    /// Example: "https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"
    public var htmlURL: String
    /// The time that the environment was created, in ISO 8601 format.
    ///
    /// Example: "2020-11-23T22:00:40Z"
    public var createdAt: Date
    /// The time that the environment was last updated, in ISO 8601 format.
    ///
    /// Example: "2020-11-23T22:00:40Z"
    public var updatedAt: Date
    public var protectionRules: [ProtectionRule]?
    /// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
    public var deploymentBranchPolicy: DeploymentBranchPolicy?

    public struct ProtectionRule: Codable {
        public var a: A?
        public var b: B?
        public var c: C?

        public struct A: Codable {
            /// Example: 3515
            public var id: Int
            /// Example: "MDQ6R2F0ZTM1MTU="
            public var nodeID: String
            /// Example: "wait_timer"
            public var type: String
            /// The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
            ///
            /// Example: 30
            public var waitTimer: Int?

            public init(id: Int, nodeID: String, type: String, waitTimer: Int? = nil) {
                self.id = id
                self.nodeID = nodeID
                self.type = type
                self.waitTimer = waitTimer
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.type = try values.decode(String.self, forKey: "type")
                self.waitTimer = try values.decodeIfPresent(Int.self, forKey: "wait_timer")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(type, forKey: "type")
                try values.encodeIfPresent(waitTimer, forKey: "wait_timer")
            }
        }

        public struct B: Codable {
            /// Example: 3755
            public var id: Int
            /// Example: "MDQ6R2F0ZTM3NTU="
            public var nodeID: String
            /// Example: "required_reviewers"
            public var type: String
            /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
            public var reviewers: [Reviewer]?

            public struct Reviewer: Codable {
                /// The type of reviewer. Must be one of: `User` or `Team`
                ///
                /// Example: "User"
                public var type: DeploymentReviewerType?
                public var reviewer: Reviewer?

                public struct Reviewer: Codable {
                    public var simpleUser: SimpleUser?
                    /// Groups of organization members that gives permissions on specified repositories.
                    public var team: Team?

                    public init(simpleUser: SimpleUser? = nil, team: Team? = nil) {
                        self.simpleUser = simpleUser
                        self.team = team
                    }

                    public init(from decoder: Decoder) throws {
                        let container = try decoder.singleValueContainer()
                        self.simpleUser = try? container.decode(SimpleUser.self)
                        self.team = try? container.decode(Team.self)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.singleValueContainer()
                        if let value = simpleUser { try container.encode(value) }
                        if let value = team { try container.encode(value) }
                    }
                }

                public init(type: DeploymentReviewerType? = nil, reviewer: Reviewer? = nil) {
                    self.type = type
                    self.reviewer = reviewer
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.type = try values.decodeIfPresent(DeploymentReviewerType.self, forKey: "type")
                    self.reviewer = try values.decodeIfPresent(Reviewer.self, forKey: "reviewer")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(type, forKey: "type")
                    try values.encodeIfPresent(reviewer, forKey: "reviewer")
                }
            }

            public init(id: Int, nodeID: String, type: String, reviewers: [Reviewer]? = nil) {
                self.id = id
                self.nodeID = nodeID
                self.type = type
                self.reviewers = reviewers
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.type = try values.decode(String.self, forKey: "type")
                self.reviewers = try values.decodeIfPresent([Reviewer].self, forKey: "reviewers")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(type, forKey: "type")
                try values.encodeIfPresent(reviewers, forKey: "reviewers")
            }
        }

        public struct C: Codable {
            /// Example: 3515
            public var id: Int
            /// Example: "MDQ6R2F0ZTM1MTU="
            public var nodeID: String
            /// Example: "branch_policy"
            public var type: String

            public init(id: Int, nodeID: String, type: String) {
                self.id = id
                self.nodeID = nodeID
                self.type = type
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.type = try values.decode(String.self, forKey: "type")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(type, forKey: "type")
            }
        }

        public init(a: A? = nil, b: B? = nil, c: C? = nil) {
            self.a = a
            self.b = b
            self.c = c
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.a = try? container.decode(A.self)
            self.b = try? container.decode(B.self)
            self.c = try? container.decode(C.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = a { try container.encode(value) }
            if let value = b { try container.encode(value) }
            if let value = c { try container.encode(value) }
        }
    }

    public init(id: Int, nodeID: String, name: String, url: String, htmlURL: String, createdAt: Date, updatedAt: Date, protectionRules: [ProtectionRule]? = nil, deploymentBranchPolicy: DeploymentBranchPolicy? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.url = url
        self.htmlURL = htmlURL
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.protectionRules = protectionRules
        self.deploymentBranchPolicy = deploymentBranchPolicy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decode(String.self, forKey: "url")
        self.htmlURL = try values.decode(String.self, forKey: "html_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.protectionRules = try values.decodeIfPresent([ProtectionRule].self, forKey: "protection_rules")
        self.deploymentBranchPolicy = try values.decodeIfPresent(DeploymentBranchPolicy.self, forKey: "deployment_branch_policy")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(protectionRules, forKey: "protection_rules")
        try values.encodeIfPresent(deploymentBranchPolicy, forKey: "deployment_branch_policy")
    }
}

public struct ShortBlob: Codable {
    public var url: String
    public var sha: String

    public init(url: String, sha: String) {
        self.url = url
        self.sha = sha
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(String.self, forKey: "url")
        self.sha = try values.decode(String.self, forKey: "sha")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(sha, forKey: "sha")
    }
}

public struct Blob: Codable {
    public var content: String
    public var encoding: String
    public var url: URL
    public var sha: String
    public var size: Int?
    public var nodeID: String
    public var highlightedContent: String?

    public init(content: String, encoding: String, url: URL, sha: String, size: Int? = nil, nodeID: String, highlightedContent: String? = nil) {
        self.content = content
        self.encoding = encoding
        self.url = url
        self.sha = sha
        self.size = size
        self.nodeID = nodeID
        self.highlightedContent = highlightedContent
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.content = try values.decode(String.self, forKey: "content")
        self.encoding = try values.decode(String.self, forKey: "encoding")
        self.url = try values.decode(URL.self, forKey: "url")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.highlightedContent = try values.decodeIfPresent(String.self, forKey: "highlighted_content")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(content, forKey: "content")
        try values.encode(encoding, forKey: "encoding")
        try values.encode(url, forKey: "url")
        try values.encode(sha, forKey: "sha")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(highlightedContent, forKey: "highlighted_content")
    }
}

/// Low-level Git commit operations within a repository
public struct GitCommit: Codable {
    /// SHA for the commit
    ///
    /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
    public var sha: String
    public var nodeID: String
    public var url: URL
    /// Identifying information for the git-user
    public var author: Author
    /// Identifying information for the git-user
    public var committer: Committer
    /// Message describing the purpose of the commit
    ///
    /// Example: "Fix #42"
    public var message: String
    public var tree: Tree
    public var parents: [Parent]
    public var verification: Verification
    public var htmlURL: URL

    /// Identifying information for the git-user
    public struct Author: Codable {
        /// Timestamp of the commit
        ///
        /// Example: "2014-08-09T08:02:04+12:00"
        public var date: Date
        /// Git email address of the user
        ///
        /// Example: "monalisa.octocat@example.com"
        public var email: String
        /// Name of the git user
        ///
        /// Example: "Monalisa Octocat"
        public var name: String

        public init(date: Date, email: String, name: String) {
            self.date = date
            self.email = email
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
        }
    }

    /// Identifying information for the git-user
    public struct Committer: Codable {
        /// Timestamp of the commit
        ///
        /// Example: "2014-08-09T08:02:04+12:00"
        public var date: Date
        /// Git email address of the user
        ///
        /// Example: "monalisa.octocat@example.com"
        public var email: String
        /// Name of the git user
        ///
        /// Example: "Monalisa Octocat"
        public var name: String

        public init(date: Date, email: String, name: String) {
            self.date = date
            self.email = email
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
        }
    }

    public struct Tree: Codable {
        /// SHA for the commit
        ///
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        public var url: URL

        public init(sha: String, url: URL) {
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public struct Parent: Codable {
        /// SHA for the commit
        ///
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        public var url: URL
        public var htmlURL: URL

        public init(sha: String, url: URL, htmlURL: URL) {
            self.sha = sha
            self.url = url
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
            self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
            try values.encode(htmlURL, forKey: "html_url")
        }
    }

    public struct Verification: Codable {
        public var isVerified: Bool
        public var reason: String
        public var signature: String?
        public var payload: String?

        public init(isVerified: Bool, reason: String, signature: String? = nil, payload: String? = nil) {
            self.isVerified = isVerified
            self.reason = reason
            self.signature = signature
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isVerified = try values.decode(Bool.self, forKey: "verified")
            self.reason = try values.decode(String.self, forKey: "reason")
            self.signature = try values.decodeIfPresent(String.self, forKey: "signature")
            self.payload = try values.decodeIfPresent(String.self, forKey: "payload")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isVerified, forKey: "verified")
            try values.encode(reason, forKey: "reason")
            try values.encodeIfPresent(signature, forKey: "signature")
            try values.encodeIfPresent(payload, forKey: "payload")
        }
    }

    public init(sha: String, nodeID: String, url: URL, author: Author, committer: Committer, message: String, tree: Tree, parents: [Parent], verification: Verification, htmlURL: URL) {
        self.sha = sha
        self.nodeID = nodeID
        self.url = url
        self.author = author
        self.committer = committer
        self.message = message
        self.tree = tree
        self.parents = parents
        self.verification = verification
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decode(String.self, forKey: "sha")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.author = try values.decode(Author.self, forKey: "author")
        self.committer = try values.decode(Committer.self, forKey: "committer")
        self.message = try values.decode(String.self, forKey: "message")
        self.tree = try values.decode(Tree.self, forKey: "tree")
        self.parents = try values.decode([Parent].self, forKey: "parents")
        self.verification = try values.decode(Verification.self, forKey: "verification")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(sha, forKey: "sha")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(author, forKey: "author")
        try values.encode(committer, forKey: "committer")
        try values.encode(message, forKey: "message")
        try values.encode(tree, forKey: "tree")
        try values.encode(parents, forKey: "parents")
        try values.encode(verification, forKey: "verification")
        try values.encode(htmlURL, forKey: "html_url")
    }
}

/// Git Reference
///
/// Git references within a repository
public struct GitRef: Codable {
    public var ref: String
    public var nodeID: String
    public var url: URL
    public var object: Object

    public struct Object: Codable {
        public var type: String
        /// SHA for the reference
        ///
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        public var url: URL

        public init(type: String, sha: String, url: URL) {
            self.type = type
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decode(String.self, forKey: "type")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(type, forKey: "type")
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public init(ref: String, nodeID: String, url: URL, object: Object) {
        self.ref = ref
        self.nodeID = nodeID
        self.url = url
        self.object = object
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ref = try values.decode(String.self, forKey: "ref")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.object = try values.decode(Object.self, forKey: "object")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ref, forKey: "ref")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(object, forKey: "object")
    }
}

/// Metadata for a Git tag
public struct GitTag: Codable {
    /// Example: "MDM6VGFnOTQwYmQzMzYyNDhlZmFlMGY5ZWU1YmM3YjJkNWM5ODU4ODdiMTZhYw=="
    public var nodeID: String
    /// Name of the tag
    ///
    /// Example: "v0.0.1"
    public var tag: String
    /// Example: "940bd336248efae0f9ee5bc7b2d5c985887b16ac"
    public var sha: String
    /// URL for the tag
    ///
    /// Example: "https://api.github.com/repositories/42/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac"
    public var url: URL
    /// Message describing the purpose of the tag
    ///
    /// Example: "Initial public release"
    public var message: String
    public var tagger: Tagger
    public var object: Object
    public var verification: Verification?

    public struct Tagger: Codable {
        public var date: String
        public var email: String
        public var name: String

        public init(date: String, email: String, name: String) {
            self.date = date
            self.email = email
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(String.self, forKey: "date")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
        }
    }

    public struct Object: Codable {
        public var sha: String
        public var type: String
        public var url: URL

        public init(sha: String, type: String, url: URL) {
            self.sha = sha
            self.type = type
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.type = try values.decode(String.self, forKey: "type")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(type, forKey: "type")
            try values.encode(url, forKey: "url")
        }
    }

    public init(nodeID: String, tag: String, sha: String, url: URL, message: String, tagger: Tagger, object: Object, verification: Verification? = nil) {
        self.nodeID = nodeID
        self.tag = tag
        self.sha = sha
        self.url = url
        self.message = message
        self.tagger = tagger
        self.object = object
        self.verification = verification
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.tag = try values.decode(String.self, forKey: "tag")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.message = try values.decode(String.self, forKey: "message")
        self.tagger = try values.decode(Tagger.self, forKey: "tagger")
        self.object = try values.decode(Object.self, forKey: "object")
        self.verification = try values.decodeIfPresent(Verification.self, forKey: "verification")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(tag, forKey: "tag")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encode(message, forKey: "message")
        try values.encode(tagger, forKey: "tagger")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(verification, forKey: "verification")
    }
}

/// The hierarchy between files in a Git repository.
public struct GitTree: Codable {
    public var sha: String
    public var url: URL
    public var isTruncated: Bool
    /// Objects specifying a tree structure
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "mode" : "100644",
    ///     "path" : "file.rb",
    ///     "properties" : {
    ///       "mode" : {
    ///         "type" : "string"
    ///       },
    ///       "path" : {
    ///         "type" : "string"
    ///       },
    ///       "sha" : {
    ///         "type" : "string"
    ///       },
    ///       "size" : {
    ///         "type" : "integer"
    ///       },
    ///       "type" : {
    ///         "type" : "string"
    ///       },
    ///       "url" : {
    ///         "type" : "string"
    ///       }
    ///     },
    ///     "required" : [
    ///       "path",
    ///       "mode",
    ///       "type",
    ///       "sha",
    ///       "url",
    ///       "size"
    ///     ],
    ///     "sha" : "44b4fc6d56897b048c772eb4087f854f46256132",
    ///     "size" : 30,
    ///     "type" : "blob",
    ///     "url" : "https:\/\/api.github.com\/repos\/octocat\/Hello-World\/git\/blobs\/44b4fc6d56897b048c772eb4087f854f46256132"
    ///   }
    /// ]
    public var tree: [TreeItem]

    public struct TreeItem: Codable {
        /// Example: "test/file.rb"
        public var path: String?
        /// Example: "040000"
        public var mode: String?
        /// Example: "tree"
        public var type: String?
        /// Example: "23f6827669e43831def8a7ad935069c8bd418261"
        public var sha: String?
        /// Example: 12
        public var size: Int?
        /// Example: "https://api.github.com/repos/owner-482f3203ecf01f67e9deb18e/BBB_Private_Repo/git/blobs/23f6827669e43831def8a7ad935069c8bd418261"
        public var url: String?

        public init(path: String? = nil, mode: String? = nil, type: String? = nil, sha: String? = nil, size: Int? = nil, url: String? = nil) {
            self.path = path
            self.mode = mode
            self.type = type
            self.sha = sha
            self.size = size
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.path = try values.decodeIfPresent(String.self, forKey: "path")
            self.mode = try values.decodeIfPresent(String.self, forKey: "mode")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
            self.size = try values.decodeIfPresent(Int.self, forKey: "size")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(path, forKey: "path")
            try values.encodeIfPresent(mode, forKey: "mode")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(sha, forKey: "sha")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(url, forKey: "url")
        }
    }

    public init(sha: String, url: URL, isTruncated: Bool, tree: [TreeItem]) {
        self.sha = sha
        self.url = url
        self.isTruncated = isTruncated
        self.tree = tree
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.isTruncated = try values.decode(Bool.self, forKey: "truncated")
        self.tree = try values.decode([TreeItem].self, forKey: "tree")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encode(isTruncated, forKey: "truncated")
        try values.encode(tree, forKey: "tree")
    }
}

public struct HookResponse: Codable {
    public var code: Int?
    public var status: String?
    public var message: String?

    public init(code: Int? = nil, status: String? = nil, message: String? = nil) {
        self.code = code
        self.status = status
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.code = try values.decodeIfPresent(Int.self, forKey: "code")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(code, forKey: "code")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(message, forKey: "message")
    }
}

/// Webhook
///
/// Webhooks for repositories.
public struct Hook: Codable {
    public var type: String
    /// Unique identifier of the webhook.
    ///
    /// Example: 42
    public var id: Int
    /// The name of a valid service, use 'web' for a webhook.
    ///
    /// Example: "web"
    public var name: String
    /// Determines whether the hook is actually triggered on pushes.
    ///
    /// Example: true
    public var isActive: Bool
    /// Determines what events the hook is triggered for. Default: ['push'].
    ///
    /// Example: ["push", "pull_request"]
    public var events: [String]
    public var config: Config
    /// Example: "2011-09-06T20:39:23Z"
    public var updatedAt: Date
    /// Example: "2011-09-06T17:26:27Z"
    public var createdAt: Date
    /// Example: "https://api.github.com/repos/octocat/Hello-World/hooks/1"
    public var url: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/hooks/1/test"
    public var testURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/hooks/1/pings"
    public var pingURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/hooks/1/deliveries"
    public var deliveriesURL: URL?
    /// Hook Response
    public var lastResponse: HookResponse

    public struct Config: Codable {
        /// Example: "foo@bar.com"
        public var email: String?
        /// Example: "foo"
        public var password: String?
        /// Example: "roomer"
        public var room: String?
        /// Example: "foo"
        public var subdomain: String?
        /// The URL to which the payloads will be delivered.
        ///
        /// Example: "https://example.com/webhook"
        public var url: URL?
        public var insecureSSL: WebhookConfigInsecureSSL?
        /// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
        ///
        /// Example: "json"
        public var contentType: String?
        /// Example: "sha256"
        public var digest: String?
        /// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
        ///
        /// Example: "********"
        public var secret: String?
        /// Example: "abc"
        public var token: String?

        public init(email: String? = nil, password: String? = nil, room: String? = nil, subdomain: String? = nil, url: URL? = nil, insecureSSL: WebhookConfigInsecureSSL? = nil, contentType: String? = nil, digest: String? = nil, secret: String? = nil, token: String? = nil) {
            self.email = email
            self.password = password
            self.room = room
            self.subdomain = subdomain
            self.url = url
            self.insecureSSL = insecureSSL
            self.contentType = contentType
            self.digest = digest
            self.secret = secret
            self.token = token
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
            self.password = try values.decodeIfPresent(String.self, forKey: "password")
            self.room = try values.decodeIfPresent(String.self, forKey: "room")
            self.subdomain = try values.decodeIfPresent(String.self, forKey: "subdomain")
            self.url = try values.decodeIfPresent(URL.self, forKey: "url")
            self.insecureSSL = try values.decodeIfPresent(WebhookConfigInsecureSSL.self, forKey: "insecure_ssl")
            self.contentType = try values.decodeIfPresent(String.self, forKey: "content_type")
            self.digest = try values.decodeIfPresent(String.self, forKey: "digest")
            self.secret = try values.decodeIfPresent(String.self, forKey: "secret")
            self.token = try values.decodeIfPresent(String.self, forKey: "token")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(email, forKey: "email")
            try values.encodeIfPresent(password, forKey: "password")
            try values.encodeIfPresent(room, forKey: "room")
            try values.encodeIfPresent(subdomain, forKey: "subdomain")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(insecureSSL, forKey: "insecure_ssl")
            try values.encodeIfPresent(contentType, forKey: "content_type")
            try values.encodeIfPresent(digest, forKey: "digest")
            try values.encodeIfPresent(secret, forKey: "secret")
            try values.encodeIfPresent(token, forKey: "token")
        }
    }

    public init(type: String, id: Int, name: String, isActive: Bool, events: [String], config: Config, updatedAt: Date, createdAt: Date, url: URL, testURL: URL, pingURL: URL, deliveriesURL: URL? = nil, lastResponse: HookResponse) {
        self.type = type
        self.id = id
        self.name = name
        self.isActive = isActive
        self.events = events
        self.config = config
        self.updatedAt = updatedAt
        self.createdAt = createdAt
        self.url = url
        self.testURL = testURL
        self.pingURL = pingURL
        self.deliveriesURL = deliveriesURL
        self.lastResponse = lastResponse
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.isActive = try values.decode(Bool.self, forKey: "active")
        self.events = try values.decode([String].self, forKey: "events")
        self.config = try values.decode(Config.self, forKey: "config")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.testURL = try values.decode(URL.self, forKey: "test_url")
        self.pingURL = try values.decode(URL.self, forKey: "ping_url")
        self.deliveriesURL = try values.decodeIfPresent(URL.self, forKey: "deliveries_url")
        self.lastResponse = try values.decode(HookResponse.self, forKey: "last_response")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(isActive, forKey: "active")
        try values.encode(events, forKey: "events")
        try values.encode(config, forKey: "config")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(url, forKey: "url")
        try values.encode(testURL, forKey: "test_url")
        try values.encode(pingURL, forKey: "ping_url")
        try values.encodeIfPresent(deliveriesURL, forKey: "deliveries_url")
        try values.encode(lastResponse, forKey: "last_response")
    }
}

/// A repository import from an external source.
public struct Import: Codable {
    public var vcs: String?
    public var useLfs: Bool?
    /// The URL of the originating repository.
    public var vcsURL: String
    public var svcRoot: String?
    public var tfvcProject: String?
    public var status: Status
    public var statusText: String?
    public var failedStep: String?
    public var errorMessage: String?
    public var importPercent: Int?
    public var commitCount: Int?
    public var pushPercent: Int?
    public var hasLargeFiles: Bool?
    public var largeFilesSize: Int?
    public var largeFilesCount: Int?
    public var projectChoices: [ProjectChoice]?
    public var message: String?
    public var authorsCount: Int?
    public var url: URL
    public var htmlURL: URL
    public var authorsURL: URL
    public var repositoryURL: URL
    public var svnRoot: String?

    public enum Status: String, Codable, CaseIterable {
        case auth
        case error
        case `none`
        case detecting
        case choose
        case authFailed = "auth_failed"
        case importing
        case mapping
        case waitingToPush = "waiting_to_push"
        case pushing
        case complete
        case setup
        case unknown
        case detectionFoundMultiple = "detection_found_multiple"
        case detectionFoundNothing = "detection_found_nothing"
        case detectionNeedsAuth = "detection_needs_auth"
    }

    public struct ProjectChoice: Codable {
        public var vcs: String?
        public var tfvcProject: String?
        public var humanName: String?

        public init(vcs: String? = nil, tfvcProject: String? = nil, humanName: String? = nil) {
            self.vcs = vcs
            self.tfvcProject = tfvcProject
            self.humanName = humanName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.vcs = try values.decodeIfPresent(String.self, forKey: "vcs")
            self.tfvcProject = try values.decodeIfPresent(String.self, forKey: "tfvc_project")
            self.humanName = try values.decodeIfPresent(String.self, forKey: "human_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(vcs, forKey: "vcs")
            try values.encodeIfPresent(tfvcProject, forKey: "tfvc_project")
            try values.encodeIfPresent(humanName, forKey: "human_name")
        }
    }

    public init(vcs: String? = nil, useLfs: Bool? = nil, vcsURL: String, svcRoot: String? = nil, tfvcProject: String? = nil, status: Status, statusText: String? = nil, failedStep: String? = nil, errorMessage: String? = nil, importPercent: Int? = nil, commitCount: Int? = nil, pushPercent: Int? = nil, hasLargeFiles: Bool? = nil, largeFilesSize: Int? = nil, largeFilesCount: Int? = nil, projectChoices: [ProjectChoice]? = nil, message: String? = nil, authorsCount: Int? = nil, url: URL, htmlURL: URL, authorsURL: URL, repositoryURL: URL, svnRoot: String? = nil) {
        self.vcs = vcs
        self.useLfs = useLfs
        self.vcsURL = vcsURL
        self.svcRoot = svcRoot
        self.tfvcProject = tfvcProject
        self.status = status
        self.statusText = statusText
        self.failedStep = failedStep
        self.errorMessage = errorMessage
        self.importPercent = importPercent
        self.commitCount = commitCount
        self.pushPercent = pushPercent
        self.hasLargeFiles = hasLargeFiles
        self.largeFilesSize = largeFilesSize
        self.largeFilesCount = largeFilesCount
        self.projectChoices = projectChoices
        self.message = message
        self.authorsCount = authorsCount
        self.url = url
        self.htmlURL = htmlURL
        self.authorsURL = authorsURL
        self.repositoryURL = repositoryURL
        self.svnRoot = svnRoot
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.vcs = try values.decodeIfPresent(String.self, forKey: "vcs")
        self.useLfs = try values.decodeIfPresent(Bool.self, forKey: "use_lfs")
        self.vcsURL = try values.decode(String.self, forKey: "vcs_url")
        self.svcRoot = try values.decodeIfPresent(String.self, forKey: "svc_root")
        self.tfvcProject = try values.decodeIfPresent(String.self, forKey: "tfvc_project")
        self.status = try values.decode(Status.self, forKey: "status")
        self.statusText = try values.decodeIfPresent(String.self, forKey: "status_text")
        self.failedStep = try values.decodeIfPresent(String.self, forKey: "failed_step")
        self.errorMessage = try values.decodeIfPresent(String.self, forKey: "error_message")
        self.importPercent = try values.decodeIfPresent(Int.self, forKey: "import_percent")
        self.commitCount = try values.decodeIfPresent(Int.self, forKey: "commit_count")
        self.pushPercent = try values.decodeIfPresent(Int.self, forKey: "push_percent")
        self.hasLargeFiles = try values.decodeIfPresent(Bool.self, forKey: "has_large_files")
        self.largeFilesSize = try values.decodeIfPresent(Int.self, forKey: "large_files_size")
        self.largeFilesCount = try values.decodeIfPresent(Int.self, forKey: "large_files_count")
        self.projectChoices = try values.decodeIfPresent([ProjectChoice].self, forKey: "project_choices")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.authorsCount = try values.decodeIfPresent(Int.self, forKey: "authors_count")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.authorsURL = try values.decode(URL.self, forKey: "authors_url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.svnRoot = try values.decodeIfPresent(String.self, forKey: "svn_root")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(vcs, forKey: "vcs")
        try values.encodeIfPresent(useLfs, forKey: "use_lfs")
        try values.encode(vcsURL, forKey: "vcs_url")
        try values.encodeIfPresent(svcRoot, forKey: "svc_root")
        try values.encodeIfPresent(tfvcProject, forKey: "tfvc_project")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(statusText, forKey: "status_text")
        try values.encodeIfPresent(failedStep, forKey: "failed_step")
        try values.encodeIfPresent(errorMessage, forKey: "error_message")
        try values.encodeIfPresent(importPercent, forKey: "import_percent")
        try values.encodeIfPresent(commitCount, forKey: "commit_count")
        try values.encodeIfPresent(pushPercent, forKey: "push_percent")
        try values.encodeIfPresent(hasLargeFiles, forKey: "has_large_files")
        try values.encodeIfPresent(largeFilesSize, forKey: "large_files_size")
        try values.encodeIfPresent(largeFilesCount, forKey: "large_files_count")
        try values.encodeIfPresent(projectChoices, forKey: "project_choices")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(authorsCount, forKey: "authors_count")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(authorsURL, forKey: "authors_url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encodeIfPresent(svnRoot, forKey: "svn_root")
    }
}

public struct PorterAuthor: Codable {
    public var id: Int
    public var remoteID: String
    public var remoteName: String
    public var email: String
    public var name: String
    public var url: URL
    public var importURL: URL

    public init(id: Int, remoteID: String, remoteName: String, email: String, name: String, url: URL, importURL: URL) {
        self.id = id
        self.remoteID = remoteID
        self.remoteName = remoteName
        self.email = email
        self.name = name
        self.url = url
        self.importURL = importURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.remoteID = try values.decode(String.self, forKey: "remote_id")
        self.remoteName = try values.decode(String.self, forKey: "remote_name")
        self.email = try values.decode(String.self, forKey: "email")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decode(URL.self, forKey: "url")
        self.importURL = try values.decode(URL.self, forKey: "import_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(remoteID, forKey: "remote_id")
        try values.encode(remoteName, forKey: "remote_name")
        try values.encode(email, forKey: "email")
        try values.encode(name, forKey: "name")
        try values.encode(url, forKey: "url")
        try values.encode(importURL, forKey: "import_url")
    }
}

public struct PorterLargeFile: Codable {
    public var refName: String
    public var path: String
    public var oid: String
    public var size: Int

    public init(refName: String, path: String, oid: String, size: Int) {
        self.refName = refName
        self.path = path
        self.oid = oid
        self.size = size
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.refName = try values.decode(String.self, forKey: "ref_name")
        self.path = try values.decode(String.self, forKey: "path")
        self.oid = try values.decode(String.self, forKey: "oid")
        self.size = try values.decode(Int.self, forKey: "size")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(refName, forKey: "ref_name")
        try values.encode(path, forKey: "path")
        try values.encode(oid, forKey: "oid")
        try values.encode(size, forKey: "size")
    }
}

public struct IssueEventLabel: Codable {
    public var name: String?
    public var color: String?

    public init(name: String? = nil, color: String? = nil) {
        self.name = name
        self.color = color
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.color = try values.decodeIfPresent(String.self, forKey: "color")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(color, forKey: "color")
    }
}

public struct IssueEventDismissedReview: Codable {
    public var state: String
    public var reviewID: Int
    public var dismissalMessage: String?
    public var dismissalCommitID: String?

    public init(state: String, reviewID: Int, dismissalMessage: String? = nil, dismissalCommitID: String? = nil) {
        self.state = state
        self.reviewID = reviewID
        self.dismissalMessage = dismissalMessage
        self.dismissalCommitID = dismissalCommitID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.state = try values.decode(String.self, forKey: "state")
        self.reviewID = try values.decode(Int.self, forKey: "review_id")
        self.dismissalMessage = try values.decodeIfPresent(String.self, forKey: "dismissal_message")
        self.dismissalCommitID = try values.decodeIfPresent(String.self, forKey: "dismissal_commit_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(state, forKey: "state")
        try values.encode(reviewID, forKey: "review_id")
        try values.encodeIfPresent(dismissalMessage, forKey: "dismissal_message")
        try values.encodeIfPresent(dismissalCommitID, forKey: "dismissal_commit_id")
    }
}

public struct IssueEventMilestone: Codable {
    public var title: String

    public init(title: String) {
        self.title = title
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.title = try values.decode(String.self, forKey: "title")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(title, forKey: "title")
    }
}

public struct IssueEventProjectCard: Codable {
    public var url: URL
    public var id: Int
    public var projectURL: URL
    public var projectID: Int
    public var columnName: String
    public var previousColumnName: String?

    public init(url: URL, id: Int, projectURL: URL, projectID: Int, columnName: String, previousColumnName: String? = nil) {
        self.url = url
        self.id = id
        self.projectURL = projectURL
        self.projectID = projectID
        self.columnName = columnName
        self.previousColumnName = previousColumnName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.projectURL = try values.decode(URL.self, forKey: "project_url")
        self.projectID = try values.decode(Int.self, forKey: "project_id")
        self.columnName = try values.decode(String.self, forKey: "column_name")
        self.previousColumnName = try values.decodeIfPresent(String.self, forKey: "previous_column_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(projectURL, forKey: "project_url")
        try values.encode(projectID, forKey: "project_id")
        try values.encode(columnName, forKey: "column_name")
        try values.encodeIfPresent(previousColumnName, forKey: "previous_column_name")
    }
}

public struct IssueEventRename: Codable {
    public var from: String
    public var to: String

    public init(from: String, to: String) {
        self.from = from
        self.to = to
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.from = try values.decode(String.self, forKey: "from")
        self.to = try values.decode(String.self, forKey: "to")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(from, forKey: "from")
        try values.encode(to, forKey: "to")
    }
}

public struct IssueEvent: Codable {
    public var id: Int
    /// Example: "MDEwOklzc3VlRXZlbnQx"
    public var nodeID: String
    /// Example: "https://api.github.com/repos/octocat/Hello-World/issues/events/1"
    public var url: URL
    /// Simple User
    public var actor: SimpleUser?
    /// Example: "closed"
    public var event: String
    /// Example: "6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var commitID: String?
    /// Example: "https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var commitURL: String?
    /// Example: "2011-04-14T16:00:49Z"
    public var createdAt: Date
    /// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
    public var issue: Issue?
    /// Issue Event Label
    public var label: IssueEventLabel?
    /// Simple User
    public var assignee: SimpleUser?
    /// Simple User
    public var assigner: SimpleUser?
    /// Simple User
    public var reviewRequester: SimpleUser?
    /// Simple User
    public var requestedReviewer: SimpleUser?
    /// Team
    ///
    /// Groups of organization members that gives permissions on specified repositories.
    public var requestedTeam: Team?
    /// Issue Event Dismissed Review
    public var dismissedReview: IssueEventDismissedReview?
    /// Issue Event Milestone
    public var milestone: IssueEventMilestone?
    /// Issue Event Project Card
    public var projectCard: IssueEventProjectCard?
    /// Issue Event Rename
    public var rename: IssueEventRename?
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation?
    public var lockReason: String?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?

    public init(id: Int, nodeID: String, url: URL, actor: SimpleUser? = nil, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: Date, issue: Issue? = nil, label: IssueEventLabel? = nil, assignee: SimpleUser? = nil, assigner: SimpleUser? = nil, reviewRequester: SimpleUser? = nil, requestedReviewer: SimpleUser? = nil, requestedTeam: Team? = nil, dismissedReview: IssueEventDismissedReview? = nil, milestone: IssueEventMilestone? = nil, projectCard: IssueEventProjectCard? = nil, rename: IssueEventRename? = nil, authorAssociation: AuthorAssociation? = nil, lockReason: String? = nil, performedViaGithubApp: Integration? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.issue = issue
        self.label = label
        self.assignee = assignee
        self.assigner = assigner
        self.reviewRequester = reviewRequester
        self.requestedReviewer = requestedReviewer
        self.requestedTeam = requestedTeam
        self.dismissedReview = dismissedReview
        self.milestone = milestone
        self.projectCard = projectCard
        self.rename = rename
        self.authorAssociation = authorAssociation
        self.lockReason = lockReason
        self.performedViaGithubApp = performedViaGithubApp
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.actor = try values.decodeIfPresent(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.issue = try values.decodeIfPresent(Issue.self, forKey: "issue")
        self.label = try values.decodeIfPresent(IssueEventLabel.self, forKey: "label")
        self.assignee = try values.decodeIfPresent(SimpleUser.self, forKey: "assignee")
        self.assigner = try values.decodeIfPresent(SimpleUser.self, forKey: "assigner")
        self.reviewRequester = try values.decodeIfPresent(SimpleUser.self, forKey: "review_requester")
        self.requestedReviewer = try values.decodeIfPresent(SimpleUser.self, forKey: "requested_reviewer")
        self.requestedTeam = try values.decodeIfPresent(Team.self, forKey: "requested_team")
        self.dismissedReview = try values.decodeIfPresent(IssueEventDismissedReview.self, forKey: "dismissed_review")
        self.milestone = try values.decodeIfPresent(IssueEventMilestone.self, forKey: "milestone")
        self.projectCard = try values.decodeIfPresent(IssueEventProjectCard.self, forKey: "project_card")
        self.rename = try values.decodeIfPresent(IssueEventRename.self, forKey: "rename")
        self.authorAssociation = try values.decodeIfPresent(AuthorAssociation.self, forKey: "author_association")
        self.lockReason = try values.decodeIfPresent(String.self, forKey: "lock_reason")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(issue, forKey: "issue")
        try values.encodeIfPresent(label, forKey: "label")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(assigner, forKey: "assigner")
        try values.encodeIfPresent(reviewRequester, forKey: "review_requester")
        try values.encodeIfPresent(requestedReviewer, forKey: "requested_reviewer")
        try values.encodeIfPresent(requestedTeam, forKey: "requested_team")
        try values.encodeIfPresent(dismissedReview, forKey: "dismissed_review")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encodeIfPresent(projectCard, forKey: "project_card")
        try values.encodeIfPresent(rename, forKey: "rename")
        try values.encodeIfPresent(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(lockReason, forKey: "lock_reason")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
    }
}

public struct LabeledIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var label: Label

    public struct Label: Codable {
        public var name: String
        public var color: String

        public init(name: String, color: String) {
            self.name = name
            self.color = color
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.color = try values.decode(String.self, forKey: "color")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(color, forKey: "color")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, label: Label) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.label = label
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.label = try values.decode(Label.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(label, forKey: "label")
    }
}

public struct UnlabeledIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var label: Label

    public struct Label: Codable {
        public var name: String
        public var color: String

        public init(name: String, color: String) {
            self.name = name
            self.color = color
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.color = try values.decode(String.self, forKey: "color")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(color, forKey: "color")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, label: Label) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.label = label
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.label = try values.decode(Label.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(label, forKey: "label")
    }
}

public struct AssignedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration
    /// Simple User
    public var assignee: SimpleUser
    /// Simple User
    public var assigner: SimpleUser

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration, assignee: SimpleUser, assigner: SimpleUser) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.assignee = assignee
        self.assigner = assigner
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decode(Integration.self, forKey: "performed_via_github_app")
        self.assignee = try values.decode(SimpleUser.self, forKey: "assignee")
        self.assigner = try values.decode(SimpleUser.self, forKey: "assigner")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(assignee, forKey: "assignee")
        try values.encode(assigner, forKey: "assigner")
    }
}

public struct UnassignedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Simple User
    public var assignee: SimpleUser
    /// Simple User
    public var assigner: SimpleUser

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, assignee: SimpleUser, assigner: SimpleUser) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.assignee = assignee
        self.assigner = assigner
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.assignee = try values.decode(SimpleUser.self, forKey: "assignee")
        self.assigner = try values.decode(SimpleUser.self, forKey: "assigner")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(assignee, forKey: "assignee")
        try values.encode(assigner, forKey: "assigner")
    }
}

public struct MilestonedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var milestone: Milestone

    public struct Milestone: Codable {
        public var title: String

        public init(title: String) {
            self.title = title
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.title = try values.decode(String.self, forKey: "title")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(title, forKey: "title")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, milestone: Milestone) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.milestone = milestone
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.milestone = try values.decode(Milestone.self, forKey: "milestone")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(milestone, forKey: "milestone")
    }
}

public struct DemilestonedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var milestone: Milestone

    public struct Milestone: Codable {
        public var title: String

        public init(title: String) {
            self.title = title
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.title = try values.decode(String.self, forKey: "title")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(title, forKey: "title")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, milestone: Milestone) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.milestone = milestone
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.milestone = try values.decode(Milestone.self, forKey: "milestone")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(milestone, forKey: "milestone")
    }
}

public struct RenamedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var rename: Rename

    public struct Rename: Codable {
        public var from: String
        public var to: String

        public init(from: String, to: String) {
            self.from = from
            self.to = to
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.from = try values.decode(String.self, forKey: "from")
            self.to = try values.decode(String.self, forKey: "to")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(from, forKey: "from")
            try values.encode(to, forKey: "to")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, rename: Rename) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.rename = rename
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.rename = try values.decode(Rename.self, forKey: "rename")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(rename, forKey: "rename")
    }
}

public struct ReviewRequestedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Simple User
    public var reviewRequester: SimpleUser
    /// Team
    ///
    /// Groups of organization members that gives permissions on specified repositories.
    public var requestedTeam: Team?
    /// Simple User
    public var requestedReviewer: SimpleUser?

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, reviewRequester: SimpleUser, requestedTeam: Team? = nil, requestedReviewer: SimpleUser? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.reviewRequester = reviewRequester
        self.requestedTeam = requestedTeam
        self.requestedReviewer = requestedReviewer
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.reviewRequester = try values.decode(SimpleUser.self, forKey: "review_requester")
        self.requestedTeam = try values.decodeIfPresent(Team.self, forKey: "requested_team")
        self.requestedReviewer = try values.decodeIfPresent(SimpleUser.self, forKey: "requested_reviewer")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(reviewRequester, forKey: "review_requester")
        try values.encodeIfPresent(requestedTeam, forKey: "requested_team")
        try values.encodeIfPresent(requestedReviewer, forKey: "requested_reviewer")
    }
}

public struct ReviewRequestRemovedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Simple User
    public var reviewRequester: SimpleUser
    /// Team
    ///
    /// Groups of organization members that gives permissions on specified repositories.
    public var requestedTeam: Team?
    /// Simple User
    public var requestedReviewer: SimpleUser?

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, reviewRequester: SimpleUser, requestedTeam: Team? = nil, requestedReviewer: SimpleUser? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.reviewRequester = reviewRequester
        self.requestedTeam = requestedTeam
        self.requestedReviewer = requestedReviewer
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.reviewRequester = try values.decode(SimpleUser.self, forKey: "review_requester")
        self.requestedTeam = try values.decodeIfPresent(Team.self, forKey: "requested_team")
        self.requestedReviewer = try values.decodeIfPresent(SimpleUser.self, forKey: "requested_reviewer")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(reviewRequester, forKey: "review_requester")
        try values.encodeIfPresent(requestedTeam, forKey: "requested_team")
        try values.encodeIfPresent(requestedReviewer, forKey: "requested_reviewer")
    }
}

public struct ReviewDismissedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var dismissedReview: DismissedReview

    public struct DismissedReview: Codable {
        public var state: String
        public var reviewID: Int
        public var dismissalMessage: String?
        public var dismissalCommitID: String?

        public init(state: String, reviewID: Int, dismissalMessage: String? = nil, dismissalCommitID: String? = nil) {
            self.state = state
            self.reviewID = reviewID
            self.dismissalMessage = dismissalMessage
            self.dismissalCommitID = dismissalCommitID
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.state = try values.decode(String.self, forKey: "state")
            self.reviewID = try values.decode(Int.self, forKey: "review_id")
            self.dismissalMessage = try values.decodeIfPresent(String.self, forKey: "dismissal_message")
            self.dismissalCommitID = try values.decodeIfPresent(String.self, forKey: "dismissal_commit_id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(state, forKey: "state")
            try values.encode(reviewID, forKey: "review_id")
            try values.encodeIfPresent(dismissalMessage, forKey: "dismissal_message")
            try values.encodeIfPresent(dismissalCommitID, forKey: "dismissal_commit_id")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, dismissedReview: DismissedReview) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.dismissedReview = dismissedReview
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.dismissedReview = try values.decode(DismissedReview.self, forKey: "dismissed_review")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(dismissedReview, forKey: "dismissed_review")
    }
}

public struct LockedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Example: "off-topic"
    public var lockReason: String?

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, lockReason: String? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.lockReason = lockReason
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.lockReason = try values.decodeIfPresent(String.self, forKey: "lock_reason")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(lockReason, forKey: "lock_reason")
    }
}

public struct AddedToProjectIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var projectCard: ProjectCard?

    public struct ProjectCard: Codable {
        public var id: Int
        public var url: URL
        public var projectID: Int
        public var projectURL: URL
        public var columnName: String
        public var previousColumnName: String?

        public init(id: Int, url: URL, projectID: Int, projectURL: URL, columnName: String, previousColumnName: String? = nil) {
            self.id = id
            self.url = url
            self.projectID = projectID
            self.projectURL = projectURL
            self.columnName = columnName
            self.previousColumnName = previousColumnName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.url = try values.decode(URL.self, forKey: "url")
            self.projectID = try values.decode(Int.self, forKey: "project_id")
            self.projectURL = try values.decode(URL.self, forKey: "project_url")
            self.columnName = try values.decode(String.self, forKey: "column_name")
            self.previousColumnName = try values.decodeIfPresent(String.self, forKey: "previous_column_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(url, forKey: "url")
            try values.encode(projectID, forKey: "project_id")
            try values.encode(projectURL, forKey: "project_url")
            try values.encode(columnName, forKey: "column_name")
            try values.encodeIfPresent(previousColumnName, forKey: "previous_column_name")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, projectCard: ProjectCard? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.projectCard = projectCard
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.projectCard = try values.decodeIfPresent(ProjectCard.self, forKey: "project_card")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(projectCard, forKey: "project_card")
    }
}

public struct MovedColumnInProjectIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var projectCard: ProjectCard?

    public struct ProjectCard: Codable {
        public var id: Int
        public var url: URL
        public var projectID: Int
        public var projectURL: URL
        public var columnName: String
        public var previousColumnName: String?

        public init(id: Int, url: URL, projectID: Int, projectURL: URL, columnName: String, previousColumnName: String? = nil) {
            self.id = id
            self.url = url
            self.projectID = projectID
            self.projectURL = projectURL
            self.columnName = columnName
            self.previousColumnName = previousColumnName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.url = try values.decode(URL.self, forKey: "url")
            self.projectID = try values.decode(Int.self, forKey: "project_id")
            self.projectURL = try values.decode(URL.self, forKey: "project_url")
            self.columnName = try values.decode(String.self, forKey: "column_name")
            self.previousColumnName = try values.decodeIfPresent(String.self, forKey: "previous_column_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(url, forKey: "url")
            try values.encode(projectID, forKey: "project_id")
            try values.encode(projectURL, forKey: "project_url")
            try values.encode(columnName, forKey: "column_name")
            try values.encodeIfPresent(previousColumnName, forKey: "previous_column_name")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, projectCard: ProjectCard? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.projectCard = projectCard
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.projectCard = try values.decodeIfPresent(ProjectCard.self, forKey: "project_card")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(projectCard, forKey: "project_card")
    }
}

public struct RemovedFromProjectIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    public var projectCard: ProjectCard?

    public struct ProjectCard: Codable {
        public var id: Int
        public var url: URL
        public var projectID: Int
        public var projectURL: URL
        public var columnName: String
        public var previousColumnName: String?

        public init(id: Int, url: URL, projectID: Int, projectURL: URL, columnName: String, previousColumnName: String? = nil) {
            self.id = id
            self.url = url
            self.projectID = projectID
            self.projectURL = projectURL
            self.columnName = columnName
            self.previousColumnName = previousColumnName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.url = try values.decode(URL.self, forKey: "url")
            self.projectID = try values.decode(Int.self, forKey: "project_id")
            self.projectURL = try values.decode(URL.self, forKey: "project_url")
            self.columnName = try values.decode(String.self, forKey: "column_name")
            self.previousColumnName = try values.decodeIfPresent(String.self, forKey: "previous_column_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(url, forKey: "url")
            try values.encode(projectID, forKey: "project_id")
            try values.encode(projectURL, forKey: "project_url")
            try values.encode(columnName, forKey: "column_name")
            try values.encodeIfPresent(previousColumnName, forKey: "previous_column_name")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, projectCard: ProjectCard? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.projectCard = projectCard
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.projectCard = try values.decodeIfPresent(ProjectCard.self, forKey: "project_card")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(projectCard, forKey: "project_card")
    }
}

public struct ConvertedNoteToIssueIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration
    public var projectCard: ProjectCard?

    public struct ProjectCard: Codable {
        public var id: Int
        public var url: URL
        public var projectID: Int
        public var projectURL: URL
        public var columnName: String
        public var previousColumnName: String?

        public init(id: Int, url: URL, projectID: Int, projectURL: URL, columnName: String, previousColumnName: String? = nil) {
            self.id = id
            self.url = url
            self.projectID = projectID
            self.projectURL = projectURL
            self.columnName = columnName
            self.previousColumnName = previousColumnName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.url = try values.decode(URL.self, forKey: "url")
            self.projectID = try values.decode(Int.self, forKey: "project_id")
            self.projectURL = try values.decode(URL.self, forKey: "project_url")
            self.columnName = try values.decode(String.self, forKey: "column_name")
            self.previousColumnName = try values.decodeIfPresent(String.self, forKey: "previous_column_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(url, forKey: "url")
            try values.encode(projectID, forKey: "project_id")
            try values.encode(projectURL, forKey: "project_url")
            try values.encode(columnName, forKey: "column_name")
            try values.encodeIfPresent(previousColumnName, forKey: "previous_column_name")
        }
    }

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration, projectCard: ProjectCard? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.projectCard = projectCard
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decode(Integration.self, forKey: "performed_via_github_app")
        self.projectCard = try values.decodeIfPresent(ProjectCard.self, forKey: "project_card")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(projectCard, forKey: "project_card")
    }
}

public struct IssueEventForIssue: Codable {
    public var labeledIssueEvent: LabeledIssueEvent?
    public var unlabeledIssueEvent: UnlabeledIssueEvent?
    public var assignedIssueEvent: AssignedIssueEvent?
    public var unassignedIssueEvent: UnassignedIssueEvent?
    public var milestonedIssueEvent: MilestonedIssueEvent?
    public var demilestonedIssueEvent: DemilestonedIssueEvent?
    public var renamedIssueEvent: RenamedIssueEvent?
    public var reviewRequestedIssueEvent: ReviewRequestedIssueEvent?
    public var reviewRequestRemovedIssueEvent: ReviewRequestRemovedIssueEvent?
    public var reviewDismissedIssueEvent: ReviewDismissedIssueEvent?
    public var lockedIssueEvent: LockedIssueEvent?
    public var addedToProjectIssueEvent: AddedToProjectIssueEvent?
    public var movedColumnInProjectIssueEvent: MovedColumnInProjectIssueEvent?
    public var removedFromProjectIssueEvent: RemovedFromProjectIssueEvent?
    public var convertedNoteToIssueIssueEvent: ConvertedNoteToIssueIssueEvent?

    public init(labeledIssueEvent: LabeledIssueEvent? = nil, unlabeledIssueEvent: UnlabeledIssueEvent? = nil, assignedIssueEvent: AssignedIssueEvent? = nil, unassignedIssueEvent: UnassignedIssueEvent? = nil, milestonedIssueEvent: MilestonedIssueEvent? = nil, demilestonedIssueEvent: DemilestonedIssueEvent? = nil, renamedIssueEvent: RenamedIssueEvent? = nil, reviewRequestedIssueEvent: ReviewRequestedIssueEvent? = nil, reviewRequestRemovedIssueEvent: ReviewRequestRemovedIssueEvent? = nil, reviewDismissedIssueEvent: ReviewDismissedIssueEvent? = nil, lockedIssueEvent: LockedIssueEvent? = nil, addedToProjectIssueEvent: AddedToProjectIssueEvent? = nil, movedColumnInProjectIssueEvent: MovedColumnInProjectIssueEvent? = nil, removedFromProjectIssueEvent: RemovedFromProjectIssueEvent? = nil, convertedNoteToIssueIssueEvent: ConvertedNoteToIssueIssueEvent? = nil) {
        self.labeledIssueEvent = labeledIssueEvent
        self.unlabeledIssueEvent = unlabeledIssueEvent
        self.assignedIssueEvent = assignedIssueEvent
        self.unassignedIssueEvent = unassignedIssueEvent
        self.milestonedIssueEvent = milestonedIssueEvent
        self.demilestonedIssueEvent = demilestonedIssueEvent
        self.renamedIssueEvent = renamedIssueEvent
        self.reviewRequestedIssueEvent = reviewRequestedIssueEvent
        self.reviewRequestRemovedIssueEvent = reviewRequestRemovedIssueEvent
        self.reviewDismissedIssueEvent = reviewDismissedIssueEvent
        self.lockedIssueEvent = lockedIssueEvent
        self.addedToProjectIssueEvent = addedToProjectIssueEvent
        self.movedColumnInProjectIssueEvent = movedColumnInProjectIssueEvent
        self.removedFromProjectIssueEvent = removedFromProjectIssueEvent
        self.convertedNoteToIssueIssueEvent = convertedNoteToIssueIssueEvent
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.labeledIssueEvent = try? container.decode(LabeledIssueEvent.self)
        self.unlabeledIssueEvent = try? container.decode(UnlabeledIssueEvent.self)
        self.assignedIssueEvent = try? container.decode(AssignedIssueEvent.self)
        self.unassignedIssueEvent = try? container.decode(UnassignedIssueEvent.self)
        self.milestonedIssueEvent = try? container.decode(MilestonedIssueEvent.self)
        self.demilestonedIssueEvent = try? container.decode(DemilestonedIssueEvent.self)
        self.renamedIssueEvent = try? container.decode(RenamedIssueEvent.self)
        self.reviewRequestedIssueEvent = try? container.decode(ReviewRequestedIssueEvent.self)
        self.reviewRequestRemovedIssueEvent = try? container.decode(ReviewRequestRemovedIssueEvent.self)
        self.reviewDismissedIssueEvent = try? container.decode(ReviewDismissedIssueEvent.self)
        self.lockedIssueEvent = try? container.decode(LockedIssueEvent.self)
        self.addedToProjectIssueEvent = try? container.decode(AddedToProjectIssueEvent.self)
        self.movedColumnInProjectIssueEvent = try? container.decode(MovedColumnInProjectIssueEvent.self)
        self.removedFromProjectIssueEvent = try? container.decode(RemovedFromProjectIssueEvent.self)
        self.convertedNoteToIssueIssueEvent = try? container.decode(ConvertedNoteToIssueIssueEvent.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = labeledIssueEvent { try container.encode(value) }
        if let value = unlabeledIssueEvent { try container.encode(value) }
        if let value = assignedIssueEvent { try container.encode(value) }
        if let value = unassignedIssueEvent { try container.encode(value) }
        if let value = milestonedIssueEvent { try container.encode(value) }
        if let value = demilestonedIssueEvent { try container.encode(value) }
        if let value = renamedIssueEvent { try container.encode(value) }
        if let value = reviewRequestedIssueEvent { try container.encode(value) }
        if let value = reviewRequestRemovedIssueEvent { try container.encode(value) }
        if let value = reviewDismissedIssueEvent { try container.encode(value) }
        if let value = lockedIssueEvent { try container.encode(value) }
        if let value = addedToProjectIssueEvent { try container.encode(value) }
        if let value = movedColumnInProjectIssueEvent { try container.encode(value) }
        if let value = removedFromProjectIssueEvent { try container.encode(value) }
        if let value = convertedNoteToIssueIssueEvent { try container.encode(value) }
    }
}

/// Color-coded labels help you categorize and filter your issues (just like labels in Gmail).
public struct Label: Codable {
    /// Example: 208045946
    public var id: Int
    /// Example: "MDU6TGFiZWwyMDgwNDU5NDY="
    public var nodeID: String
    /// URL for the label
    ///
    /// Example: "https://api.github.com/repositories/42/labels/bug"
    public var url: URL
    /// The name of the label.
    ///
    /// Example: "bug"
    public var name: String
    /// Example: "Something isn't working"
    public var description: String?
    /// 6-character hex code, without the leading #, identifying the color
    ///
    /// Example: "FFFFFF"
    public var color: String
    /// Example: true
    public var isDefault: Bool

    public init(id: Int, nodeID: String, url: URL, name: String, description: String? = nil, color: String, isDefault: Bool) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.name = name
        self.description = description
        self.color = color
        self.isDefault = isDefault
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.name = try values.decode(String.self, forKey: "name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.color = try values.decode(String.self, forKey: "color")
        self.isDefault = try values.decode(Bool.self, forKey: "default")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(color, forKey: "color")
        try values.encode(isDefault, forKey: "default")
    }
}

public struct TimelineCommentEvent: Codable {
    public var event: String
    /// Simple User
    public var actor: SimpleUser
    /// Unique identifier of the issue comment
    ///
    /// Example: 42
    public var id: Int
    public var nodeID: String
    /// URL for the issue comment
    ///
    /// Example: "https://api.github.com/repositories/42/issues/comments/1"
    public var url: URL
    /// Contents of the issue comment
    ///
    /// Example: "What version of Safari were you using when you observed this bug?"
    public var body: String?
    public var bodyText: String?
    public var bodyHTML: String?
    public var htmlURL: URL
    /// Simple User
    public var user: SimpleUser
    /// Example: "2011-04-14T16:00:49Z"
    public var createdAt: Date
    /// Example: "2011-04-14T16:00:49Z"
    public var updatedAt: Date
    public var issueURL: URL
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(event: String, actor: SimpleUser, id: Int, nodeID: String, url: URL, body: String? = nil, bodyText: String? = nil, bodyHTML: String? = nil, htmlURL: URL, user: SimpleUser, createdAt: Date, updatedAt: Date, issueURL: URL, authorAssociation: AuthorAssociation, performedViaGithubApp: Integration? = nil, reactions: ReactionRollup? = nil) {
        self.event = event
        self.actor = actor
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.body = body
        self.bodyText = bodyText
        self.bodyHTML = bodyHTML
        self.htmlURL = htmlURL
        self.user = user
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.issueURL = issueURL
        self.authorAssociation = authorAssociation
        self.performedViaGithubApp = performedViaGithubApp
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decode(String.self, forKey: "event")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.user = try values.decode(SimpleUser.self, forKey: "user")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.issueURL = try values.decode(URL.self, forKey: "issue_url")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(event, forKey: "event")
        try values.encode(actor, forKey: "actor")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(user, forKey: "user")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(issueURL, forKey: "issue_url")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

public struct TimelineCrossReferencedEvent: Codable {
    public var event: String
    /// Simple User
    public var actor: SimpleUser?
    public var createdAt: Date
    public var updatedAt: Date
    public var source: Source

    public struct Source: Codable {
        public var type: String?
        /// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
        public var issue: Issue?

        public init(type: String? = nil, issue: Issue? = nil) {
            self.type = type
            self.issue = issue
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.issue = try values.decodeIfPresent(Issue.self, forKey: "issue")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(issue, forKey: "issue")
        }
    }

    public init(event: String, actor: SimpleUser? = nil, createdAt: Date, updatedAt: Date, source: Source) {
        self.event = event
        self.actor = actor
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.source = source
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decode(String.self, forKey: "event")
        self.actor = try values.decodeIfPresent(SimpleUser.self, forKey: "actor")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.source = try values.decode(Source.self, forKey: "source")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(actor, forKey: "actor")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(source, forKey: "source")
    }
}

public struct TimelineCommittedEvent: Codable {
    public var event: String?
    /// SHA for the commit
    ///
    /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
    public var sha: String
    public var nodeID: String
    public var url: URL
    /// Identifying information for the git-user
    public var author: Author
    /// Identifying information for the git-user
    public var committer: Committer
    /// Message describing the purpose of the commit
    ///
    /// Example: "Fix #42"
    public var message: String
    public var tree: Tree
    public var parents: [Parent]
    public var verification: Verification
    public var htmlURL: URL

    /// Identifying information for the git-user
    public struct Author: Codable {
        /// Timestamp of the commit
        ///
        /// Example: "2014-08-09T08:02:04+12:00"
        public var date: Date
        /// Git email address of the user
        ///
        /// Example: "monalisa.octocat@example.com"
        public var email: String
        /// Name of the git user
        ///
        /// Example: "Monalisa Octocat"
        public var name: String

        public init(date: Date, email: String, name: String) {
            self.date = date
            self.email = email
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
        }
    }

    /// Identifying information for the git-user
    public struct Committer: Codable {
        /// Timestamp of the commit
        ///
        /// Example: "2014-08-09T08:02:04+12:00"
        public var date: Date
        /// Git email address of the user
        ///
        /// Example: "monalisa.octocat@example.com"
        public var email: String
        /// Name of the git user
        ///
        /// Example: "Monalisa Octocat"
        public var name: String

        public init(date: Date, email: String, name: String) {
            self.date = date
            self.email = email
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
        }
    }

    public struct Tree: Codable {
        /// SHA for the commit
        ///
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        public var url: URL

        public init(sha: String, url: URL) {
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public struct Parent: Codable {
        /// SHA for the commit
        ///
        /// Example: "7638417db6d59f3c431d3e1f261cc637155684cd"
        public var sha: String
        public var url: URL
        public var htmlURL: URL

        public init(sha: String, url: URL, htmlURL: URL) {
            self.sha = sha
            self.url = url
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
            self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
            try values.encode(htmlURL, forKey: "html_url")
        }
    }

    public struct Verification: Codable {
        public var isVerified: Bool
        public var reason: String
        public var signature: String?
        public var payload: String?

        public init(isVerified: Bool, reason: String, signature: String? = nil, payload: String? = nil) {
            self.isVerified = isVerified
            self.reason = reason
            self.signature = signature
            self.payload = payload
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isVerified = try values.decode(Bool.self, forKey: "verified")
            self.reason = try values.decode(String.self, forKey: "reason")
            self.signature = try values.decodeIfPresent(String.self, forKey: "signature")
            self.payload = try values.decodeIfPresent(String.self, forKey: "payload")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isVerified, forKey: "verified")
            try values.encode(reason, forKey: "reason")
            try values.encodeIfPresent(signature, forKey: "signature")
            try values.encodeIfPresent(payload, forKey: "payload")
        }
    }

    public init(event: String? = nil, sha: String, nodeID: String, url: URL, author: Author, committer: Committer, message: String, tree: Tree, parents: [Parent], verification: Verification, htmlURL: URL) {
        self.event = event
        self.sha = sha
        self.nodeID = nodeID
        self.url = url
        self.author = author
        self.committer = committer
        self.message = message
        self.tree = tree
        self.parents = parents
        self.verification = verification
        self.htmlURL = htmlURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decodeIfPresent(String.self, forKey: "event")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.author = try values.decode(Author.self, forKey: "author")
        self.committer = try values.decode(Committer.self, forKey: "committer")
        self.message = try values.decode(String.self, forKey: "message")
        self.tree = try values.decode(Tree.self, forKey: "tree")
        self.parents = try values.decode([Parent].self, forKey: "parents")
        self.verification = try values.decode(Verification.self, forKey: "verification")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(event, forKey: "event")
        try values.encode(sha, forKey: "sha")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(author, forKey: "author")
        try values.encode(committer, forKey: "committer")
        try values.encode(message, forKey: "message")
        try values.encode(tree, forKey: "tree")
        try values.encode(parents, forKey: "parents")
        try values.encode(verification, forKey: "verification")
        try values.encode(htmlURL, forKey: "html_url")
    }
}

public struct TimelineReviewedEvent: Codable {
    public var event: String
    /// Unique identifier of the review
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA="
    public var nodeID: String
    /// Simple User
    public var user: SimpleUser
    /// The text of the review.
    ///
    /// Example: "This looks great."
    public var body: String?
    /// Example: "CHANGES_REQUESTED"
    public var state: String
    /// Example: "https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80"
    public var htmlURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/12"
    public var pullRequestURL: URL
    public var links: Links
    public var submittedAt: Date?
    /// A commit SHA for the review.
    ///
    /// Example: "54bb654c9e6025347f57900a4a5c2313a96b8035"
    public var commitID: String
    public var bodyHTML: String?
    public var bodyText: String?
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation

    public struct Links: Codable {
        public var html: HTML
        public var pullRequest: PullRequest

        public struct HTML: Codable {
            public var href: String

            public init(href: String) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(String.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public struct PullRequest: Codable {
            public var href: String

            public init(href: String) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(String.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public init(html: HTML, pullRequest: PullRequest) {
            self.html = html
            self.pullRequest = pullRequest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.html = try values.decode(HTML.self, forKey: "html")
            self.pullRequest = try values.decode(PullRequest.self, forKey: "pull_request")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(html, forKey: "html")
            try values.encode(pullRequest, forKey: "pull_request")
        }
    }

    public init(event: String, id: Int, nodeID: String, user: SimpleUser, body: String? = nil, state: String, htmlURL: URL, pullRequestURL: URL, links: Links, submittedAt: Date? = nil, commitID: String, bodyHTML: String? = nil, bodyText: String? = nil, authorAssociation: AuthorAssociation) {
        self.event = event
        self.id = id
        self.nodeID = nodeID
        self.user = user
        self.body = body
        self.state = state
        self.htmlURL = htmlURL
        self.pullRequestURL = pullRequestURL
        self.links = links
        self.submittedAt = submittedAt
        self.commitID = commitID
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
        self.authorAssociation = authorAssociation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decode(String.self, forKey: "event")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.user = try values.decode(SimpleUser.self, forKey: "user")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.state = try values.decode(String.self, forKey: "state")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.pullRequestURL = try values.decode(URL.self, forKey: "pull_request_url")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.submittedAt = try values.decodeIfPresent(Date.self, forKey: "submitted_at")
        self.commitID = try values.decode(String.self, forKey: "commit_id")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(event, forKey: "event")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(user, forKey: "user")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(state, forKey: "state")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(pullRequestURL, forKey: "pull_request_url")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(submittedAt, forKey: "submitted_at")
        try values.encode(commitID, forKey: "commit_id")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encode(authorAssociation, forKey: "author_association")
    }
}

/// Pull Request Review Comments are comments on a portion of the Pull Request's diff.
public struct PullRequestReviewComment: Codable {
    /// URL for the pull request review comment
    ///
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/comments/1"
    public var url: String
    /// The ID of the pull request review to which the comment belongs.
    ///
    /// Example: 42
    public var pullRequestReviewID: Int?
    /// The ID of the pull request review comment.
    public var id: Int
    /// The node ID of the pull request review comment.
    ///
    /// Example: "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw"
    public var nodeID: String
    /// The diff of the line that the comment refers to.
    ///
    /// Example: "@@ -16,33 +16,40 @@ public class Connection : IConnection..."
    public var diffHunk: String
    /// The relative path of the file to which the comment applies.
    ///
    /// Example: "config/database.yaml"
    public var path: String
    /// The line index in the diff to which the comment applies.
    public var position: Int
    /// The index of the original line in the diff to which the comment applies.
    public var originalPosition: Int
    /// The SHA of the commit to which the comment applies.
    ///
    /// Example: "6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var commitID: String
    /// The SHA of the original commit to which the comment applies.
    ///
    /// Example: "9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840"
    public var originalCommitID: String
    /// The comment ID to reply to.
    public var inReplyToID: Int?
    /// Simple User
    public var user: SimpleUser
    /// The text of the comment.
    ///
    /// Example: "We should probably include a check for null values here."
    public var body: String
    /// Example: "2011-04-14T16:00:49Z"
    public var createdAt: Date
    /// Example: "2011-04-14T16:00:49Z"
    public var updatedAt: Date
    /// HTML URL for the pull request review comment.
    ///
    /// Example: "https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"
    public var htmlURL: URL
    /// URL for the pull request that the review comment belongs to.
    ///
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1"
    public var pullRequestURL: URL
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    public var links: Links
    /// The first line of the range for a multi-line comment.
    public var startLine: Int?
    /// The first line of the range for a multi-line comment.
    public var originalStartLine: Int?
    /// The side of the first line of the range for a multi-line comment.
    public var startSide: StartSide?
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    public var line: Int?
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    public var originalLine: Int?
    /// The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
    public var side: Side?
    /// Reaction Rollup
    public var reactions: ReactionRollup?
    /// Example: "<p>comment body</p>"
    public var bodyHTML: String?
    /// Example: "comment body"
    public var bodyText: String?

    public struct Links: Codable {
        public var this: `Self`
        public var html: HTML
        public var pullRequest: PullRequest

        public struct `Self`: Codable {
            /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/comments/1"
            public var href: URL

            public init(href: URL) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(URL.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public struct HTML: Codable {
            /// Example: "https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"
            public var href: URL

            public init(href: URL) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(URL.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public struct PullRequest: Codable {
            /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1"
            public var href: URL

            public init(href: URL) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(URL.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public init(this: `Self`, html: HTML, pullRequest: PullRequest) {
            self.this = this
            self.html = html
            self.pullRequest = pullRequest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.this = try values.decode(`Self`.self, forKey: "self")
            self.html = try values.decode(HTML.self, forKey: "html")
            self.pullRequest = try values.decode(PullRequest.self, forKey: "pull_request")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(this, forKey: "self")
            try values.encode(html, forKey: "html")
            try values.encode(pullRequest, forKey: "pull_request")
        }
    }

    /// The side of the first line of the range for a multi-line comment.
    public enum StartSide: String, Codable, CaseIterable {
        case left = "LEFT"
        case right = "RIGHT"
    }

    /// The side of the diff to which the comment applies. The side of the last line of the range for a multi-line comment
    public enum Side: String, Codable, CaseIterable {
        case left = "LEFT"
        case right = "RIGHT"
    }

    public init(url: String, pullRequestReviewID: Int? = nil, id: Int, nodeID: String, diffHunk: String, path: String, position: Int, originalPosition: Int, commitID: String, originalCommitID: String, inReplyToID: Int? = nil, user: SimpleUser, body: String, createdAt: Date, updatedAt: Date, htmlURL: URL, pullRequestURL: URL, authorAssociation: AuthorAssociation, links: Links, startLine: Int? = nil, originalStartLine: Int? = nil, startSide: StartSide? = nil, line: Int? = nil, originalLine: Int? = nil, side: Side? = nil, reactions: ReactionRollup? = nil, bodyHTML: String? = nil, bodyText: String? = nil) {
        self.url = url
        self.pullRequestReviewID = pullRequestReviewID
        self.id = id
        self.nodeID = nodeID
        self.diffHunk = diffHunk
        self.path = path
        self.position = position
        self.originalPosition = originalPosition
        self.commitID = commitID
        self.originalCommitID = originalCommitID
        self.inReplyToID = inReplyToID
        self.user = user
        self.body = body
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.htmlURL = htmlURL
        self.pullRequestURL = pullRequestURL
        self.authorAssociation = authorAssociation
        self.links = links
        self.startLine = startLine
        self.originalStartLine = originalStartLine
        self.startSide = startSide
        self.line = line
        self.originalLine = originalLine
        self.side = side
        self.reactions = reactions
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(String.self, forKey: "url")
        self.pullRequestReviewID = try values.decodeIfPresent(Int.self, forKey: "pull_request_review_id")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.diffHunk = try values.decode(String.self, forKey: "diff_hunk")
        self.path = try values.decode(String.self, forKey: "path")
        self.position = try values.decode(Int.self, forKey: "position")
        self.originalPosition = try values.decode(Int.self, forKey: "original_position")
        self.commitID = try values.decode(String.self, forKey: "commit_id")
        self.originalCommitID = try values.decode(String.self, forKey: "original_commit_id")
        self.inReplyToID = try values.decodeIfPresent(Int.self, forKey: "in_reply_to_id")
        self.user = try values.decode(SimpleUser.self, forKey: "user")
        self.body = try values.decode(String.self, forKey: "body")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.pullRequestURL = try values.decode(URL.self, forKey: "pull_request_url")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.startLine = try values.decodeIfPresent(Int.self, forKey: "start_line")
        self.originalStartLine = try values.decodeIfPresent(Int.self, forKey: "original_start_line")
        self.startSide = try values.decodeIfPresent(StartSide.self, forKey: "start_side")
        self.line = try values.decodeIfPresent(Int.self, forKey: "line")
        self.originalLine = try values.decodeIfPresent(Int.self, forKey: "original_line")
        self.side = try values.decodeIfPresent(Side.self, forKey: "side")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(pullRequestReviewID, forKey: "pull_request_review_id")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(diffHunk, forKey: "diff_hunk")
        try values.encode(path, forKey: "path")
        try values.encode(position, forKey: "position")
        try values.encode(originalPosition, forKey: "original_position")
        try values.encode(commitID, forKey: "commit_id")
        try values.encode(originalCommitID, forKey: "original_commit_id")
        try values.encodeIfPresent(inReplyToID, forKey: "in_reply_to_id")
        try values.encode(user, forKey: "user")
        try values.encode(body, forKey: "body")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(pullRequestURL, forKey: "pull_request_url")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(startLine, forKey: "start_line")
        try values.encodeIfPresent(originalStartLine, forKey: "original_start_line")
        try values.encodeIfPresent(startSide, forKey: "start_side")
        try values.encodeIfPresent(line, forKey: "line")
        try values.encodeIfPresent(originalLine, forKey: "original_line")
        try values.encodeIfPresent(side, forKey: "side")
        try values.encodeIfPresent(reactions, forKey: "reactions")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
    }
}

public struct TimelineLineCommentedEvent: Codable {
    public var event: String?
    public var nodeID: String?
    public var comments: [PullRequestReviewComment]?

    public init(event: String? = nil, nodeID: String? = nil, comments: [PullRequestReviewComment]? = nil) {
        self.event = event
        self.nodeID = nodeID
        self.comments = comments
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decodeIfPresent(String.self, forKey: "event")
        self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        self.comments = try values.decodeIfPresent([PullRequestReviewComment].self, forKey: "comments")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(event, forKey: "event")
        try values.encodeIfPresent(nodeID, forKey: "node_id")
        try values.encodeIfPresent(comments, forKey: "comments")
    }
}

public struct TimelineCommitCommentedEvent: Codable {
    public var event: String?
    public var nodeID: String?
    public var commitID: String?
    public var comments: [CommitComment]?

    public init(event: String? = nil, nodeID: String? = nil, commitID: String? = nil, comments: [CommitComment]? = nil) {
        self.event = event
        self.nodeID = nodeID
        self.commitID = commitID
        self.comments = comments
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.event = try values.decodeIfPresent(String.self, forKey: "event")
        self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.comments = try values.decodeIfPresent([CommitComment].self, forKey: "comments")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(event, forKey: "event")
        try values.encodeIfPresent(nodeID, forKey: "node_id")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(comments, forKey: "comments")
    }
}

public struct TimelineAssignedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Simple User
    public var assignee: SimpleUser

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, assignee: SimpleUser) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.assignee = assignee
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.assignee = try values.decode(SimpleUser.self, forKey: "assignee")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(assignee, forKey: "assignee")
    }
}

public struct TimelineUnassignedIssueEvent: Codable {
    public var id: Int
    public var nodeID: String
    public var url: String
    /// Simple User
    public var actor: SimpleUser
    public var event: String
    public var commitID: String?
    public var commitURL: String?
    public var createdAt: String
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Simple User
    public var assignee: SimpleUser

    public init(id: Int, nodeID: String, url: String, actor: SimpleUser, event: String, commitID: String? = nil, commitURL: String? = nil, createdAt: String, performedViaGithubApp: Integration? = nil, assignee: SimpleUser) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.actor = actor
        self.event = event
        self.commitID = commitID
        self.commitURL = commitURL
        self.createdAt = createdAt
        self.performedViaGithubApp = performedViaGithubApp
        self.assignee = assignee
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(String.self, forKey: "url")
        self.actor = try values.decode(SimpleUser.self, forKey: "actor")
        self.event = try values.decode(String.self, forKey: "event")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commit_id")
        self.commitURL = try values.decodeIfPresent(String.self, forKey: "commit_url")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.assignee = try values.decode(SimpleUser.self, forKey: "assignee")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(actor, forKey: "actor")
        try values.encode(event, forKey: "event")
        try values.encodeIfPresent(commitID, forKey: "commit_id")
        try values.encodeIfPresent(commitURL, forKey: "commit_url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encode(assignee, forKey: "assignee")
    }
}

/// Timeline Event
public struct TimelineIssueEvents: Codable {
    public var labeledIssueEvent: LabeledIssueEvent?
    public var unlabeledIssueEvent: UnlabeledIssueEvent?
    public var milestonedIssueEvent: MilestonedIssueEvent?
    public var demilestonedIssueEvent: DemilestonedIssueEvent?
    public var renamedIssueEvent: RenamedIssueEvent?
    public var reviewRequestedIssueEvent: ReviewRequestedIssueEvent?
    public var reviewRequestRemovedIssueEvent: ReviewRequestRemovedIssueEvent?
    public var reviewDismissedIssueEvent: ReviewDismissedIssueEvent?
    public var lockedIssueEvent: LockedIssueEvent?
    public var addedToProjectIssueEvent: AddedToProjectIssueEvent?
    public var movedColumnInProjectIssueEvent: MovedColumnInProjectIssueEvent?
    public var removedFromProjectIssueEvent: RemovedFromProjectIssueEvent?
    public var convertedNoteToIssueIssueEvent: ConvertedNoteToIssueIssueEvent?
    public var timelineCommentEvent: TimelineCommentEvent?
    public var timelineCrossReferencedEvent: TimelineCrossReferencedEvent?
    public var timelineCommittedEvent: TimelineCommittedEvent?
    public var timelineReviewedEvent: TimelineReviewedEvent?
    public var timelineLineCommentedEvent: TimelineLineCommentedEvent?
    public var timelineCommitCommentedEvent: TimelineCommitCommentedEvent?
    public var timelineAssignedIssueEvent: TimelineAssignedIssueEvent?
    public var timelineUnassignedIssueEvent: TimelineUnassignedIssueEvent?

    public init(labeledIssueEvent: LabeledIssueEvent? = nil, unlabeledIssueEvent: UnlabeledIssueEvent? = nil, milestonedIssueEvent: MilestonedIssueEvent? = nil, demilestonedIssueEvent: DemilestonedIssueEvent? = nil, renamedIssueEvent: RenamedIssueEvent? = nil, reviewRequestedIssueEvent: ReviewRequestedIssueEvent? = nil, reviewRequestRemovedIssueEvent: ReviewRequestRemovedIssueEvent? = nil, reviewDismissedIssueEvent: ReviewDismissedIssueEvent? = nil, lockedIssueEvent: LockedIssueEvent? = nil, addedToProjectIssueEvent: AddedToProjectIssueEvent? = nil, movedColumnInProjectIssueEvent: MovedColumnInProjectIssueEvent? = nil, removedFromProjectIssueEvent: RemovedFromProjectIssueEvent? = nil, convertedNoteToIssueIssueEvent: ConvertedNoteToIssueIssueEvent? = nil, timelineCommentEvent: TimelineCommentEvent? = nil, timelineCrossReferencedEvent: TimelineCrossReferencedEvent? = nil, timelineCommittedEvent: TimelineCommittedEvent? = nil, timelineReviewedEvent: TimelineReviewedEvent? = nil, timelineLineCommentedEvent: TimelineLineCommentedEvent? = nil, timelineCommitCommentedEvent: TimelineCommitCommentedEvent? = nil, timelineAssignedIssueEvent: TimelineAssignedIssueEvent? = nil, timelineUnassignedIssueEvent: TimelineUnassignedIssueEvent? = nil) {
        self.labeledIssueEvent = labeledIssueEvent
        self.unlabeledIssueEvent = unlabeledIssueEvent
        self.milestonedIssueEvent = milestonedIssueEvent
        self.demilestonedIssueEvent = demilestonedIssueEvent
        self.renamedIssueEvent = renamedIssueEvent
        self.reviewRequestedIssueEvent = reviewRequestedIssueEvent
        self.reviewRequestRemovedIssueEvent = reviewRequestRemovedIssueEvent
        self.reviewDismissedIssueEvent = reviewDismissedIssueEvent
        self.lockedIssueEvent = lockedIssueEvent
        self.addedToProjectIssueEvent = addedToProjectIssueEvent
        self.movedColumnInProjectIssueEvent = movedColumnInProjectIssueEvent
        self.removedFromProjectIssueEvent = removedFromProjectIssueEvent
        self.convertedNoteToIssueIssueEvent = convertedNoteToIssueIssueEvent
        self.timelineCommentEvent = timelineCommentEvent
        self.timelineCrossReferencedEvent = timelineCrossReferencedEvent
        self.timelineCommittedEvent = timelineCommittedEvent
        self.timelineReviewedEvent = timelineReviewedEvent
        self.timelineLineCommentedEvent = timelineLineCommentedEvent
        self.timelineCommitCommentedEvent = timelineCommitCommentedEvent
        self.timelineAssignedIssueEvent = timelineAssignedIssueEvent
        self.timelineUnassignedIssueEvent = timelineUnassignedIssueEvent
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.labeledIssueEvent = try? container.decode(LabeledIssueEvent.self)
        self.unlabeledIssueEvent = try? container.decode(UnlabeledIssueEvent.self)
        self.milestonedIssueEvent = try? container.decode(MilestonedIssueEvent.self)
        self.demilestonedIssueEvent = try? container.decode(DemilestonedIssueEvent.self)
        self.renamedIssueEvent = try? container.decode(RenamedIssueEvent.self)
        self.reviewRequestedIssueEvent = try? container.decode(ReviewRequestedIssueEvent.self)
        self.reviewRequestRemovedIssueEvent = try? container.decode(ReviewRequestRemovedIssueEvent.self)
        self.reviewDismissedIssueEvent = try? container.decode(ReviewDismissedIssueEvent.self)
        self.lockedIssueEvent = try? container.decode(LockedIssueEvent.self)
        self.addedToProjectIssueEvent = try? container.decode(AddedToProjectIssueEvent.self)
        self.movedColumnInProjectIssueEvent = try? container.decode(MovedColumnInProjectIssueEvent.self)
        self.removedFromProjectIssueEvent = try? container.decode(RemovedFromProjectIssueEvent.self)
        self.convertedNoteToIssueIssueEvent = try? container.decode(ConvertedNoteToIssueIssueEvent.self)
        self.timelineCommentEvent = try? container.decode(TimelineCommentEvent.self)
        self.timelineCrossReferencedEvent = try? container.decode(TimelineCrossReferencedEvent.self)
        self.timelineCommittedEvent = try? container.decode(TimelineCommittedEvent.self)
        self.timelineReviewedEvent = try? container.decode(TimelineReviewedEvent.self)
        self.timelineLineCommentedEvent = try? container.decode(TimelineLineCommentedEvent.self)
        self.timelineCommitCommentedEvent = try? container.decode(TimelineCommitCommentedEvent.self)
        self.timelineAssignedIssueEvent = try? container.decode(TimelineAssignedIssueEvent.self)
        self.timelineUnassignedIssueEvent = try? container.decode(TimelineUnassignedIssueEvent.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = labeledIssueEvent { try container.encode(value) }
        if let value = unlabeledIssueEvent { try container.encode(value) }
        if let value = milestonedIssueEvent { try container.encode(value) }
        if let value = demilestonedIssueEvent { try container.encode(value) }
        if let value = renamedIssueEvent { try container.encode(value) }
        if let value = reviewRequestedIssueEvent { try container.encode(value) }
        if let value = reviewRequestRemovedIssueEvent { try container.encode(value) }
        if let value = reviewDismissedIssueEvent { try container.encode(value) }
        if let value = lockedIssueEvent { try container.encode(value) }
        if let value = addedToProjectIssueEvent { try container.encode(value) }
        if let value = movedColumnInProjectIssueEvent { try container.encode(value) }
        if let value = removedFromProjectIssueEvent { try container.encode(value) }
        if let value = convertedNoteToIssueIssueEvent { try container.encode(value) }
        if let value = timelineCommentEvent { try container.encode(value) }
        if let value = timelineCrossReferencedEvent { try container.encode(value) }
        if let value = timelineCommittedEvent { try container.encode(value) }
        if let value = timelineReviewedEvent { try container.encode(value) }
        if let value = timelineLineCommentedEvent { try container.encode(value) }
        if let value = timelineCommitCommentedEvent { try container.encode(value) }
        if let value = timelineAssignedIssueEvent { try container.encode(value) }
        if let value = timelineUnassignedIssueEvent { try container.encode(value) }
    }
}

/// An SSH key granting access to a single repository.
public struct DeployKey: Codable {
    public var id: Int
    public var key: String
    public var url: String
    public var title: String
    public var isVerified: Bool
    public var createdAt: String
    public var isReadOnly: Bool

    public init(id: Int, key: String, url: String, title: String, isVerified: Bool, createdAt: String, isReadOnly: Bool) {
        self.id = id
        self.key = key
        self.url = url
        self.title = title
        self.isVerified = isVerified
        self.createdAt = createdAt
        self.isReadOnly = isReadOnly
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.key = try values.decode(String.self, forKey: "key")
        self.url = try values.decode(String.self, forKey: "url")
        self.title = try values.decode(String.self, forKey: "title")
        self.isVerified = try values.decode(Bool.self, forKey: "verified")
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.isReadOnly = try values.decode(Bool.self, forKey: "read_only")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(key, forKey: "key")
        try values.encode(url, forKey: "url")
        try values.encode(title, forKey: "title")
        try values.encode(isVerified, forKey: "verified")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(isReadOnly, forKey: "read_only")
    }
}

public struct LicenseContent: Codable {
    public var name: String
    public var path: String
    public var sha: String
    public var size: Int
    public var url: URL
    public var htmlURL: URL?
    public var gitURL: URL?
    public var downloadURL: URL?
    public var type: String
    public var content: String
    public var encoding: String
    public var links: Links
    /// License Simple
    public var license: LicenseSimple?

    public struct Links: Codable {
        public var git: URL?
        public var html: URL?
        public var this: URL

        public init(git: URL? = nil, html: URL? = nil, this: URL) {
            self.git = git
            self.html = html
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.git = try values.decodeIfPresent(URL.self, forKey: "git")
            self.html = try values.decodeIfPresent(URL.self, forKey: "html")
            self.this = try values.decode(URL.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(git, forKey: "git")
            try values.encodeIfPresent(html, forKey: "html")
            try values.encode(this, forKey: "self")
        }
    }

    public init(name: String, path: String, sha: String, size: Int, url: URL, htmlURL: URL? = nil, gitURL: URL? = nil, downloadURL: URL? = nil, type: String, content: String, encoding: String, links: Links, license: LicenseSimple? = nil) {
        self.name = name
        self.path = path
        self.sha = sha
        self.size = size
        self.url = url
        self.htmlURL = htmlURL
        self.gitURL = gitURL
        self.downloadURL = downloadURL
        self.type = type
        self.content = content
        self.encoding = encoding
        self.links = links
        self.license = license
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.size = try values.decode(Int.self, forKey: "size")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.gitURL = try values.decodeIfPresent(URL.self, forKey: "git_url")
        self.downloadURL = try values.decodeIfPresent(URL.self, forKey: "download_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.content = try values.decode(String.self, forKey: "content")
        self.encoding = try values.decode(String.self, forKey: "encoding")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(sha, forKey: "sha")
        try values.encode(size, forKey: "size")
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(gitURL, forKey: "git_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encode(type, forKey: "type")
        try values.encode(content, forKey: "content")
        try values.encode(encoding, forKey: "encoding")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(license, forKey: "license")
    }
}

/// Results of a successful merge upstream request
public struct MergedUpstream: Codable {
    public var message: String?
    public var mergeType: MergeType?
    public var baseBranch: String?

    public enum MergeType: String, Codable, CaseIterable {
        case merge
        case fastForward = "fast-forward"
        case `none`
    }

    public init(message: String? = nil, mergeType: MergeType? = nil, baseBranch: String? = nil) {
        self.message = message
        self.mergeType = mergeType
        self.baseBranch = baseBranch
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.mergeType = try values.decodeIfPresent(MergeType.self, forKey: "merge_type")
        self.baseBranch = try values.decodeIfPresent(String.self, forKey: "base_branch")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(mergeType, forKey: "merge_type")
        try values.encodeIfPresent(baseBranch, forKey: "base_branch")
    }
}

/// A collection of related issues and pull requests.
public struct Milestone: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/milestones/1"
    public var url: URL
    /// Example: "https://github.com/octocat/Hello-World/milestones/v1.0"
    public var htmlURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/milestones/1/labels"
    public var labelsURL: URL
    /// Example: 1002604
    public var id: Int
    /// Example: "MDk6TWlsZXN0b25lMTAwMjYwNA=="
    public var nodeID: String
    /// The number of the milestone.
    ///
    /// Example: 42
    public var number: Int
    /// The state of the milestone.
    ///
    /// Example: "open"
    public var state: State
    /// The title of the milestone.
    ///
    /// Example: "v1.0"
    public var title: String
    /// Example: "Tracking milestone for version 1.0"
    public var description: String?
    /// Simple User
    public var creator: SimpleUser?
    public var openIssues: Int
    public var closedIssues: Int
    /// Example: "2011-04-10T20:09:31Z"
    public var createdAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var updatedAt: Date
    /// Example: "2013-02-12T13:22:01Z"
    public var closedAt: Date?
    /// Example: "2012-10-09T23:39:01Z"
    public var dueOn: Date?

    /// The state of the milestone.
    ///
    /// Example: "open"
    public enum State: String, Codable, CaseIterable {
        case `open`
        case closed
    }

    public init(url: URL, htmlURL: URL, labelsURL: URL, id: Int, nodeID: String, number: Int, state: State, title: String, description: String? = nil, creator: SimpleUser? = nil, openIssues: Int, closedIssues: Int, createdAt: Date, updatedAt: Date, closedAt: Date? = nil, dueOn: Date? = nil) {
        self.url = url
        self.htmlURL = htmlURL
        self.labelsURL = labelsURL
        self.id = id
        self.nodeID = nodeID
        self.number = number
        self.state = state
        self.title = title
        self.description = description
        self.creator = creator
        self.openIssues = openIssues
        self.closedIssues = closedIssues
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.closedAt = closedAt
        self.dueOn = dueOn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.labelsURL = try values.decode(URL.self, forKey: "labels_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(State.self, forKey: "state")
        self.title = try values.decode(String.self, forKey: "title")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.creator = try values.decodeIfPresent(SimpleUser.self, forKey: "creator")
        self.openIssues = try values.decode(Int.self, forKey: "open_issues")
        self.closedIssues = try values.decode(Int.self, forKey: "closed_issues")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.closedAt = try values.decodeIfPresent(Date.self, forKey: "closed_at")
        self.dueOn = try values.decodeIfPresent(Date.self, forKey: "due_on")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encode(title, forKey: "title")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encode(openIssues, forKey: "open_issues")
        try values.encode(closedIssues, forKey: "closed_issues")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(closedAt, forKey: "closed_at")
        try values.encodeIfPresent(dueOn, forKey: "due_on")
    }
}

public struct PagesSourceHash: Codable {
    public var branch: String
    public var path: String

    public init(branch: String, path: String) {
        self.branch = branch
        self.path = path
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.branch = try values.decode(String.self, forKey: "branch")
        self.path = try values.decode(String.self, forKey: "path")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(branch, forKey: "branch")
        try values.encode(path, forKey: "path")
    }
}

public struct PagesHTTPSCertificate: Codable {
    /// Example: "approved"
    public var state: State
    /// Example: "Certificate is approved"
    public var description: String
    /// Array of the domain set and its alternate name (if it is configured)
    ///
    /// Example: ["example.com", "www.example.com"]
    public var domains: [String]
    public var expiresAt: NaiveDate?

    /// Example: "approved"
    public enum State: String, Codable, CaseIterable {
        case new
        case authorizationCreated = "authorization_created"
        case authorizationPending = "authorization_pending"
        case authorized
        case authorizationRevoked = "authorization_revoked"
        case issued
        case uploaded
        case approved
        case errored
        case badAuthz = "bad_authz"
        case destroyPending = "destroy_pending"
        case dnsChanged = "dns_changed"
    }

    public init(state: State, description: String, domains: [String], expiresAt: NaiveDate? = nil) {
        self.state = state
        self.description = description
        self.domains = domains
        self.expiresAt = expiresAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.state = try values.decode(State.self, forKey: "state")
        self.description = try values.decode(String.self, forKey: "description")
        self.domains = try values.decode([String].self, forKey: "domains")
        self.expiresAt = try values.decodeIfPresent(NaiveDate.self, forKey: "expires_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(state, forKey: "state")
        try values.encode(description, forKey: "description")
        try values.encode(domains, forKey: "domains")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
    }
}

/// GitHub Pages
///
/// The configuration for GitHub Pages for a repository.
public struct Page: Codable {
    /// The API address for accessing this Page resource.
    ///
    /// Example: "https://api.github.com/repos/github/hello-world/pages"
    public var url: URL
    /// The status of the most recent build of the Page.
    ///
    /// Example: "built"
    public var status: Status?
    /// The Pages site's custom domain
    ///
    /// Example: "example.com"
    public var cname: String?
    /// The state if the domain is verified
    ///
    /// Example: "pending"
    public var protectedDomainState: ProtectedDomainState?
    /// The timestamp when a pending domain becomes unverified.
    public var pendingDomainUnverifiedAt: Date?
    /// Whether the Page has a custom 404 page.
    ///
    /// Example: false
    public var isCustom404: Bool
    /// The web address the Page can be accessed from.
    ///
    /// Example: "https://example.com"
    public var htmlURL: URL?
    /// Pages Source Hash
    public var source: PagesSourceHash?
    /// Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
    ///
    /// Example: true
    public var isPublic: Bool
    /// Pages Https Certificate
    public var httpsCertificate: PagesHTTPSCertificate?
    /// Whether https is enabled on the domain
    ///
    /// Example: true
    public var isHTTPSEnforced: Bool?

    /// The status of the most recent build of the Page.
    ///
    /// Example: "built"
    public enum Status: String, Codable, CaseIterable {
        case built
        case building
        case errored
    }

    /// The state if the domain is verified
    ///
    /// Example: "pending"
    public enum ProtectedDomainState: String, Codable, CaseIterable {
        case pending
        case verified
        case unverified
    }

    public init(url: URL, status: Status? = nil, cname: String? = nil, protectedDomainState: ProtectedDomainState? = nil, pendingDomainUnverifiedAt: Date? = nil, isCustom404: Bool, htmlURL: URL? = nil, source: PagesSourceHash? = nil, isPublic: Bool, httpsCertificate: PagesHTTPSCertificate? = nil, isHTTPSEnforced: Bool? = nil) {
        self.url = url
        self.status = status
        self.cname = cname
        self.protectedDomainState = protectedDomainState
        self.pendingDomainUnverifiedAt = pendingDomainUnverifiedAt
        self.isCustom404 = isCustom404
        self.htmlURL = htmlURL
        self.source = source
        self.isPublic = isPublic
        self.httpsCertificate = httpsCertificate
        self.isHTTPSEnforced = isHTTPSEnforced
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.cname = try values.decodeIfPresent(String.self, forKey: "cname")
        self.protectedDomainState = try values.decodeIfPresent(ProtectedDomainState.self, forKey: "protected_domain_state")
        self.pendingDomainUnverifiedAt = try values.decodeIfPresent(Date.self, forKey: "pending_domain_unverified_at")
        self.isCustom404 = try values.decode(Bool.self, forKey: "custom_404")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.source = try values.decodeIfPresent(PagesSourceHash.self, forKey: "source")
        self.isPublic = try values.decode(Bool.self, forKey: "public")
        self.httpsCertificate = try values.decodeIfPresent(PagesHTTPSCertificate.self, forKey: "https_certificate")
        self.isHTTPSEnforced = try values.decodeIfPresent(Bool.self, forKey: "https_enforced")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(cname, forKey: "cname")
        try values.encodeIfPresent(protectedDomainState, forKey: "protected_domain_state")
        try values.encodeIfPresent(pendingDomainUnverifiedAt, forKey: "pending_domain_unverified_at")
        try values.encode(isCustom404, forKey: "custom_404")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encode(isPublic, forKey: "public")
        try values.encodeIfPresent(httpsCertificate, forKey: "https_certificate")
        try values.encodeIfPresent(isHTTPSEnforced, forKey: "https_enforced")
    }
}

public struct PageBuild: Codable {
    public var url: URL
    public var status: String
    public var error: Error
    /// Simple User
    public var pusher: SimpleUser?
    public var commit: String
    public var duration: Int
    public var createdAt: Date
    public var updatedAt: Date

    public struct Error: Codable {
        public var message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.message = try values.decodeIfPresent(String.self, forKey: "message")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(message, forKey: "message")
        }
    }

    public init(url: URL, status: String, error: Error, pusher: SimpleUser? = nil, commit: String, duration: Int, createdAt: Date, updatedAt: Date) {
        self.url = url
        self.status = status
        self.error = error
        self.pusher = pusher
        self.commit = commit
        self.duration = duration
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.status = try values.decode(String.self, forKey: "status")
        self.error = try values.decode(Error.self, forKey: "error")
        self.pusher = try values.decodeIfPresent(SimpleUser.self, forKey: "pusher")
        self.commit = try values.decode(String.self, forKey: "commit")
        self.duration = try values.decode(Int.self, forKey: "duration")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(status, forKey: "status")
        try values.encode(error, forKey: "error")
        try values.encodeIfPresent(pusher, forKey: "pusher")
        try values.encode(commit, forKey: "commit")
        try values.encode(duration, forKey: "duration")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
    }
}

public struct PageBuildStatus: Codable {
    /// Example: "https://api.github.com/repos/github/hello-world/pages/builds/latest"
    public var url: URL
    /// Example: "queued"
    public var status: String

    public init(url: URL, status: String) {
        self.url = url
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.status = try values.decode(String.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(status, forKey: "status")
    }
}

/// Pages Health Check Status
public struct PagesHealthCheck: Codable {
    public var domain: Domain?
    public var altDomain: AltDomain?

    public struct Domain: Codable {
        public var host: String?
        public var uri: String?
        public var nameservers: String?
        public var dnsResolves: Bool?
        public var isProxied: Bool?
        public var isCloudflareIp: Bool?
        public var isFastlyIp: Bool?
        public var isOldIpAddress: Bool?
        public var isARecord: Bool?
        public var hasCnameRecord: Bool?
        public var hasMxRecordsPresent: Bool?
        public var isValidDomain: Bool?
        public var isApexDomain: Bool?
        public var shouldBeARecord: Bool?
        public var isCnameToGithubUserDomain: Bool?
        public var isCnameToPagesDotGithubDotCom: Bool?
        public var isCnameToFastly: Bool?
        public var isPointedToGithubPagesIp: Bool?
        public var isNonGithubPagesIpPresent: Bool?
        public var isPagesDomain: Bool?
        public var isServedByPages: Bool?
        public var isValid: Bool?
        public var reason: String?
        public var respondsToHTTPS: Bool?
        public var enforcesHTTPS: Bool?
        public var httpsError: String?
        public var isHTTPSEligible: Bool?
        public var caaError: String?

        public init(host: String? = nil, uri: String? = nil, nameservers: String? = nil, dnsResolves: Bool? = nil, isProxied: Bool? = nil, isCloudflareIp: Bool? = nil, isFastlyIp: Bool? = nil, isOldIpAddress: Bool? = nil, isARecord: Bool? = nil, hasCnameRecord: Bool? = nil, hasMxRecordsPresent: Bool? = nil, isValidDomain: Bool? = nil, isApexDomain: Bool? = nil, shouldBeARecord: Bool? = nil, isCnameToGithubUserDomain: Bool? = nil, isCnameToPagesDotGithubDotCom: Bool? = nil, isCnameToFastly: Bool? = nil, isPointedToGithubPagesIp: Bool? = nil, isNonGithubPagesIpPresent: Bool? = nil, isPagesDomain: Bool? = nil, isServedByPages: Bool? = nil, isValid: Bool? = nil, reason: String? = nil, respondsToHTTPS: Bool? = nil, enforcesHTTPS: Bool? = nil, httpsError: String? = nil, isHTTPSEligible: Bool? = nil, caaError: String? = nil) {
            self.host = host
            self.uri = uri
            self.nameservers = nameservers
            self.dnsResolves = dnsResolves
            self.isProxied = isProxied
            self.isCloudflareIp = isCloudflareIp
            self.isFastlyIp = isFastlyIp
            self.isOldIpAddress = isOldIpAddress
            self.isARecord = isARecord
            self.hasCnameRecord = hasCnameRecord
            self.hasMxRecordsPresent = hasMxRecordsPresent
            self.isValidDomain = isValidDomain
            self.isApexDomain = isApexDomain
            self.shouldBeARecord = shouldBeARecord
            self.isCnameToGithubUserDomain = isCnameToGithubUserDomain
            self.isCnameToPagesDotGithubDotCom = isCnameToPagesDotGithubDotCom
            self.isCnameToFastly = isCnameToFastly
            self.isPointedToGithubPagesIp = isPointedToGithubPagesIp
            self.isNonGithubPagesIpPresent = isNonGithubPagesIpPresent
            self.isPagesDomain = isPagesDomain
            self.isServedByPages = isServedByPages
            self.isValid = isValid
            self.reason = reason
            self.respondsToHTTPS = respondsToHTTPS
            self.enforcesHTTPS = enforcesHTTPS
            self.httpsError = httpsError
            self.isHTTPSEligible = isHTTPSEligible
            self.caaError = caaError
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.host = try values.decodeIfPresent(String.self, forKey: "host")
            self.uri = try values.decodeIfPresent(String.self, forKey: "uri")
            self.nameservers = try values.decodeIfPresent(String.self, forKey: "nameservers")
            self.dnsResolves = try values.decodeIfPresent(Bool.self, forKey: "dns_resolves")
            self.isProxied = try values.decodeIfPresent(Bool.self, forKey: "is_proxied")
            self.isCloudflareIp = try values.decodeIfPresent(Bool.self, forKey: "is_cloudflare_ip")
            self.isFastlyIp = try values.decodeIfPresent(Bool.self, forKey: "is_fastly_ip")
            self.isOldIpAddress = try values.decodeIfPresent(Bool.self, forKey: "is_old_ip_address")
            self.isARecord = try values.decodeIfPresent(Bool.self, forKey: "is_a_record")
            self.hasCnameRecord = try values.decodeIfPresent(Bool.self, forKey: "has_cname_record")
            self.hasMxRecordsPresent = try values.decodeIfPresent(Bool.self, forKey: "has_mx_records_present")
            self.isValidDomain = try values.decodeIfPresent(Bool.self, forKey: "is_valid_domain")
            self.isApexDomain = try values.decodeIfPresent(Bool.self, forKey: "is_apex_domain")
            self.shouldBeARecord = try values.decodeIfPresent(Bool.self, forKey: "should_be_a_record")
            self.isCnameToGithubUserDomain = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_github_user_domain")
            self.isCnameToPagesDotGithubDotCom = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_pages_dot_github_dot_com")
            self.isCnameToFastly = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_fastly")
            self.isPointedToGithubPagesIp = try values.decodeIfPresent(Bool.self, forKey: "is_pointed_to_github_pages_ip")
            self.isNonGithubPagesIpPresent = try values.decodeIfPresent(Bool.self, forKey: "is_non_github_pages_ip_present")
            self.isPagesDomain = try values.decodeIfPresent(Bool.self, forKey: "is_pages_domain")
            self.isServedByPages = try values.decodeIfPresent(Bool.self, forKey: "is_served_by_pages")
            self.isValid = try values.decodeIfPresent(Bool.self, forKey: "is_valid")
            self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
            self.respondsToHTTPS = try values.decodeIfPresent(Bool.self, forKey: "responds_to_https")
            self.enforcesHTTPS = try values.decodeIfPresent(Bool.self, forKey: "enforces_https")
            self.httpsError = try values.decodeIfPresent(String.self, forKey: "https_error")
            self.isHTTPSEligible = try values.decodeIfPresent(Bool.self, forKey: "is_https_eligible")
            self.caaError = try values.decodeIfPresent(String.self, forKey: "caa_error")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(host, forKey: "host")
            try values.encodeIfPresent(uri, forKey: "uri")
            try values.encodeIfPresent(nameservers, forKey: "nameservers")
            try values.encodeIfPresent(dnsResolves, forKey: "dns_resolves")
            try values.encodeIfPresent(isProxied, forKey: "is_proxied")
            try values.encodeIfPresent(isCloudflareIp, forKey: "is_cloudflare_ip")
            try values.encodeIfPresent(isFastlyIp, forKey: "is_fastly_ip")
            try values.encodeIfPresent(isOldIpAddress, forKey: "is_old_ip_address")
            try values.encodeIfPresent(isARecord, forKey: "is_a_record")
            try values.encodeIfPresent(hasCnameRecord, forKey: "has_cname_record")
            try values.encodeIfPresent(hasMxRecordsPresent, forKey: "has_mx_records_present")
            try values.encodeIfPresent(isValidDomain, forKey: "is_valid_domain")
            try values.encodeIfPresent(isApexDomain, forKey: "is_apex_domain")
            try values.encodeIfPresent(shouldBeARecord, forKey: "should_be_a_record")
            try values.encodeIfPresent(isCnameToGithubUserDomain, forKey: "is_cname_to_github_user_domain")
            try values.encodeIfPresent(isCnameToPagesDotGithubDotCom, forKey: "is_cname_to_pages_dot_github_dot_com")
            try values.encodeIfPresent(isCnameToFastly, forKey: "is_cname_to_fastly")
            try values.encodeIfPresent(isPointedToGithubPagesIp, forKey: "is_pointed_to_github_pages_ip")
            try values.encodeIfPresent(isNonGithubPagesIpPresent, forKey: "is_non_github_pages_ip_present")
            try values.encodeIfPresent(isPagesDomain, forKey: "is_pages_domain")
            try values.encodeIfPresent(isServedByPages, forKey: "is_served_by_pages")
            try values.encodeIfPresent(isValid, forKey: "is_valid")
            try values.encodeIfPresent(reason, forKey: "reason")
            try values.encodeIfPresent(respondsToHTTPS, forKey: "responds_to_https")
            try values.encodeIfPresent(enforcesHTTPS, forKey: "enforces_https")
            try values.encodeIfPresent(httpsError, forKey: "https_error")
            try values.encodeIfPresent(isHTTPSEligible, forKey: "is_https_eligible")
            try values.encodeIfPresent(caaError, forKey: "caa_error")
        }
    }

    public struct AltDomain: Codable {
        public var host: String?
        public var uri: String?
        public var nameservers: String?
        public var dnsResolves: Bool?
        public var isProxied: Bool?
        public var isCloudflareIp: Bool?
        public var isFastlyIp: Bool?
        public var isOldIpAddress: Bool?
        public var isARecord: Bool?
        public var hasCnameRecord: Bool?
        public var hasMxRecordsPresent: Bool?
        public var isValidDomain: Bool?
        public var isApexDomain: Bool?
        public var shouldBeARecord: Bool?
        public var isCnameToGithubUserDomain: Bool?
        public var isCnameToPagesDotGithubDotCom: Bool?
        public var isCnameToFastly: Bool?
        public var isPointedToGithubPagesIp: Bool?
        public var isNonGithubPagesIpPresent: Bool?
        public var isPagesDomain: Bool?
        public var isServedByPages: Bool?
        public var isValid: Bool?
        public var reason: String?
        public var respondsToHTTPS: Bool?
        public var enforcesHTTPS: Bool?
        public var httpsError: String?
        public var isHTTPSEligible: Bool?
        public var caaError: String?

        public init(host: String? = nil, uri: String? = nil, nameservers: String? = nil, dnsResolves: Bool? = nil, isProxied: Bool? = nil, isCloudflareIp: Bool? = nil, isFastlyIp: Bool? = nil, isOldIpAddress: Bool? = nil, isARecord: Bool? = nil, hasCnameRecord: Bool? = nil, hasMxRecordsPresent: Bool? = nil, isValidDomain: Bool? = nil, isApexDomain: Bool? = nil, shouldBeARecord: Bool? = nil, isCnameToGithubUserDomain: Bool? = nil, isCnameToPagesDotGithubDotCom: Bool? = nil, isCnameToFastly: Bool? = nil, isPointedToGithubPagesIp: Bool? = nil, isNonGithubPagesIpPresent: Bool? = nil, isPagesDomain: Bool? = nil, isServedByPages: Bool? = nil, isValid: Bool? = nil, reason: String? = nil, respondsToHTTPS: Bool? = nil, enforcesHTTPS: Bool? = nil, httpsError: String? = nil, isHTTPSEligible: Bool? = nil, caaError: String? = nil) {
            self.host = host
            self.uri = uri
            self.nameservers = nameservers
            self.dnsResolves = dnsResolves
            self.isProxied = isProxied
            self.isCloudflareIp = isCloudflareIp
            self.isFastlyIp = isFastlyIp
            self.isOldIpAddress = isOldIpAddress
            self.isARecord = isARecord
            self.hasCnameRecord = hasCnameRecord
            self.hasMxRecordsPresent = hasMxRecordsPresent
            self.isValidDomain = isValidDomain
            self.isApexDomain = isApexDomain
            self.shouldBeARecord = shouldBeARecord
            self.isCnameToGithubUserDomain = isCnameToGithubUserDomain
            self.isCnameToPagesDotGithubDotCom = isCnameToPagesDotGithubDotCom
            self.isCnameToFastly = isCnameToFastly
            self.isPointedToGithubPagesIp = isPointedToGithubPagesIp
            self.isNonGithubPagesIpPresent = isNonGithubPagesIpPresent
            self.isPagesDomain = isPagesDomain
            self.isServedByPages = isServedByPages
            self.isValid = isValid
            self.reason = reason
            self.respondsToHTTPS = respondsToHTTPS
            self.enforcesHTTPS = enforcesHTTPS
            self.httpsError = httpsError
            self.isHTTPSEligible = isHTTPSEligible
            self.caaError = caaError
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.host = try values.decodeIfPresent(String.self, forKey: "host")
            self.uri = try values.decodeIfPresent(String.self, forKey: "uri")
            self.nameservers = try values.decodeIfPresent(String.self, forKey: "nameservers")
            self.dnsResolves = try values.decodeIfPresent(Bool.self, forKey: "dns_resolves")
            self.isProxied = try values.decodeIfPresent(Bool.self, forKey: "is_proxied")
            self.isCloudflareIp = try values.decodeIfPresent(Bool.self, forKey: "is_cloudflare_ip")
            self.isFastlyIp = try values.decodeIfPresent(Bool.self, forKey: "is_fastly_ip")
            self.isOldIpAddress = try values.decodeIfPresent(Bool.self, forKey: "is_old_ip_address")
            self.isARecord = try values.decodeIfPresent(Bool.self, forKey: "is_a_record")
            self.hasCnameRecord = try values.decodeIfPresent(Bool.self, forKey: "has_cname_record")
            self.hasMxRecordsPresent = try values.decodeIfPresent(Bool.self, forKey: "has_mx_records_present")
            self.isValidDomain = try values.decodeIfPresent(Bool.self, forKey: "is_valid_domain")
            self.isApexDomain = try values.decodeIfPresent(Bool.self, forKey: "is_apex_domain")
            self.shouldBeARecord = try values.decodeIfPresent(Bool.self, forKey: "should_be_a_record")
            self.isCnameToGithubUserDomain = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_github_user_domain")
            self.isCnameToPagesDotGithubDotCom = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_pages_dot_github_dot_com")
            self.isCnameToFastly = try values.decodeIfPresent(Bool.self, forKey: "is_cname_to_fastly")
            self.isPointedToGithubPagesIp = try values.decodeIfPresent(Bool.self, forKey: "is_pointed_to_github_pages_ip")
            self.isNonGithubPagesIpPresent = try values.decodeIfPresent(Bool.self, forKey: "is_non_github_pages_ip_present")
            self.isPagesDomain = try values.decodeIfPresent(Bool.self, forKey: "is_pages_domain")
            self.isServedByPages = try values.decodeIfPresent(Bool.self, forKey: "is_served_by_pages")
            self.isValid = try values.decodeIfPresent(Bool.self, forKey: "is_valid")
            self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
            self.respondsToHTTPS = try values.decodeIfPresent(Bool.self, forKey: "responds_to_https")
            self.enforcesHTTPS = try values.decodeIfPresent(Bool.self, forKey: "enforces_https")
            self.httpsError = try values.decodeIfPresent(String.self, forKey: "https_error")
            self.isHTTPSEligible = try values.decodeIfPresent(Bool.self, forKey: "is_https_eligible")
            self.caaError = try values.decodeIfPresent(String.self, forKey: "caa_error")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(host, forKey: "host")
            try values.encodeIfPresent(uri, forKey: "uri")
            try values.encodeIfPresent(nameservers, forKey: "nameservers")
            try values.encodeIfPresent(dnsResolves, forKey: "dns_resolves")
            try values.encodeIfPresent(isProxied, forKey: "is_proxied")
            try values.encodeIfPresent(isCloudflareIp, forKey: "is_cloudflare_ip")
            try values.encodeIfPresent(isFastlyIp, forKey: "is_fastly_ip")
            try values.encodeIfPresent(isOldIpAddress, forKey: "is_old_ip_address")
            try values.encodeIfPresent(isARecord, forKey: "is_a_record")
            try values.encodeIfPresent(hasCnameRecord, forKey: "has_cname_record")
            try values.encodeIfPresent(hasMxRecordsPresent, forKey: "has_mx_records_present")
            try values.encodeIfPresent(isValidDomain, forKey: "is_valid_domain")
            try values.encodeIfPresent(isApexDomain, forKey: "is_apex_domain")
            try values.encodeIfPresent(shouldBeARecord, forKey: "should_be_a_record")
            try values.encodeIfPresent(isCnameToGithubUserDomain, forKey: "is_cname_to_github_user_domain")
            try values.encodeIfPresent(isCnameToPagesDotGithubDotCom, forKey: "is_cname_to_pages_dot_github_dot_com")
            try values.encodeIfPresent(isCnameToFastly, forKey: "is_cname_to_fastly")
            try values.encodeIfPresent(isPointedToGithubPagesIp, forKey: "is_pointed_to_github_pages_ip")
            try values.encodeIfPresent(isNonGithubPagesIpPresent, forKey: "is_non_github_pages_ip_present")
            try values.encodeIfPresent(isPagesDomain, forKey: "is_pages_domain")
            try values.encodeIfPresent(isServedByPages, forKey: "is_served_by_pages")
            try values.encodeIfPresent(isValid, forKey: "is_valid")
            try values.encodeIfPresent(reason, forKey: "reason")
            try values.encodeIfPresent(respondsToHTTPS, forKey: "responds_to_https")
            try values.encodeIfPresent(enforcesHTTPS, forKey: "enforces_https")
            try values.encodeIfPresent(httpsError, forKey: "https_error")
            try values.encodeIfPresent(isHTTPSEligible, forKey: "is_https_eligible")
            try values.encodeIfPresent(caaError, forKey: "caa_error")
        }
    }

    public init(domain: Domain? = nil, altDomain: AltDomain? = nil) {
        self.domain = domain
        self.altDomain = altDomain
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.domain = try values.decodeIfPresent(Domain.self, forKey: "domain")
        self.altDomain = try values.decodeIfPresent(AltDomain.self, forKey: "alt_domain")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(domain, forKey: "domain")
        try values.encodeIfPresent(altDomain, forKey: "alt_domain")
    }
}

/// Groups of organization members that gives permissions on specified repositories.
public struct TeamSimple: Codable {
    /// Unique identifier of the team
    public var id: Int
    /// Example: "MDQ6VGVhbTE="
    public var nodeID: String
    /// URL for the team
    ///
    /// Example: "https://api.github.com/organizations/1/team/1"
    public var url: URL
    /// Example: "https://api.github.com/organizations/1/team/1/members{/member}"
    public var membersURL: String
    /// Name of the team
    ///
    /// Example: "Justice League"
    public var name: String
    /// Description of the team
    ///
    /// Example: "A great team."
    public var description: String?
    /// Permission that the team will have for its repositories
    ///
    /// Example: "admin"
    public var permission: String
    /// The level of privacy this team should have
    ///
    /// Example: "closed"
    public var privacy: String?
    /// Example: "https://github.com/orgs/rails/teams/core"
    public var htmlURL: URL
    /// Example: "https://api.github.com/organizations/1/team/1/repos"
    public var repositoriesURL: URL
    /// Example: "justice-league"
    public var slug: String
    /// Distinguished Name (DN) that team maps to within LDAP environment
    ///
    /// Example: "uid=example,ou=users,dc=github,dc=com"
    public var ldapDn: String?

    public init(id: Int, nodeID: String, url: URL, membersURL: String, name: String, description: String? = nil, permission: String, privacy: String? = nil, htmlURL: URL, repositoriesURL: URL, slug: String, ldapDn: String? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.membersURL = membersURL
        self.name = name
        self.description = description
        self.permission = permission
        self.privacy = privacy
        self.htmlURL = htmlURL
        self.repositoriesURL = repositoriesURL
        self.slug = slug
        self.ldapDn = ldapDn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.membersURL = try values.decode(String.self, forKey: "members_url")
        self.name = try values.decode(String.self, forKey: "name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.permission = try values.decode(String.self, forKey: "permission")
        self.privacy = try values.decodeIfPresent(String.self, forKey: "privacy")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.repositoriesURL = try values.decode(URL.self, forKey: "repositories_url")
        self.slug = try values.decode(String.self, forKey: "slug")
        self.ldapDn = try values.decodeIfPresent(String.self, forKey: "ldap_dn")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(membersURL, forKey: "members_url")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(permission, forKey: "permission")
        try values.encodeIfPresent(privacy, forKey: "privacy")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(repositoriesURL, forKey: "repositories_url")
        try values.encode(slug, forKey: "slug")
        try values.encodeIfPresent(ldapDn, forKey: "ldap_dn")
    }
}

/// Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.
public struct PullRequest: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347"
    public var url: URL
    public var id: Int
    /// Example: "MDExOlB1bGxSZXF1ZXN0MQ=="
    public var nodeID: String
    /// Example: "https://github.com/octocat/Hello-World/pull/1347"
    public var htmlURL: URL
    /// Example: "https://github.com/octocat/Hello-World/pull/1347.diff"
    public var diffURL: URL
    /// Example: "https://github.com/octocat/Hello-World/pull/1347.patch"
    public var patchURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/issues/1347"
    public var issueURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits"
    public var commitsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments"
    public var reviewCommentsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}"
    public var reviewCommentURL: String
    /// Example: "https://api.github.com/repos/octocat/Hello-World/issues/1347/comments"
    public var commentsURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var statusesURL: URL
    /// Number uniquely identifying the pull request within its repository.
    ///
    /// Example: 42
    public var number: Int
    /// State of this Pull Request. Either `open` or `closed`.
    ///
    /// Example: "open"
    public var state: State
    /// Example: true
    public var isLocked: Bool
    /// The title of the pull request.
    ///
    /// Example: "Amazing new feature"
    public var title: String
    /// Simple User
    public var user: SimpleUser?
    /// Example: "Please pull these awesome changes"
    public var body: String?
    public var labels: [Label]
    /// A collection of related issues and pull requests.
    public var milestone: Milestone?
    /// Example: "too heated"
    public var activeLockReason: String?
    /// Example: "2011-01-26T19:01:12Z"
    public var createdAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var updatedAt: Date
    /// Example: "2011-01-26T19:01:12Z"
    public var closedAt: Date?
    /// Example: "2011-01-26T19:01:12Z"
    public var mergedAt: Date?
    /// Example: "e5bd3914e2e596debea16f433f57875b5b90bcd6"
    public var mergeCommitSha: String?
    /// Simple User
    public var assignee: SimpleUser?
    public var assignees: [SimpleUser]?
    public var requestedReviewers: [SimpleUser]?
    public var requestedTeams: [TeamSimple]?
    public var head: Head
    public var base: Base
    public var links: Links
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    /// The status of auto merging a pull request.
    public var autoMerge: AutoMerge?
    /// Indicates whether or not the pull request is a draft.
    ///
    /// Example: false
    public var isDraft: Bool?
    public var isMerged: Bool
    /// Example: true
    public var isMergeable: Bool?
    /// Example: true
    public var isRebaseable: Bool?
    /// Example: "clean"
    public var mergeableState: String
    /// Simple User
    public var mergedBy: SimpleUser?
    /// Example: 10
    public var comments: Int
    public var reviewComments: Int
    /// Indicates whether maintainers can modify the pull request.
    ///
    /// Example: true
    public var maintainerCanModify: Bool
    public var commits: Int
    /// Example: 100
    public var additions: Int
    public var deletions: Int
    public var changedFiles: Int

    /// State of this Pull Request. Either `open` or `closed`.
    ///
    /// Example: "open"
    public enum State: String, Codable, CaseIterable {
        case `open`
        case closed
    }

    public struct Label: Codable {
        public var id: Int
        public var nodeID: String
        public var url: String
        public var name: String
        public var description: String?
        public var color: String
        public var isDefault: Bool

        public init(id: Int, nodeID: String, url: String, name: String, description: String? = nil, color: String, isDefault: Bool) {
            self.id = id
            self.nodeID = nodeID
            self.url = url
            self.name = name
            self.description = description
            self.color = color
            self.isDefault = isDefault
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.nodeID = try values.decode(String.self, forKey: "node_id")
            self.url = try values.decode(String.self, forKey: "url")
            self.name = try values.decode(String.self, forKey: "name")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.color = try values.decode(String.self, forKey: "color")
            self.isDefault = try values.decode(Bool.self, forKey: "default")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(nodeID, forKey: "node_id")
            try values.encode(url, forKey: "url")
            try values.encode(name, forKey: "name")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(color, forKey: "color")
            try values.encode(isDefault, forKey: "default")
        }
    }

    public struct Head: Codable {
        public var label: String
        public var ref: String
        public var repo: Repo?
        public var sha: String
        public var user: User

        public struct Repo: Codable {
            public var archiveURL: String
            public var assigneesURL: String
            public var blobsURL: String
            public var branchesURL: String
            public var collaboratorsURL: String
            public var commentsURL: String
            public var commitsURL: String
            public var compareURL: String
            public var contentsURL: String
            public var contributorsURL: URL
            public var deploymentsURL: URL
            public var description: String?
            public var downloadsURL: URL
            public var eventsURL: URL
            public var isFork: Bool
            public var forksURL: URL
            public var fullName: String
            public var gitCommitsURL: String
            public var gitRefsURL: String
            public var gitTagsURL: String
            public var hooksURL: URL
            public var htmlURL: URL
            public var id: Int
            public var nodeID: String
            public var issueCommentURL: String
            public var issueEventsURL: String
            public var issuesURL: String
            public var keysURL: String
            public var labelsURL: String
            public var languagesURL: URL
            public var mergesURL: URL
            public var milestonesURL: String
            public var name: String
            public var notificationsURL: String
            public var owner: Owner
            public var isPrivate: Bool
            public var pullsURL: String
            public var releasesURL: String
            public var stargazersURL: URL
            public var statusesURL: String
            public var subscribersURL: URL
            public var subscriptionURL: URL
            public var tagsURL: URL
            public var teamsURL: URL
            public var treesURL: String
            public var url: URL
            public var cloneURL: String
            public var defaultBranch: String
            public var forks: Int
            public var forksCount: Int
            public var gitURL: String
            public var hasDownloads: Bool
            public var hasIssues: Bool
            public var hasProjects: Bool
            public var hasWiki: Bool
            public var hasPages: Bool
            public var homepage: URL?
            public var language: String?
            public var masterBranch: String?
            public var isArchived: Bool
            public var isDisabled: Bool
            /// The repository visibility: public, private, or internal.
            public var visibility: String?
            public var mirrorURL: URL?
            public var openIssues: Int
            public var openIssuesCount: Int
            public var permissions: Permissions?
            public var tempCloneToken: String?
            public var allowMergeCommit: Bool?
            public var allowSquashMerge: Bool?
            public var allowRebaseMerge: Bool?
            public var license: License?
            public var pushedAt: Date
            public var size: Int
            public var sshURL: String
            public var stargazersCount: Int
            public var svnURL: URL
            public var topics: [String]?
            public var watchers: Int
            public var watchersCount: Int
            public var createdAt: Date
            public var updatedAt: Date
            public var allowForking: Bool?
            public var isTemplate: Bool?

            public struct Owner: Codable {
                public var avatarURL: URL
                public var eventsURL: String
                public var followersURL: URL
                public var followingURL: String
                public var gistsURL: String
                public var gravatarID: String?
                public var htmlURL: URL
                public var id: Int
                public var nodeID: String
                public var login: String
                public var organizationsURL: URL
                public var receivedEventsURL: URL
                public var reposURL: URL
                public var isSiteAdmin: Bool
                public var starredURL: String
                public var subscriptionsURL: URL
                public var type: String
                public var url: URL

                public init(avatarURL: URL, eventsURL: String, followersURL: URL, followingURL: String, gistsURL: String, gravatarID: String? = nil, htmlURL: URL, id: Int, nodeID: String, login: String, organizationsURL: URL, receivedEventsURL: URL, reposURL: URL, isSiteAdmin: Bool, starredURL: String, subscriptionsURL: URL, type: String, url: URL) {
                    self.avatarURL = avatarURL
                    self.eventsURL = eventsURL
                    self.followersURL = followersURL
                    self.followingURL = followingURL
                    self.gistsURL = gistsURL
                    self.gravatarID = gravatarID
                    self.htmlURL = htmlURL
                    self.id = id
                    self.nodeID = nodeID
                    self.login = login
                    self.organizationsURL = organizationsURL
                    self.receivedEventsURL = receivedEventsURL
                    self.reposURL = reposURL
                    self.isSiteAdmin = isSiteAdmin
                    self.starredURL = starredURL
                    self.subscriptionsURL = subscriptionsURL
                    self.type = type
                    self.url = url
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
                    self.eventsURL = try values.decode(String.self, forKey: "events_url")
                    self.followersURL = try values.decode(URL.self, forKey: "followers_url")
                    self.followingURL = try values.decode(String.self, forKey: "following_url")
                    self.gistsURL = try values.decode(String.self, forKey: "gists_url")
                    self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                    self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                    self.id = try values.decode(Int.self, forKey: "id")
                    self.nodeID = try values.decode(String.self, forKey: "node_id")
                    self.login = try values.decode(String.self, forKey: "login")
                    self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
                    self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
                    self.reposURL = try values.decode(URL.self, forKey: "repos_url")
                    self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
                    self.starredURL = try values.decode(String.self, forKey: "starred_url")
                    self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
                    self.type = try values.decode(String.self, forKey: "type")
                    self.url = try values.decode(URL.self, forKey: "url")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(avatarURL, forKey: "avatar_url")
                    try values.encode(eventsURL, forKey: "events_url")
                    try values.encode(followersURL, forKey: "followers_url")
                    try values.encode(followingURL, forKey: "following_url")
                    try values.encode(gistsURL, forKey: "gists_url")
                    try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                    try values.encode(htmlURL, forKey: "html_url")
                    try values.encode(id, forKey: "id")
                    try values.encode(nodeID, forKey: "node_id")
                    try values.encode(login, forKey: "login")
                    try values.encode(organizationsURL, forKey: "organizations_url")
                    try values.encode(receivedEventsURL, forKey: "received_events_url")
                    try values.encode(reposURL, forKey: "repos_url")
                    try values.encode(isSiteAdmin, forKey: "site_admin")
                    try values.encode(starredURL, forKey: "starred_url")
                    try values.encode(subscriptionsURL, forKey: "subscriptions_url")
                    try values.encode(type, forKey: "type")
                    try values.encode(url, forKey: "url")
                }
            }

            public struct Permissions: Codable {
                public var isAdmin: Bool
                public var isMaintain: Bool?
                public var isPush: Bool
                public var isTriage: Bool?
                public var isPull: Bool

                public init(isAdmin: Bool, isMaintain: Bool? = nil, isPush: Bool, isTriage: Bool? = nil, isPull: Bool) {
                    self.isAdmin = isAdmin
                    self.isMaintain = isMaintain
                    self.isPush = isPush
                    self.isTriage = isTriage
                    self.isPull = isPull
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.isAdmin = try values.decode(Bool.self, forKey: "admin")
                    self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
                    self.isPush = try values.decode(Bool.self, forKey: "push")
                    self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
                    self.isPull = try values.decode(Bool.self, forKey: "pull")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(isAdmin, forKey: "admin")
                    try values.encodeIfPresent(isMaintain, forKey: "maintain")
                    try values.encode(isPush, forKey: "push")
                    try values.encodeIfPresent(isTriage, forKey: "triage")
                    try values.encode(isPull, forKey: "pull")
                }
            }

            public struct License: Codable {
                public var key: String
                public var name: String
                public var url: URL?
                public var spdxID: String?
                public var nodeID: String

                public init(key: String, name: String, url: URL? = nil, spdxID: String? = nil, nodeID: String) {
                    self.key = key
                    self.name = name
                    self.url = url
                    self.spdxID = spdxID
                    self.nodeID = nodeID
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.key = try values.decode(String.self, forKey: "key")
                    self.name = try values.decode(String.self, forKey: "name")
                    self.url = try values.decodeIfPresent(URL.self, forKey: "url")
                    self.spdxID = try values.decodeIfPresent(String.self, forKey: "spdx_id")
                    self.nodeID = try values.decode(String.self, forKey: "node_id")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(key, forKey: "key")
                    try values.encode(name, forKey: "name")
                    try values.encodeIfPresent(url, forKey: "url")
                    try values.encodeIfPresent(spdxID, forKey: "spdx_id")
                    try values.encode(nodeID, forKey: "node_id")
                }
            }

            public init(archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, description: String? = nil, downloadsURL: URL, eventsURL: URL, isFork: Bool, forksURL: URL, fullName: String, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, hooksURL: URL, htmlURL: URL, id: Int, nodeID: String, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, name: String, notificationsURL: String, owner: Owner, isPrivate: Bool, pullsURL: String, releasesURL: String, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, url: URL, cloneURL: String, defaultBranch: String, forks: Int, forksCount: Int, gitURL: String, hasDownloads: Bool, hasIssues: Bool, hasProjects: Bool, hasWiki: Bool, hasPages: Bool, homepage: URL? = nil, language: String? = nil, masterBranch: String? = nil, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, mirrorURL: URL? = nil, openIssues: Int, openIssuesCount: Int, permissions: Permissions? = nil, tempCloneToken: String? = nil, allowMergeCommit: Bool? = nil, allowSquashMerge: Bool? = nil, allowRebaseMerge: Bool? = nil, license: License? = nil, pushedAt: Date, size: Int, sshURL: String, stargazersCount: Int, svnURL: URL, topics: [String]? = nil, watchers: Int, watchersCount: Int, createdAt: Date, updatedAt: Date, allowForking: Bool? = nil, isTemplate: Bool? = nil) {
                self.archiveURL = archiveURL
                self.assigneesURL = assigneesURL
                self.blobsURL = blobsURL
                self.branchesURL = branchesURL
                self.collaboratorsURL = collaboratorsURL
                self.commentsURL = commentsURL
                self.commitsURL = commitsURL
                self.compareURL = compareURL
                self.contentsURL = contentsURL
                self.contributorsURL = contributorsURL
                self.deploymentsURL = deploymentsURL
                self.description = description
                self.downloadsURL = downloadsURL
                self.eventsURL = eventsURL
                self.isFork = isFork
                self.forksURL = forksURL
                self.fullName = fullName
                self.gitCommitsURL = gitCommitsURL
                self.gitRefsURL = gitRefsURL
                self.gitTagsURL = gitTagsURL
                self.hooksURL = hooksURL
                self.htmlURL = htmlURL
                self.id = id
                self.nodeID = nodeID
                self.issueCommentURL = issueCommentURL
                self.issueEventsURL = issueEventsURL
                self.issuesURL = issuesURL
                self.keysURL = keysURL
                self.labelsURL = labelsURL
                self.languagesURL = languagesURL
                self.mergesURL = mergesURL
                self.milestonesURL = milestonesURL
                self.name = name
                self.notificationsURL = notificationsURL
                self.owner = owner
                self.isPrivate = isPrivate
                self.pullsURL = pullsURL
                self.releasesURL = releasesURL
                self.stargazersURL = stargazersURL
                self.statusesURL = statusesURL
                self.subscribersURL = subscribersURL
                self.subscriptionURL = subscriptionURL
                self.tagsURL = tagsURL
                self.teamsURL = teamsURL
                self.treesURL = treesURL
                self.url = url
                self.cloneURL = cloneURL
                self.defaultBranch = defaultBranch
                self.forks = forks
                self.forksCount = forksCount
                self.gitURL = gitURL
                self.hasDownloads = hasDownloads
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.homepage = homepage
                self.language = language
                self.masterBranch = masterBranch
                self.isArchived = isArchived
                self.isDisabled = isDisabled
                self.visibility = visibility
                self.mirrorURL = mirrorURL
                self.openIssues = openIssues
                self.openIssuesCount = openIssuesCount
                self.permissions = permissions
                self.tempCloneToken = tempCloneToken
                self.allowMergeCommit = allowMergeCommit
                self.allowSquashMerge = allowSquashMerge
                self.allowRebaseMerge = allowRebaseMerge
                self.license = license
                self.pushedAt = pushedAt
                self.size = size
                self.sshURL = sshURL
                self.stargazersCount = stargazersCount
                self.svnURL = svnURL
                self.topics = topics
                self.watchers = watchers
                self.watchersCount = watchersCount
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.allowForking = allowForking
                self.isTemplate = isTemplate
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.archiveURL = try values.decode(String.self, forKey: "archive_url")
                self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
                self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
                self.branchesURL = try values.decode(String.self, forKey: "branches_url")
                self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
                self.commentsURL = try values.decode(String.self, forKey: "comments_url")
                self.commitsURL = try values.decode(String.self, forKey: "commits_url")
                self.compareURL = try values.decode(String.self, forKey: "compare_url")
                self.contentsURL = try values.decode(String.self, forKey: "contents_url")
                self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
                self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
                self.eventsURL = try values.decode(URL.self, forKey: "events_url")
                self.isFork = try values.decode(Bool.self, forKey: "fork")
                self.forksURL = try values.decode(URL.self, forKey: "forks_url")
                self.fullName = try values.decode(String.self, forKey: "full_name")
                self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
                self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
                self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
                self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
                self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
                self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
                self.issuesURL = try values.decode(String.self, forKey: "issues_url")
                self.keysURL = try values.decode(String.self, forKey: "keys_url")
                self.labelsURL = try values.decode(String.self, forKey: "labels_url")
                self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
                self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
                self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
                self.name = try values.decode(String.self, forKey: "name")
                self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
                self.owner = try values.decode(Owner.self, forKey: "owner")
                self.isPrivate = try values.decode(Bool.self, forKey: "private")
                self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
                self.releasesURL = try values.decode(String.self, forKey: "releases_url")
                self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
                self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
                self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
                self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
                self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
                self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
                self.treesURL = try values.decode(String.self, forKey: "trees_url")
                self.url = try values.decode(URL.self, forKey: "url")
                self.cloneURL = try values.decode(String.self, forKey: "clone_url")
                self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
                self.forks = try values.decode(Int.self, forKey: "forks")
                self.forksCount = try values.decode(Int.self, forKey: "forks_count")
                self.gitURL = try values.decode(String.self, forKey: "git_url")
                self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
                self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
                self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
                self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
                self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
                self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
                self.language = try values.decodeIfPresent(String.self, forKey: "language")
                self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
                self.isArchived = try values.decode(Bool.self, forKey: "archived")
                self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
                self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
                self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
                self.openIssues = try values.decode(Int.self, forKey: "open_issues")
                self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
                self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
                self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
                self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit")
                self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge")
                self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge")
                self.license = try values.decodeIfPresent(License.self, forKey: "license")
                self.pushedAt = try values.decode(Date.self, forKey: "pushed_at")
                self.size = try values.decode(Int.self, forKey: "size")
                self.sshURL = try values.decode(String.self, forKey: "ssh_url")
                self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
                self.svnURL = try values.decode(URL.self, forKey: "svn_url")
                self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
                self.watchers = try values.decode(Int.self, forKey: "watchers")
                self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
                self.createdAt = try values.decode(Date.self, forKey: "created_at")
                self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
                self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
                self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(archiveURL, forKey: "archive_url")
                try values.encode(assigneesURL, forKey: "assignees_url")
                try values.encode(blobsURL, forKey: "blobs_url")
                try values.encode(branchesURL, forKey: "branches_url")
                try values.encode(collaboratorsURL, forKey: "collaborators_url")
                try values.encode(commentsURL, forKey: "comments_url")
                try values.encode(commitsURL, forKey: "commits_url")
                try values.encode(compareURL, forKey: "compare_url")
                try values.encode(contentsURL, forKey: "contents_url")
                try values.encode(contributorsURL, forKey: "contributors_url")
                try values.encode(deploymentsURL, forKey: "deployments_url")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encode(downloadsURL, forKey: "downloads_url")
                try values.encode(eventsURL, forKey: "events_url")
                try values.encode(isFork, forKey: "fork")
                try values.encode(forksURL, forKey: "forks_url")
                try values.encode(fullName, forKey: "full_name")
                try values.encode(gitCommitsURL, forKey: "git_commits_url")
                try values.encode(gitRefsURL, forKey: "git_refs_url")
                try values.encode(gitTagsURL, forKey: "git_tags_url")
                try values.encode(hooksURL, forKey: "hooks_url")
                try values.encode(htmlURL, forKey: "html_url")
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(issueCommentURL, forKey: "issue_comment_url")
                try values.encode(issueEventsURL, forKey: "issue_events_url")
                try values.encode(issuesURL, forKey: "issues_url")
                try values.encode(keysURL, forKey: "keys_url")
                try values.encode(labelsURL, forKey: "labels_url")
                try values.encode(languagesURL, forKey: "languages_url")
                try values.encode(mergesURL, forKey: "merges_url")
                try values.encode(milestonesURL, forKey: "milestones_url")
                try values.encode(name, forKey: "name")
                try values.encode(notificationsURL, forKey: "notifications_url")
                try values.encode(owner, forKey: "owner")
                try values.encode(isPrivate, forKey: "private")
                try values.encode(pullsURL, forKey: "pulls_url")
                try values.encode(releasesURL, forKey: "releases_url")
                try values.encode(stargazersURL, forKey: "stargazers_url")
                try values.encode(statusesURL, forKey: "statuses_url")
                try values.encode(subscribersURL, forKey: "subscribers_url")
                try values.encode(subscriptionURL, forKey: "subscription_url")
                try values.encode(tagsURL, forKey: "tags_url")
                try values.encode(teamsURL, forKey: "teams_url")
                try values.encode(treesURL, forKey: "trees_url")
                try values.encode(url, forKey: "url")
                try values.encode(cloneURL, forKey: "clone_url")
                try values.encode(defaultBranch, forKey: "default_branch")
                try values.encode(forks, forKey: "forks")
                try values.encode(forksCount, forKey: "forks_count")
                try values.encode(gitURL, forKey: "git_url")
                try values.encode(hasDownloads, forKey: "has_downloads")
                try values.encode(hasIssues, forKey: "has_issues")
                try values.encode(hasProjects, forKey: "has_projects")
                try values.encode(hasWiki, forKey: "has_wiki")
                try values.encode(hasPages, forKey: "has_pages")
                try values.encodeIfPresent(homepage, forKey: "homepage")
                try values.encodeIfPresent(language, forKey: "language")
                try values.encodeIfPresent(masterBranch, forKey: "master_branch")
                try values.encode(isArchived, forKey: "archived")
                try values.encode(isDisabled, forKey: "disabled")
                try values.encodeIfPresent(visibility, forKey: "visibility")
                try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
                try values.encode(openIssues, forKey: "open_issues")
                try values.encode(openIssuesCount, forKey: "open_issues_count")
                try values.encodeIfPresent(permissions, forKey: "permissions")
                try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
                try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
                try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
                try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
                try values.encodeIfPresent(license, forKey: "license")
                try values.encode(pushedAt, forKey: "pushed_at")
                try values.encode(size, forKey: "size")
                try values.encode(sshURL, forKey: "ssh_url")
                try values.encode(stargazersCount, forKey: "stargazers_count")
                try values.encode(svnURL, forKey: "svn_url")
                try values.encodeIfPresent(topics, forKey: "topics")
                try values.encode(watchers, forKey: "watchers")
                try values.encode(watchersCount, forKey: "watchers_count")
                try values.encode(createdAt, forKey: "created_at")
                try values.encode(updatedAt, forKey: "updated_at")
                try values.encodeIfPresent(allowForking, forKey: "allow_forking")
                try values.encodeIfPresent(isTemplate, forKey: "is_template")
            }
        }

        public struct User: Codable {
            public var avatarURL: URL
            public var eventsURL: String
            public var followersURL: URL
            public var followingURL: String
            public var gistsURL: String
            public var gravatarID: String?
            public var htmlURL: URL
            public var id: Int
            public var nodeID: String
            public var login: String
            public var organizationsURL: URL
            public var receivedEventsURL: URL
            public var reposURL: URL
            public var isSiteAdmin: Bool
            public var starredURL: String
            public var subscriptionsURL: URL
            public var type: String
            public var url: URL

            public init(avatarURL: URL, eventsURL: String, followersURL: URL, followingURL: String, gistsURL: String, gravatarID: String? = nil, htmlURL: URL, id: Int, nodeID: String, login: String, organizationsURL: URL, receivedEventsURL: URL, reposURL: URL, isSiteAdmin: Bool, starredURL: String, subscriptionsURL: URL, type: String, url: URL) {
                self.avatarURL = avatarURL
                self.eventsURL = eventsURL
                self.followersURL = followersURL
                self.followingURL = followingURL
                self.gistsURL = gistsURL
                self.gravatarID = gravatarID
                self.htmlURL = htmlURL
                self.id = id
                self.nodeID = nodeID
                self.login = login
                self.organizationsURL = organizationsURL
                self.receivedEventsURL = receivedEventsURL
                self.reposURL = reposURL
                self.isSiteAdmin = isSiteAdmin
                self.starredURL = starredURL
                self.subscriptionsURL = subscriptionsURL
                self.type = type
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
                self.eventsURL = try values.decode(String.self, forKey: "events_url")
                self.followersURL = try values.decode(URL.self, forKey: "followers_url")
                self.followingURL = try values.decode(String.self, forKey: "following_url")
                self.gistsURL = try values.decode(String.self, forKey: "gists_url")
                self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.login = try values.decode(String.self, forKey: "login")
                self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
                self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
                self.reposURL = try values.decode(URL.self, forKey: "repos_url")
                self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
                self.starredURL = try values.decode(String.self, forKey: "starred_url")
                self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
                self.type = try values.decode(String.self, forKey: "type")
                self.url = try values.decode(URL.self, forKey: "url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(avatarURL, forKey: "avatar_url")
                try values.encode(eventsURL, forKey: "events_url")
                try values.encode(followersURL, forKey: "followers_url")
                try values.encode(followingURL, forKey: "following_url")
                try values.encode(gistsURL, forKey: "gists_url")
                try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                try values.encode(htmlURL, forKey: "html_url")
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(login, forKey: "login")
                try values.encode(organizationsURL, forKey: "organizations_url")
                try values.encode(receivedEventsURL, forKey: "received_events_url")
                try values.encode(reposURL, forKey: "repos_url")
                try values.encode(isSiteAdmin, forKey: "site_admin")
                try values.encode(starredURL, forKey: "starred_url")
                try values.encode(subscriptionsURL, forKey: "subscriptions_url")
                try values.encode(type, forKey: "type")
                try values.encode(url, forKey: "url")
            }
        }

        public init(label: String, ref: String, repo: Repo? = nil, sha: String, user: User) {
            self.label = label
            self.ref = ref
            self.repo = repo
            self.sha = sha
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.label = try values.decode(String.self, forKey: "label")
            self.ref = try values.decode(String.self, forKey: "ref")
            self.repo = try values.decodeIfPresent(Repo.self, forKey: "repo")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.user = try values.decode(User.self, forKey: "user")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(label, forKey: "label")
            try values.encode(ref, forKey: "ref")
            try values.encodeIfPresent(repo, forKey: "repo")
            try values.encode(sha, forKey: "sha")
            try values.encode(user, forKey: "user")
        }
    }

    public struct Base: Codable {
        public var label: String
        public var ref: String
        public var repo: Repo
        public var sha: String
        public var user: User

        public struct Repo: Codable {
            public var archiveURL: String
            public var assigneesURL: String
            public var blobsURL: String
            public var branchesURL: String
            public var collaboratorsURL: String
            public var commentsURL: String
            public var commitsURL: String
            public var compareURL: String
            public var contentsURL: String
            public var contributorsURL: URL
            public var deploymentsURL: URL
            public var description: String?
            public var downloadsURL: URL
            public var eventsURL: URL
            public var isFork: Bool
            public var forksURL: URL
            public var fullName: String
            public var gitCommitsURL: String
            public var gitRefsURL: String
            public var gitTagsURL: String
            public var hooksURL: URL
            public var htmlURL: URL
            public var id: Int
            public var isTemplate: Bool?
            public var nodeID: String
            public var issueCommentURL: String
            public var issueEventsURL: String
            public var issuesURL: String
            public var keysURL: String
            public var labelsURL: String
            public var languagesURL: URL
            public var mergesURL: URL
            public var milestonesURL: String
            public var name: String
            public var notificationsURL: String
            public var owner: Owner
            public var isPrivate: Bool
            public var pullsURL: String
            public var releasesURL: String
            public var stargazersURL: URL
            public var statusesURL: String
            public var subscribersURL: URL
            public var subscriptionURL: URL
            public var tagsURL: URL
            public var teamsURL: URL
            public var treesURL: String
            public var url: URL
            public var cloneURL: String
            public var defaultBranch: String
            public var forks: Int
            public var forksCount: Int
            public var gitURL: String
            public var hasDownloads: Bool
            public var hasIssues: Bool
            public var hasProjects: Bool
            public var hasWiki: Bool
            public var hasPages: Bool
            public var homepage: URL?
            public var language: String?
            public var masterBranch: String?
            public var isArchived: Bool
            public var isDisabled: Bool
            /// The repository visibility: public, private, or internal.
            public var visibility: String?
            public var mirrorURL: URL?
            public var openIssues: Int
            public var openIssuesCount: Int
            public var permissions: Permissions?
            public var tempCloneToken: String?
            public var allowMergeCommit: Bool?
            public var allowSquashMerge: Bool?
            public var allowRebaseMerge: Bool?
            /// License Simple
            public var license: LicenseSimple?
            public var pushedAt: Date
            public var size: Int
            public var sshURL: String
            public var stargazersCount: Int
            public var svnURL: URL
            public var topics: [String]?
            public var watchers: Int
            public var watchersCount: Int
            public var createdAt: Date
            public var updatedAt: Date
            public var allowForking: Bool?

            public struct Owner: Codable {
                public var avatarURL: URL
                public var eventsURL: String
                public var followersURL: URL
                public var followingURL: String
                public var gistsURL: String
                public var gravatarID: String?
                public var htmlURL: URL
                public var id: Int
                public var nodeID: String
                public var login: String
                public var organizationsURL: URL
                public var receivedEventsURL: URL
                public var reposURL: URL
                public var isSiteAdmin: Bool
                public var starredURL: String
                public var subscriptionsURL: URL
                public var type: String
                public var url: URL

                public init(avatarURL: URL, eventsURL: String, followersURL: URL, followingURL: String, gistsURL: String, gravatarID: String? = nil, htmlURL: URL, id: Int, nodeID: String, login: String, organizationsURL: URL, receivedEventsURL: URL, reposURL: URL, isSiteAdmin: Bool, starredURL: String, subscriptionsURL: URL, type: String, url: URL) {
                    self.avatarURL = avatarURL
                    self.eventsURL = eventsURL
                    self.followersURL = followersURL
                    self.followingURL = followingURL
                    self.gistsURL = gistsURL
                    self.gravatarID = gravatarID
                    self.htmlURL = htmlURL
                    self.id = id
                    self.nodeID = nodeID
                    self.login = login
                    self.organizationsURL = organizationsURL
                    self.receivedEventsURL = receivedEventsURL
                    self.reposURL = reposURL
                    self.isSiteAdmin = isSiteAdmin
                    self.starredURL = starredURL
                    self.subscriptionsURL = subscriptionsURL
                    self.type = type
                    self.url = url
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
                    self.eventsURL = try values.decode(String.self, forKey: "events_url")
                    self.followersURL = try values.decode(URL.self, forKey: "followers_url")
                    self.followingURL = try values.decode(String.self, forKey: "following_url")
                    self.gistsURL = try values.decode(String.self, forKey: "gists_url")
                    self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                    self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                    self.id = try values.decode(Int.self, forKey: "id")
                    self.nodeID = try values.decode(String.self, forKey: "node_id")
                    self.login = try values.decode(String.self, forKey: "login")
                    self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
                    self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
                    self.reposURL = try values.decode(URL.self, forKey: "repos_url")
                    self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
                    self.starredURL = try values.decode(String.self, forKey: "starred_url")
                    self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
                    self.type = try values.decode(String.self, forKey: "type")
                    self.url = try values.decode(URL.self, forKey: "url")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(avatarURL, forKey: "avatar_url")
                    try values.encode(eventsURL, forKey: "events_url")
                    try values.encode(followersURL, forKey: "followers_url")
                    try values.encode(followingURL, forKey: "following_url")
                    try values.encode(gistsURL, forKey: "gists_url")
                    try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                    try values.encode(htmlURL, forKey: "html_url")
                    try values.encode(id, forKey: "id")
                    try values.encode(nodeID, forKey: "node_id")
                    try values.encode(login, forKey: "login")
                    try values.encode(organizationsURL, forKey: "organizations_url")
                    try values.encode(receivedEventsURL, forKey: "received_events_url")
                    try values.encode(reposURL, forKey: "repos_url")
                    try values.encode(isSiteAdmin, forKey: "site_admin")
                    try values.encode(starredURL, forKey: "starred_url")
                    try values.encode(subscriptionsURL, forKey: "subscriptions_url")
                    try values.encode(type, forKey: "type")
                    try values.encode(url, forKey: "url")
                }
            }

            public struct Permissions: Codable {
                public var isAdmin: Bool
                public var isMaintain: Bool?
                public var isPush: Bool
                public var isTriage: Bool?
                public var isPull: Bool

                public init(isAdmin: Bool, isMaintain: Bool? = nil, isPush: Bool, isTriage: Bool? = nil, isPull: Bool) {
                    self.isAdmin = isAdmin
                    self.isMaintain = isMaintain
                    self.isPush = isPush
                    self.isTriage = isTriage
                    self.isPull = isPull
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.isAdmin = try values.decode(Bool.self, forKey: "admin")
                    self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
                    self.isPush = try values.decode(Bool.self, forKey: "push")
                    self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
                    self.isPull = try values.decode(Bool.self, forKey: "pull")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(isAdmin, forKey: "admin")
                    try values.encodeIfPresent(isMaintain, forKey: "maintain")
                    try values.encode(isPush, forKey: "push")
                    try values.encodeIfPresent(isTriage, forKey: "triage")
                    try values.encode(isPull, forKey: "pull")
                }
            }

            public init(archiveURL: String, assigneesURL: String, blobsURL: String, branchesURL: String, collaboratorsURL: String, commentsURL: String, commitsURL: String, compareURL: String, contentsURL: String, contributorsURL: URL, deploymentsURL: URL, description: String? = nil, downloadsURL: URL, eventsURL: URL, isFork: Bool, forksURL: URL, fullName: String, gitCommitsURL: String, gitRefsURL: String, gitTagsURL: String, hooksURL: URL, htmlURL: URL, id: Int, isTemplate: Bool? = nil, nodeID: String, issueCommentURL: String, issueEventsURL: String, issuesURL: String, keysURL: String, labelsURL: String, languagesURL: URL, mergesURL: URL, milestonesURL: String, name: String, notificationsURL: String, owner: Owner, isPrivate: Bool, pullsURL: String, releasesURL: String, stargazersURL: URL, statusesURL: String, subscribersURL: URL, subscriptionURL: URL, tagsURL: URL, teamsURL: URL, treesURL: String, url: URL, cloneURL: String, defaultBranch: String, forks: Int, forksCount: Int, gitURL: String, hasDownloads: Bool, hasIssues: Bool, hasProjects: Bool, hasWiki: Bool, hasPages: Bool, homepage: URL? = nil, language: String? = nil, masterBranch: String? = nil, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, mirrorURL: URL? = nil, openIssues: Int, openIssuesCount: Int, permissions: Permissions? = nil, tempCloneToken: String? = nil, allowMergeCommit: Bool? = nil, allowSquashMerge: Bool? = nil, allowRebaseMerge: Bool? = nil, license: LicenseSimple? = nil, pushedAt: Date, size: Int, sshURL: String, stargazersCount: Int, svnURL: URL, topics: [String]? = nil, watchers: Int, watchersCount: Int, createdAt: Date, updatedAt: Date, allowForking: Bool? = nil) {
                self.archiveURL = archiveURL
                self.assigneesURL = assigneesURL
                self.blobsURL = blobsURL
                self.branchesURL = branchesURL
                self.collaboratorsURL = collaboratorsURL
                self.commentsURL = commentsURL
                self.commitsURL = commitsURL
                self.compareURL = compareURL
                self.contentsURL = contentsURL
                self.contributorsURL = contributorsURL
                self.deploymentsURL = deploymentsURL
                self.description = description
                self.downloadsURL = downloadsURL
                self.eventsURL = eventsURL
                self.isFork = isFork
                self.forksURL = forksURL
                self.fullName = fullName
                self.gitCommitsURL = gitCommitsURL
                self.gitRefsURL = gitRefsURL
                self.gitTagsURL = gitTagsURL
                self.hooksURL = hooksURL
                self.htmlURL = htmlURL
                self.id = id
                self.isTemplate = isTemplate
                self.nodeID = nodeID
                self.issueCommentURL = issueCommentURL
                self.issueEventsURL = issueEventsURL
                self.issuesURL = issuesURL
                self.keysURL = keysURL
                self.labelsURL = labelsURL
                self.languagesURL = languagesURL
                self.mergesURL = mergesURL
                self.milestonesURL = milestonesURL
                self.name = name
                self.notificationsURL = notificationsURL
                self.owner = owner
                self.isPrivate = isPrivate
                self.pullsURL = pullsURL
                self.releasesURL = releasesURL
                self.stargazersURL = stargazersURL
                self.statusesURL = statusesURL
                self.subscribersURL = subscribersURL
                self.subscriptionURL = subscriptionURL
                self.tagsURL = tagsURL
                self.teamsURL = teamsURL
                self.treesURL = treesURL
                self.url = url
                self.cloneURL = cloneURL
                self.defaultBranch = defaultBranch
                self.forks = forks
                self.forksCount = forksCount
                self.gitURL = gitURL
                self.hasDownloads = hasDownloads
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.homepage = homepage
                self.language = language
                self.masterBranch = masterBranch
                self.isArchived = isArchived
                self.isDisabled = isDisabled
                self.visibility = visibility
                self.mirrorURL = mirrorURL
                self.openIssues = openIssues
                self.openIssuesCount = openIssuesCount
                self.permissions = permissions
                self.tempCloneToken = tempCloneToken
                self.allowMergeCommit = allowMergeCommit
                self.allowSquashMerge = allowSquashMerge
                self.allowRebaseMerge = allowRebaseMerge
                self.license = license
                self.pushedAt = pushedAt
                self.size = size
                self.sshURL = sshURL
                self.stargazersCount = stargazersCount
                self.svnURL = svnURL
                self.topics = topics
                self.watchers = watchers
                self.watchersCount = watchersCount
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.allowForking = allowForking
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.archiveURL = try values.decode(String.self, forKey: "archive_url")
                self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
                self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
                self.branchesURL = try values.decode(String.self, forKey: "branches_url")
                self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
                self.commentsURL = try values.decode(String.self, forKey: "comments_url")
                self.commitsURL = try values.decode(String.self, forKey: "commits_url")
                self.compareURL = try values.decode(String.self, forKey: "compare_url")
                self.contentsURL = try values.decode(String.self, forKey: "contents_url")
                self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
                self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
                self.eventsURL = try values.decode(URL.self, forKey: "events_url")
                self.isFork = try values.decode(Bool.self, forKey: "fork")
                self.forksURL = try values.decode(URL.self, forKey: "forks_url")
                self.fullName = try values.decode(String.self, forKey: "full_name")
                self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
                self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
                self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
                self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
                self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                self.id = try values.decode(Int.self, forKey: "id")
                self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
                self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
                self.issuesURL = try values.decode(String.self, forKey: "issues_url")
                self.keysURL = try values.decode(String.self, forKey: "keys_url")
                self.labelsURL = try values.decode(String.self, forKey: "labels_url")
                self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
                self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
                self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
                self.name = try values.decode(String.self, forKey: "name")
                self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
                self.owner = try values.decode(Owner.self, forKey: "owner")
                self.isPrivate = try values.decode(Bool.self, forKey: "private")
                self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
                self.releasesURL = try values.decode(String.self, forKey: "releases_url")
                self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
                self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
                self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
                self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
                self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
                self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
                self.treesURL = try values.decode(String.self, forKey: "trees_url")
                self.url = try values.decode(URL.self, forKey: "url")
                self.cloneURL = try values.decode(String.self, forKey: "clone_url")
                self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
                self.forks = try values.decode(Int.self, forKey: "forks")
                self.forksCount = try values.decode(Int.self, forKey: "forks_count")
                self.gitURL = try values.decode(String.self, forKey: "git_url")
                self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
                self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
                self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
                self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
                self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
                self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
                self.language = try values.decodeIfPresent(String.self, forKey: "language")
                self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
                self.isArchived = try values.decode(Bool.self, forKey: "archived")
                self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
                self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
                self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
                self.openIssues = try values.decode(Int.self, forKey: "open_issues")
                self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
                self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
                self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
                self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit")
                self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge")
                self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge")
                self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
                self.pushedAt = try values.decode(Date.self, forKey: "pushed_at")
                self.size = try values.decode(Int.self, forKey: "size")
                self.sshURL = try values.decode(String.self, forKey: "ssh_url")
                self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
                self.svnURL = try values.decode(URL.self, forKey: "svn_url")
                self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
                self.watchers = try values.decode(Int.self, forKey: "watchers")
                self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
                self.createdAt = try values.decode(Date.self, forKey: "created_at")
                self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
                self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(archiveURL, forKey: "archive_url")
                try values.encode(assigneesURL, forKey: "assignees_url")
                try values.encode(blobsURL, forKey: "blobs_url")
                try values.encode(branchesURL, forKey: "branches_url")
                try values.encode(collaboratorsURL, forKey: "collaborators_url")
                try values.encode(commentsURL, forKey: "comments_url")
                try values.encode(commitsURL, forKey: "commits_url")
                try values.encode(compareURL, forKey: "compare_url")
                try values.encode(contentsURL, forKey: "contents_url")
                try values.encode(contributorsURL, forKey: "contributors_url")
                try values.encode(deploymentsURL, forKey: "deployments_url")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encode(downloadsURL, forKey: "downloads_url")
                try values.encode(eventsURL, forKey: "events_url")
                try values.encode(isFork, forKey: "fork")
                try values.encode(forksURL, forKey: "forks_url")
                try values.encode(fullName, forKey: "full_name")
                try values.encode(gitCommitsURL, forKey: "git_commits_url")
                try values.encode(gitRefsURL, forKey: "git_refs_url")
                try values.encode(gitTagsURL, forKey: "git_tags_url")
                try values.encode(hooksURL, forKey: "hooks_url")
                try values.encode(htmlURL, forKey: "html_url")
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(isTemplate, forKey: "is_template")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(issueCommentURL, forKey: "issue_comment_url")
                try values.encode(issueEventsURL, forKey: "issue_events_url")
                try values.encode(issuesURL, forKey: "issues_url")
                try values.encode(keysURL, forKey: "keys_url")
                try values.encode(labelsURL, forKey: "labels_url")
                try values.encode(languagesURL, forKey: "languages_url")
                try values.encode(mergesURL, forKey: "merges_url")
                try values.encode(milestonesURL, forKey: "milestones_url")
                try values.encode(name, forKey: "name")
                try values.encode(notificationsURL, forKey: "notifications_url")
                try values.encode(owner, forKey: "owner")
                try values.encode(isPrivate, forKey: "private")
                try values.encode(pullsURL, forKey: "pulls_url")
                try values.encode(releasesURL, forKey: "releases_url")
                try values.encode(stargazersURL, forKey: "stargazers_url")
                try values.encode(statusesURL, forKey: "statuses_url")
                try values.encode(subscribersURL, forKey: "subscribers_url")
                try values.encode(subscriptionURL, forKey: "subscription_url")
                try values.encode(tagsURL, forKey: "tags_url")
                try values.encode(teamsURL, forKey: "teams_url")
                try values.encode(treesURL, forKey: "trees_url")
                try values.encode(url, forKey: "url")
                try values.encode(cloneURL, forKey: "clone_url")
                try values.encode(defaultBranch, forKey: "default_branch")
                try values.encode(forks, forKey: "forks")
                try values.encode(forksCount, forKey: "forks_count")
                try values.encode(gitURL, forKey: "git_url")
                try values.encode(hasDownloads, forKey: "has_downloads")
                try values.encode(hasIssues, forKey: "has_issues")
                try values.encode(hasProjects, forKey: "has_projects")
                try values.encode(hasWiki, forKey: "has_wiki")
                try values.encode(hasPages, forKey: "has_pages")
                try values.encodeIfPresent(homepage, forKey: "homepage")
                try values.encodeIfPresent(language, forKey: "language")
                try values.encodeIfPresent(masterBranch, forKey: "master_branch")
                try values.encode(isArchived, forKey: "archived")
                try values.encode(isDisabled, forKey: "disabled")
                try values.encodeIfPresent(visibility, forKey: "visibility")
                try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
                try values.encode(openIssues, forKey: "open_issues")
                try values.encode(openIssuesCount, forKey: "open_issues_count")
                try values.encodeIfPresent(permissions, forKey: "permissions")
                try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
                try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
                try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
                try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
                try values.encodeIfPresent(license, forKey: "license")
                try values.encode(pushedAt, forKey: "pushed_at")
                try values.encode(size, forKey: "size")
                try values.encode(sshURL, forKey: "ssh_url")
                try values.encode(stargazersCount, forKey: "stargazers_count")
                try values.encode(svnURL, forKey: "svn_url")
                try values.encodeIfPresent(topics, forKey: "topics")
                try values.encode(watchers, forKey: "watchers")
                try values.encode(watchersCount, forKey: "watchers_count")
                try values.encode(createdAt, forKey: "created_at")
                try values.encode(updatedAt, forKey: "updated_at")
                try values.encodeIfPresent(allowForking, forKey: "allow_forking")
            }
        }

        public struct User: Codable {
            public var avatarURL: URL
            public var eventsURL: String
            public var followersURL: URL
            public var followingURL: String
            public var gistsURL: String
            public var gravatarID: String?
            public var htmlURL: URL
            public var id: Int
            public var nodeID: String
            public var login: String
            public var organizationsURL: URL
            public var receivedEventsURL: URL
            public var reposURL: URL
            public var isSiteAdmin: Bool
            public var starredURL: String
            public var subscriptionsURL: URL
            public var type: String
            public var url: URL

            public init(avatarURL: URL, eventsURL: String, followersURL: URL, followingURL: String, gistsURL: String, gravatarID: String? = nil, htmlURL: URL, id: Int, nodeID: String, login: String, organizationsURL: URL, receivedEventsURL: URL, reposURL: URL, isSiteAdmin: Bool, starredURL: String, subscriptionsURL: URL, type: String, url: URL) {
                self.avatarURL = avatarURL
                self.eventsURL = eventsURL
                self.followersURL = followersURL
                self.followingURL = followingURL
                self.gistsURL = gistsURL
                self.gravatarID = gravatarID
                self.htmlURL = htmlURL
                self.id = id
                self.nodeID = nodeID
                self.login = login
                self.organizationsURL = organizationsURL
                self.receivedEventsURL = receivedEventsURL
                self.reposURL = reposURL
                self.isSiteAdmin = isSiteAdmin
                self.starredURL = starredURL
                self.subscriptionsURL = subscriptionsURL
                self.type = type
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
                self.eventsURL = try values.decode(String.self, forKey: "events_url")
                self.followersURL = try values.decode(URL.self, forKey: "followers_url")
                self.followingURL = try values.decode(String.self, forKey: "following_url")
                self.gistsURL = try values.decode(String.self, forKey: "gists_url")
                self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
                self.htmlURL = try values.decode(URL.self, forKey: "html_url")
                self.id = try values.decode(Int.self, forKey: "id")
                self.nodeID = try values.decode(String.self, forKey: "node_id")
                self.login = try values.decode(String.self, forKey: "login")
                self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
                self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
                self.reposURL = try values.decode(URL.self, forKey: "repos_url")
                self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
                self.starredURL = try values.decode(String.self, forKey: "starred_url")
                self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
                self.type = try values.decode(String.self, forKey: "type")
                self.url = try values.decode(URL.self, forKey: "url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(avatarURL, forKey: "avatar_url")
                try values.encode(eventsURL, forKey: "events_url")
                try values.encode(followersURL, forKey: "followers_url")
                try values.encode(followingURL, forKey: "following_url")
                try values.encode(gistsURL, forKey: "gists_url")
                try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
                try values.encode(htmlURL, forKey: "html_url")
                try values.encode(id, forKey: "id")
                try values.encode(nodeID, forKey: "node_id")
                try values.encode(login, forKey: "login")
                try values.encode(organizationsURL, forKey: "organizations_url")
                try values.encode(receivedEventsURL, forKey: "received_events_url")
                try values.encode(reposURL, forKey: "repos_url")
                try values.encode(isSiteAdmin, forKey: "site_admin")
                try values.encode(starredURL, forKey: "starred_url")
                try values.encode(subscriptionsURL, forKey: "subscriptions_url")
                try values.encode(type, forKey: "type")
                try values.encode(url, forKey: "url")
            }
        }

        public init(label: String, ref: String, repo: Repo, sha: String, user: User) {
            self.label = label
            self.ref = ref
            self.repo = repo
            self.sha = sha
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.label = try values.decode(String.self, forKey: "label")
            self.ref = try values.decode(String.self, forKey: "ref")
            self.repo = try values.decode(Repo.self, forKey: "repo")
            self.sha = try values.decode(String.self, forKey: "sha")
            self.user = try values.decode(User.self, forKey: "user")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(label, forKey: "label")
            try values.encode(ref, forKey: "ref")
            try values.encode(repo, forKey: "repo")
            try values.encode(sha, forKey: "sha")
            try values.encode(user, forKey: "user")
        }
    }

    public struct Links: Codable {
        /// Link
        ///
        /// Hypermedia Link
        public var comments: Link
        /// Link
        ///
        /// Hypermedia Link
        public var commits: Link
        /// Link
        ///
        /// Hypermedia Link
        public var statuses: Link
        /// Link
        ///
        /// Hypermedia Link
        public var html: Link
        /// Link
        ///
        /// Hypermedia Link
        public var issue: Link
        /// Link
        ///
        /// Hypermedia Link
        public var reviewComments: Link
        /// Link
        ///
        /// Hypermedia Link
        public var reviewComment: Link
        /// Link
        ///
        /// Hypermedia Link
        public var this: Link

        public init(comments: Link, commits: Link, statuses: Link, html: Link, issue: Link, reviewComments: Link, reviewComment: Link, this: Link) {
            self.comments = comments
            self.commits = commits
            self.statuses = statuses
            self.html = html
            self.issue = issue
            self.reviewComments = reviewComments
            self.reviewComment = reviewComment
            self.this = this
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.comments = try values.decode(Link.self, forKey: "comments")
            self.commits = try values.decode(Link.self, forKey: "commits")
            self.statuses = try values.decode(Link.self, forKey: "statuses")
            self.html = try values.decode(Link.self, forKey: "html")
            self.issue = try values.decode(Link.self, forKey: "issue")
            self.reviewComments = try values.decode(Link.self, forKey: "review_comments")
            self.reviewComment = try values.decode(Link.self, forKey: "review_comment")
            self.this = try values.decode(Link.self, forKey: "self")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(comments, forKey: "comments")
            try values.encode(commits, forKey: "commits")
            try values.encode(statuses, forKey: "statuses")
            try values.encode(html, forKey: "html")
            try values.encode(issue, forKey: "issue")
            try values.encode(reviewComments, forKey: "review_comments")
            try values.encode(reviewComment, forKey: "review_comment")
            try values.encode(this, forKey: "self")
        }
    }

    public init(url: URL, id: Int, nodeID: String, htmlURL: URL, diffURL: URL, patchURL: URL, issueURL: URL, commitsURL: URL, reviewCommentsURL: URL, reviewCommentURL: String, commentsURL: URL, statusesURL: URL, number: Int, state: State, isLocked: Bool, title: String, user: SimpleUser? = nil, body: String? = nil, labels: [Label], milestone: Milestone? = nil, activeLockReason: String? = nil, createdAt: Date, updatedAt: Date, closedAt: Date? = nil, mergedAt: Date? = nil, mergeCommitSha: String? = nil, assignee: SimpleUser? = nil, assignees: [SimpleUser]? = nil, requestedReviewers: [SimpleUser]? = nil, requestedTeams: [TeamSimple]? = nil, head: Head, base: Base, links: Links, authorAssociation: AuthorAssociation, autoMerge: AutoMerge? = nil, isDraft: Bool? = nil, isMerged: Bool, isMergeable: Bool? = nil, isRebaseable: Bool? = nil, mergeableState: String, mergedBy: SimpleUser? = nil, comments: Int, reviewComments: Int, maintainerCanModify: Bool, commits: Int, additions: Int, deletions: Int, changedFiles: Int) {
        self.url = url
        self.id = id
        self.nodeID = nodeID
        self.htmlURL = htmlURL
        self.diffURL = diffURL
        self.patchURL = patchURL
        self.issueURL = issueURL
        self.commitsURL = commitsURL
        self.reviewCommentsURL = reviewCommentsURL
        self.reviewCommentURL = reviewCommentURL
        self.commentsURL = commentsURL
        self.statusesURL = statusesURL
        self.number = number
        self.state = state
        self.isLocked = isLocked
        self.title = title
        self.user = user
        self.body = body
        self.labels = labels
        self.milestone = milestone
        self.activeLockReason = activeLockReason
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.closedAt = closedAt
        self.mergedAt = mergedAt
        self.mergeCommitSha = mergeCommitSha
        self.assignee = assignee
        self.assignees = assignees
        self.requestedReviewers = requestedReviewers
        self.requestedTeams = requestedTeams
        self.head = head
        self.base = base
        self.links = links
        self.authorAssociation = authorAssociation
        self.autoMerge = autoMerge
        self.isDraft = isDraft
        self.isMerged = isMerged
        self.isMergeable = isMergeable
        self.isRebaseable = isRebaseable
        self.mergeableState = mergeableState
        self.mergedBy = mergedBy
        self.comments = comments
        self.reviewComments = reviewComments
        self.maintainerCanModify = maintainerCanModify
        self.commits = commits
        self.additions = additions
        self.deletions = deletions
        self.changedFiles = changedFiles
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.diffURL = try values.decode(URL.self, forKey: "diff_url")
        self.patchURL = try values.decode(URL.self, forKey: "patch_url")
        self.issueURL = try values.decode(URL.self, forKey: "issue_url")
        self.commitsURL = try values.decode(URL.self, forKey: "commits_url")
        self.reviewCommentsURL = try values.decode(URL.self, forKey: "review_comments_url")
        self.reviewCommentURL = try values.decode(String.self, forKey: "review_comment_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.statusesURL = try values.decode(URL.self, forKey: "statuses_url")
        self.number = try values.decode(Int.self, forKey: "number")
        self.state = try values.decode(State.self, forKey: "state")
        self.isLocked = try values.decode(Bool.self, forKey: "locked")
        self.title = try values.decode(String.self, forKey: "title")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.labels = try values.decode([Label].self, forKey: "labels")
        self.milestone = try values.decodeIfPresent(Milestone.self, forKey: "milestone")
        self.activeLockReason = try values.decodeIfPresent(String.self, forKey: "active_lock_reason")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.closedAt = try values.decodeIfPresent(Date.self, forKey: "closed_at")
        self.mergedAt = try values.decodeIfPresent(Date.self, forKey: "merged_at")
        self.mergeCommitSha = try values.decodeIfPresent(String.self, forKey: "merge_commit_sha")
        self.assignee = try values.decodeIfPresent(SimpleUser.self, forKey: "assignee")
        self.assignees = try values.decodeIfPresent([SimpleUser].self, forKey: "assignees")
        self.requestedReviewers = try values.decodeIfPresent([SimpleUser].self, forKey: "requested_reviewers")
        self.requestedTeams = try values.decodeIfPresent([TeamSimple].self, forKey: "requested_teams")
        self.head = try values.decode(Head.self, forKey: "head")
        self.base = try values.decode(Base.self, forKey: "base")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.autoMerge = try values.decodeIfPresent(AutoMerge.self, forKey: "auto_merge")
        self.isDraft = try values.decodeIfPresent(Bool.self, forKey: "draft")
        self.isMerged = try values.decode(Bool.self, forKey: "merged")
        self.isMergeable = try values.decodeIfPresent(Bool.self, forKey: "mergeable")
        self.isRebaseable = try values.decodeIfPresent(Bool.self, forKey: "rebaseable")
        self.mergeableState = try values.decode(String.self, forKey: "mergeable_state")
        self.mergedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "merged_by")
        self.comments = try values.decode(Int.self, forKey: "comments")
        self.reviewComments = try values.decode(Int.self, forKey: "review_comments")
        self.maintainerCanModify = try values.decode(Bool.self, forKey: "maintainer_can_modify")
        self.commits = try values.decode(Int.self, forKey: "commits")
        self.additions = try values.decode(Int.self, forKey: "additions")
        self.deletions = try values.decode(Int.self, forKey: "deletions")
        self.changedFiles = try values.decode(Int.self, forKey: "changed_files")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(diffURL, forKey: "diff_url")
        try values.encode(patchURL, forKey: "patch_url")
        try values.encode(issueURL, forKey: "issue_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(reviewCommentsURL, forKey: "review_comments_url")
        try values.encode(reviewCommentURL, forKey: "review_comment_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(number, forKey: "number")
        try values.encode(state, forKey: "state")
        try values.encode(isLocked, forKey: "locked")
        try values.encode(title, forKey: "title")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(labels, forKey: "labels")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encodeIfPresent(activeLockReason, forKey: "active_lock_reason")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(closedAt, forKey: "closed_at")
        try values.encodeIfPresent(mergedAt, forKey: "merged_at")
        try values.encodeIfPresent(mergeCommitSha, forKey: "merge_commit_sha")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(assignees, forKey: "assignees")
        try values.encodeIfPresent(requestedReviewers, forKey: "requested_reviewers")
        try values.encodeIfPresent(requestedTeams, forKey: "requested_teams")
        try values.encode(head, forKey: "head")
        try values.encode(base, forKey: "base")
        try values.encode(links, forKey: "_links")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(autoMerge, forKey: "auto_merge")
        try values.encodeIfPresent(isDraft, forKey: "draft")
        try values.encode(isMerged, forKey: "merged")
        try values.encodeIfPresent(isMergeable, forKey: "mergeable")
        try values.encodeIfPresent(isRebaseable, forKey: "rebaseable")
        try values.encode(mergeableState, forKey: "mergeable_state")
        try values.encodeIfPresent(mergedBy, forKey: "merged_by")
        try values.encode(comments, forKey: "comments")
        try values.encode(reviewComments, forKey: "review_comments")
        try values.encode(maintainerCanModify, forKey: "maintainer_can_modify")
        try values.encode(commits, forKey: "commits")
        try values.encode(additions, forKey: "additions")
        try values.encode(deletions, forKey: "deletions")
        try values.encode(changedFiles, forKey: "changed_files")
    }
}

public struct PullRequestMergeResult: Codable {
    public var sha: String
    public var isMerged: Bool
    public var message: String

    public init(sha: String, isMerged: Bool, message: String) {
        self.sha = sha
        self.isMerged = isMerged
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decode(String.self, forKey: "sha")
        self.isMerged = try values.decode(Bool.self, forKey: "merged")
        self.message = try values.decode(String.self, forKey: "message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(sha, forKey: "sha")
        try values.encode(isMerged, forKey: "merged")
        try values.encode(message, forKey: "message")
    }
}

public struct PullRequestReviewRequest: Codable {
    public var users: [SimpleUser]
    public var teams: [Team]

    public init(users: [SimpleUser], teams: [Team]) {
        self.users = users
        self.teams = teams
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.users = try values.decode([SimpleUser].self, forKey: "users")
        self.teams = try values.decode([Team].self, forKey: "teams")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(users, forKey: "users")
        try values.encode(teams, forKey: "teams")
    }
}

/// Pull Request Reviews are reviews on pull requests.
public struct PullRequestReview: Codable {
    /// Unique identifier of the review
    ///
    /// Example: 42
    public var id: Int
    /// Example: "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA="
    public var nodeID: String
    /// Simple User
    public var user: SimpleUser?
    /// The text of the review.
    ///
    /// Example: "This looks great."
    public var body: String
    /// Example: "CHANGES_REQUESTED"
    public var state: String
    /// Example: "https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80"
    public var htmlURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/12"
    public var pullRequestURL: URL
    public var links: Links
    public var submittedAt: Date?
    /// A commit SHA for the review.
    ///
    /// Example: "54bb654c9e6025347f57900a4a5c2313a96b8035"
    public var commitID: String
    public var bodyHTML: String?
    public var bodyText: String?
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation

    public struct Links: Codable {
        public var html: HTML
        public var pullRequest: PullRequest

        public struct HTML: Codable {
            public var href: String

            public init(href: String) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(String.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public struct PullRequest: Codable {
            public var href: String

            public init(href: String) {
                self.href = href
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.href = try values.decode(String.self, forKey: "href")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(href, forKey: "href")
            }
        }

        public init(html: HTML, pullRequest: PullRequest) {
            self.html = html
            self.pullRequest = pullRequest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.html = try values.decode(HTML.self, forKey: "html")
            self.pullRequest = try values.decode(PullRequest.self, forKey: "pull_request")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(html, forKey: "html")
            try values.encode(pullRequest, forKey: "pull_request")
        }
    }

    public init(id: Int, nodeID: String, user: SimpleUser? = nil, body: String, state: String, htmlURL: URL, pullRequestURL: URL, links: Links, submittedAt: Date? = nil, commitID: String, bodyHTML: String? = nil, bodyText: String? = nil, authorAssociation: AuthorAssociation) {
        self.id = id
        self.nodeID = nodeID
        self.user = user
        self.body = body
        self.state = state
        self.htmlURL = htmlURL
        self.pullRequestURL = pullRequestURL
        self.links = links
        self.submittedAt = submittedAt
        self.commitID = commitID
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
        self.authorAssociation = authorAssociation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.body = try values.decode(String.self, forKey: "body")
        self.state = try values.decode(String.self, forKey: "state")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.pullRequestURL = try values.decode(URL.self, forKey: "pull_request_url")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.submittedAt = try values.decodeIfPresent(Date.self, forKey: "submitted_at")
        self.commitID = try values.decode(String.self, forKey: "commit_id")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(body, forKey: "body")
        try values.encode(state, forKey: "state")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(pullRequestURL, forKey: "pull_request_url")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(submittedAt, forKey: "submitted_at")
        try values.encode(commitID, forKey: "commit_id")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encode(authorAssociation, forKey: "author_association")
    }
}

/// Legacy Review Comment
public struct ReviewComment: Codable {
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/comments/1"
    public var url: URL
    /// Example: 42
    public var pullRequestReviewID: Int?
    /// Example: 10
    public var id: Int
    /// Example: "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw"
    public var nodeID: String
    /// Example: "@@ -16,33 +16,40 @@ public class Connection : IConnection..."
    public var diffHunk: String
    /// Example: "file1.txt"
    public var path: String
    public var position: Int?
    public var originalPosition: Int
    /// Example: "6dcb09b5b57875f334f61aebed695e2e4193db5e"
    public var commitID: String
    /// Example: "9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840"
    public var originalCommitID: String
    public var inReplyToID: Int?
    /// Simple User
    public var user: SimpleUser?
    /// Example: "Great stuff"
    public var body: String
    /// Example: "2011-04-14T16:00:49Z"
    public var createdAt: Date
    /// Example: "2011-04-14T16:00:49Z"
    public var updatedAt: Date
    /// Example: "https://github.com/octocat/Hello-World/pull/1#discussion-diff-1"
    public var htmlURL: URL
    /// Example: "https://api.github.com/repos/octocat/Hello-World/pulls/1"
    public var pullRequestURL: URL
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    public var links: Links
    public var bodyText: String?
    public var bodyHTML: String?
    /// Reaction Rollup
    public var reactions: ReactionRollup?
    /// The side of the first line of the range for a multi-line comment.
    public var side: Side?
    /// The side of the first line of the range for a multi-line comment.
    public var startSide: StartSide?
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    public var line: Int?
    /// The original line of the blob to which the comment applies. The last line of the range for a multi-line comment
    public var originalLine: Int?
    /// The first line of the range for a multi-line comment.
    public var startLine: Int?
    /// The original first line of the range for a multi-line comment.
    public var originalStartLine: Int?

    public struct Links: Codable {
        /// Link
        ///
        /// Hypermedia Link
        public var this: Link
        /// Link
        ///
        /// Hypermedia Link
        public var html: Link
        /// Link
        ///
        /// Hypermedia Link
        public var pullRequest: Link

        public init(this: Link, html: Link, pullRequest: Link) {
            self.this = this
            self.html = html
            self.pullRequest = pullRequest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.this = try values.decode(Link.self, forKey: "self")
            self.html = try values.decode(Link.self, forKey: "html")
            self.pullRequest = try values.decode(Link.self, forKey: "pull_request")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(this, forKey: "self")
            try values.encode(html, forKey: "html")
            try values.encode(pullRequest, forKey: "pull_request")
        }
    }

    /// The side of the first line of the range for a multi-line comment.
    public enum Side: String, Codable, CaseIterable {
        case left = "LEFT"
        case right = "RIGHT"
    }

    /// The side of the first line of the range for a multi-line comment.
    public enum StartSide: String, Codable, CaseIterable {
        case left = "LEFT"
        case right = "RIGHT"
    }

    public init(url: URL, pullRequestReviewID: Int? = nil, id: Int, nodeID: String, diffHunk: String, path: String, position: Int? = nil, originalPosition: Int, commitID: String, originalCommitID: String, inReplyToID: Int? = nil, user: SimpleUser? = nil, body: String, createdAt: Date, updatedAt: Date, htmlURL: URL, pullRequestURL: URL, authorAssociation: AuthorAssociation, links: Links, bodyText: String? = nil, bodyHTML: String? = nil, reactions: ReactionRollup? = nil, side: Side? = nil, startSide: StartSide? = nil, line: Int? = nil, originalLine: Int? = nil, startLine: Int? = nil, originalStartLine: Int? = nil) {
        self.url = url
        self.pullRequestReviewID = pullRequestReviewID
        self.id = id
        self.nodeID = nodeID
        self.diffHunk = diffHunk
        self.path = path
        self.position = position
        self.originalPosition = originalPosition
        self.commitID = commitID
        self.originalCommitID = originalCommitID
        self.inReplyToID = inReplyToID
        self.user = user
        self.body = body
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.htmlURL = htmlURL
        self.pullRequestURL = pullRequestURL
        self.authorAssociation = authorAssociation
        self.links = links
        self.bodyText = bodyText
        self.bodyHTML = bodyHTML
        self.reactions = reactions
        self.side = side
        self.startSide = startSide
        self.line = line
        self.originalLine = originalLine
        self.startLine = startLine
        self.originalStartLine = originalStartLine
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.pullRequestReviewID = try values.decodeIfPresent(Int.self, forKey: "pull_request_review_id")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.diffHunk = try values.decode(String.self, forKey: "diff_hunk")
        self.path = try values.decode(String.self, forKey: "path")
        self.position = try values.decodeIfPresent(Int.self, forKey: "position")
        self.originalPosition = try values.decode(Int.self, forKey: "original_position")
        self.commitID = try values.decode(String.self, forKey: "commit_id")
        self.originalCommitID = try values.decode(String.self, forKey: "original_commit_id")
        self.inReplyToID = try values.decodeIfPresent(Int.self, forKey: "in_reply_to_id")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.body = try values.decode(String.self, forKey: "body")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.pullRequestURL = try values.decode(URL.self, forKey: "pull_request_url")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.links = try values.decode(Links.self, forKey: "_links")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
        self.side = try values.decodeIfPresent(Side.self, forKey: "side")
        self.startSide = try values.decodeIfPresent(StartSide.self, forKey: "start_side")
        self.line = try values.decodeIfPresent(Int.self, forKey: "line")
        self.originalLine = try values.decodeIfPresent(Int.self, forKey: "original_line")
        self.startLine = try values.decodeIfPresent(Int.self, forKey: "start_line")
        self.originalStartLine = try values.decodeIfPresent(Int.self, forKey: "original_start_line")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encodeIfPresent(pullRequestReviewID, forKey: "pull_request_review_id")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(diffHunk, forKey: "diff_hunk")
        try values.encode(path, forKey: "path")
        try values.encodeIfPresent(position, forKey: "position")
        try values.encode(originalPosition, forKey: "original_position")
        try values.encode(commitID, forKey: "commit_id")
        try values.encode(originalCommitID, forKey: "original_commit_id")
        try values.encodeIfPresent(inReplyToID, forKey: "in_reply_to_id")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(body, forKey: "body")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(pullRequestURL, forKey: "pull_request_url")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encode(links, forKey: "_links")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(reactions, forKey: "reactions")
        try values.encodeIfPresent(side, forKey: "side")
        try values.encodeIfPresent(startSide, forKey: "start_side")
        try values.encodeIfPresent(line, forKey: "line")
        try values.encodeIfPresent(originalLine, forKey: "original_line")
        try values.encodeIfPresent(startLine, forKey: "start_line")
        try values.encodeIfPresent(originalStartLine, forKey: "original_start_line")
    }
}

/// Data related to a release.
public struct ReleaseAsset: Codable {
    public var url: URL
    public var browserDownloadURL: URL
    public var id: Int
    public var nodeID: String
    /// The file name of the asset.
    ///
    /// Example: "Team Environment"
    public var name: String
    public var label: String?
    /// State of the release asset.
    public var state: State
    public var contentType: String
    public var size: Int
    public var downloadCount: Int
    public var createdAt: Date
    public var updatedAt: Date
    /// Simple User
    public var uploader: SimpleUser?

    /// State of the release asset.
    public enum State: String, Codable, CaseIterable {
        case uploaded
        case `open`
    }

    public init(url: URL, browserDownloadURL: URL, id: Int, nodeID: String, name: String, label: String? = nil, state: State, contentType: String, size: Int, downloadCount: Int, createdAt: Date, updatedAt: Date, uploader: SimpleUser? = nil) {
        self.url = url
        self.browserDownloadURL = browserDownloadURL
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.label = label
        self.state = state
        self.contentType = contentType
        self.size = size
        self.downloadCount = downloadCount
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.uploader = uploader
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.browserDownloadURL = try values.decode(URL.self, forKey: "browser_download_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
        self.state = try values.decode(State.self, forKey: "state")
        self.contentType = try values.decode(String.self, forKey: "content_type")
        self.size = try values.decode(Int.self, forKey: "size")
        self.downloadCount = try values.decode(Int.self, forKey: "download_count")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.uploader = try values.decodeIfPresent(SimpleUser.self, forKey: "uploader")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(browserDownloadURL, forKey: "browser_download_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(label, forKey: "label")
        try values.encode(state, forKey: "state")
        try values.encode(contentType, forKey: "content_type")
        try values.encode(size, forKey: "size")
        try values.encode(downloadCount, forKey: "download_count")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(uploader, forKey: "uploader")
    }
}

/// A release.
public struct Release: Codable {
    public var url: URL
    public var htmlURL: URL
    public var assetsURL: URL
    public var uploadURL: String
    public var tarballURL: URL?
    public var zipballURL: URL?
    public var id: Int
    public var nodeID: String
    /// The name of the tag.
    ///
    /// Example: "v1.0.0"
    public var tagName: String
    /// Specifies the commitish value that determines where the Git tag is created from.
    ///
    /// Example: "master"
    public var targetCommitish: String
    public var name: String?
    public var body: String?
    /// True to create a draft (unpublished) release, false to create a published one.
    ///
    /// Example: false
    public var isDraft: Bool
    /// Whether to identify the release as a prerelease or a full release.
    ///
    /// Example: false
    public var isPrerelease: Bool
    public var createdAt: Date
    public var publishedAt: Date?
    /// Simple User
    public var author: SimpleUser
    public var assets: [ReleaseAsset]
    public var bodyHTML: String?
    public var bodyText: String?
    public var mentionsCount: Int?
    /// The URL of the release discussion.
    public var discussionURL: URL?
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public init(url: URL, htmlURL: URL, assetsURL: URL, uploadURL: String, tarballURL: URL? = nil, zipballURL: URL? = nil, id: Int, nodeID: String, tagName: String, targetCommitish: String, name: String? = nil, body: String? = nil, isDraft: Bool, isPrerelease: Bool, createdAt: Date, publishedAt: Date? = nil, author: SimpleUser, assets: [ReleaseAsset], bodyHTML: String? = nil, bodyText: String? = nil, mentionsCount: Int? = nil, discussionURL: URL? = nil, reactions: ReactionRollup? = nil) {
        self.url = url
        self.htmlURL = htmlURL
        self.assetsURL = assetsURL
        self.uploadURL = uploadURL
        self.tarballURL = tarballURL
        self.zipballURL = zipballURL
        self.id = id
        self.nodeID = nodeID
        self.tagName = tagName
        self.targetCommitish = targetCommitish
        self.name = name
        self.body = body
        self.isDraft = isDraft
        self.isPrerelease = isPrerelease
        self.createdAt = createdAt
        self.publishedAt = publishedAt
        self.author = author
        self.assets = assets
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
        self.mentionsCount = mentionsCount
        self.discussionURL = discussionURL
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.assetsURL = try values.decode(URL.self, forKey: "assets_url")
        self.uploadURL = try values.decode(String.self, forKey: "upload_url")
        self.tarballURL = try values.decodeIfPresent(URL.self, forKey: "tarball_url")
        self.zipballURL = try values.decodeIfPresent(URL.self, forKey: "zipball_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.tagName = try values.decode(String.self, forKey: "tag_name")
        self.targetCommitish = try values.decode(String.self, forKey: "target_commitish")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.isDraft = try values.decode(Bool.self, forKey: "draft")
        self.isPrerelease = try values.decode(Bool.self, forKey: "prerelease")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.publishedAt = try values.decodeIfPresent(Date.self, forKey: "published_at")
        self.author = try values.decode(SimpleUser.self, forKey: "author")
        self.assets = try values.decode([ReleaseAsset].self, forKey: "assets")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.mentionsCount = try values.decodeIfPresent(Int.self, forKey: "mentions_count")
        self.discussionURL = try values.decodeIfPresent(URL.self, forKey: "discussion_url")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(assetsURL, forKey: "assets_url")
        try values.encode(uploadURL, forKey: "upload_url")
        try values.encodeIfPresent(tarballURL, forKey: "tarball_url")
        try values.encodeIfPresent(zipballURL, forKey: "zipball_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(tagName, forKey: "tag_name")
        try values.encode(targetCommitish, forKey: "target_commitish")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(isDraft, forKey: "draft")
        try values.encode(isPrerelease, forKey: "prerelease")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(publishedAt, forKey: "published_at")
        try values.encode(author, forKey: "author")
        try values.encode(assets, forKey: "assets")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(mentionsCount, forKey: "mentions_count")
        try values.encodeIfPresent(discussionURL, forKey: "discussion_url")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

/// Generated Release Notes Content
///
/// Generated name and body describing a release
public struct ReleaseNotesContent: Codable {
    /// The generated name of the release
    ///
    /// Example: "Release v1.0.0 is now available!"
    public var name: String
    /// The generated body describing the contents of the release supporting markdown formatting
    public var body: String

    public init(name: String, body: String) {
        self.name = name
        self.body = body
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.body = try values.decode(String.self, forKey: "body")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(body, forKey: "body")
    }
}

public struct SecretScanningAlert: Codable {
    /// The security alert number.
    public var number: Int?
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var createdAt: Date?
    /// The REST API URL of the alert resource.
    public var url: URL?
    /// The GitHub URL of the alert resource.
    public var htmlURL: URL?
    /// The REST API URL of the code locations for this alert.
    public var locationsURL: URL?
    /// Sets the state of the secret scanning alert. Can be either `open` or `resolved`. You must provide `resolution` when you set the state to `resolved`.
    public var state: SecretScanningAlertState?
    /// **Required when the `state` is `resolved`.** The reason for resolving the alert. Can be one of `false_positive`, `wont_fix`, `revoked`, or `used_in_tests`.
    public var resolution: SecretScanningAlertResolution?
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    public var resolvedAt: Date?
    /// Simple User
    public var resolvedBy: SimpleUser?
    /// The type of secret that secret scanning detected.
    public var secretType: String?
    /// The secret that was detected.
    public var secret: String?

    public init(number: Int? = nil, createdAt: Date? = nil, url: URL? = nil, htmlURL: URL? = nil, locationsURL: URL? = nil, state: SecretScanningAlertState? = nil, resolution: SecretScanningAlertResolution? = nil, resolvedAt: Date? = nil, resolvedBy: SimpleUser? = nil, secretType: String? = nil, secret: String? = nil) {
        self.number = number
        self.createdAt = createdAt
        self.url = url
        self.htmlURL = htmlURL
        self.locationsURL = locationsURL
        self.state = state
        self.resolution = resolution
        self.resolvedAt = resolvedAt
        self.resolvedBy = resolvedBy
        self.secretType = secretType
        self.secret = secret
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.number = try values.decodeIfPresent(Int.self, forKey: "number")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
        self.locationsURL = try values.decodeIfPresent(URL.self, forKey: "locations_url")
        self.state = try values.decodeIfPresent(SecretScanningAlertState.self, forKey: "state")
        self.resolution = try values.decodeIfPresent(SecretScanningAlertResolution.self, forKey: "resolution")
        self.resolvedAt = try values.decodeIfPresent(Date.self, forKey: "resolved_at")
        self.resolvedBy = try values.decodeIfPresent(SimpleUser.self, forKey: "resolved_by")
        self.secretType = try values.decodeIfPresent(String.self, forKey: "secret_type")
        self.secret = try values.decodeIfPresent(String.self, forKey: "secret")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(number, forKey: "number")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(locationsURL, forKey: "locations_url")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(resolution, forKey: "resolution")
        try values.encodeIfPresent(resolvedAt, forKey: "resolved_at")
        try values.encodeIfPresent(resolvedBy, forKey: "resolved_by")
        try values.encodeIfPresent(secretType, forKey: "secret_type")
        try values.encodeIfPresent(secret, forKey: "secret")
    }
}

/// Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
public struct SecretScanningLocationCommit: Codable {
    /// The file path in the repository
    ///
    /// Example: "/example/secrets.txt"
    public var path: String
    /// Line number at which the secret starts in the file
    public var startLine: Double
    /// Line number at which the secret ends in the file
    public var endLine: Double
    /// The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII
    public var startColumn: Double
    /// The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII
    public var endColumn: Double
    /// SHA-1 hash ID of the associated blob
    ///
    /// Example: "af5626b4a114abcb82d63db7c8082c3c4756e51b"
    public var blobSha: String
    /// The API URL to get the associated blob resource
    public var blobURL: String
    /// SHA-1 hash ID of the associated commit
    ///
    /// Example: "af5626b4a114abcb82d63db7c8082c3c4756e51b"
    public var commitSha: String
    /// The API URL to get the associated commit resource
    public var commitURL: String

    public init(path: String, startLine: Double, endLine: Double, startColumn: Double, endColumn: Double, blobSha: String, blobURL: String, commitSha: String, commitURL: String) {
        self.path = path
        self.startLine = startLine
        self.endLine = endLine
        self.startColumn = startColumn
        self.endColumn = endColumn
        self.blobSha = blobSha
        self.blobURL = blobURL
        self.commitSha = commitSha
        self.commitURL = commitURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.path = try values.decode(String.self, forKey: "path")
        self.startLine = try values.decode(Double.self, forKey: "start_line")
        self.endLine = try values.decode(Double.self, forKey: "end_line")
        self.startColumn = try values.decode(Double.self, forKey: "start_column")
        self.endColumn = try values.decode(Double.self, forKey: "end_column")
        self.blobSha = try values.decode(String.self, forKey: "blob_sha")
        self.blobURL = try values.decode(String.self, forKey: "blob_url")
        self.commitSha = try values.decode(String.self, forKey: "commit_sha")
        self.commitURL = try values.decode(String.self, forKey: "commit_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(path, forKey: "path")
        try values.encode(startLine, forKey: "start_line")
        try values.encode(endLine, forKey: "end_line")
        try values.encode(startColumn, forKey: "start_column")
        try values.encode(endColumn, forKey: "end_column")
        try values.encode(blobSha, forKey: "blob_sha")
        try values.encode(blobURL, forKey: "blob_url")
        try values.encode(commitSha, forKey: "commit_sha")
        try values.encode(commitURL, forKey: "commit_url")
    }
}

public struct SecretScanningLocation: Codable {
    /// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues), this field identifies the type of resource where the secret was found.
    ///
    /// Example: "commit"
    public var type: `Type`
    public var details: SecretScanningLocationCommit

    /// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues), this field identifies the type of resource where the secret was found.
    ///
    /// Example: "commit"
    public enum `Type`: String, Codable, CaseIterable {
        case commit
    }

    public init(type: `Type`, details: SecretScanningLocationCommit) {
        self.type = type
        self.details = details
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.details = try values.decode(SecretScanningLocationCommit.self, forKey: "details")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(details, forKey: "details")
    }
}

public struct Stargazer: Codable {
    public var starredAt: Date
    /// Simple User
    public var user: SimpleUser?

    public init(starredAt: Date, user: SimpleUser? = nil) {
        self.starredAt = starredAt
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.starredAt = try values.decode(Date.self, forKey: "starred_at")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(starredAt, forKey: "starred_at")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct CommitActivity: Codable {
    /// Example: [0, 3, 26, 20, 39, 1, 0]
    public var days: [Int]
    /// Example: 89
    public var total: Int
    /// Example: 1336280400
    public var week: Int

    public init(days: [Int], total: Int, week: Int) {
        self.days = days
        self.total = total
        self.week = week
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.days = try values.decode([Int].self, forKey: "days")
        self.total = try values.decode(Int.self, forKey: "total")
        self.week = try values.decode(Int.self, forKey: "week")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(days, forKey: "days")
        try values.encode(total, forKey: "total")
        try values.encode(week, forKey: "week")
    }
}

public struct ContributorActivity: Codable {
    /// Simple User
    public var author: SimpleUser?
    /// Example: 135
    public var total: Int
    /// Example:
    ///
    /// [
    ///   {
    ///     "a" : 6898,
    ///     "c" : 10,
    ///     "d" : 77,
    ///     "w" : "1367712000"
    ///   }
    /// ]
    public var weeks: [Week]

    public struct Week: Codable {
        public var w: Int?
        public var a: Int?
        public var d: Int?
        public var c: Int?

        public init(w: Int? = nil, a: Int? = nil, d: Int? = nil, c: Int? = nil) {
            self.w = w
            self.a = a
            self.d = d
            self.c = c
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.w = try values.decodeIfPresent(Int.self, forKey: "w")
            self.a = try values.decodeIfPresent(Int.self, forKey: "a")
            self.d = try values.decodeIfPresent(Int.self, forKey: "d")
            self.c = try values.decodeIfPresent(Int.self, forKey: "c")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(w, forKey: "w")
            try values.encodeIfPresent(a, forKey: "a")
            try values.encodeIfPresent(d, forKey: "d")
            try values.encodeIfPresent(c, forKey: "c")
        }
    }

    public init(author: SimpleUser? = nil, total: Int, weeks: [Week]) {
        self.author = author
        self.total = total
        self.weeks = weeks
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.author = try values.decodeIfPresent(SimpleUser.self, forKey: "author")
        self.total = try values.decode(Int.self, forKey: "total")
        self.weeks = try values.decode([Week].self, forKey: "weeks")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(author, forKey: "author")
        try values.encode(total, forKey: "total")
        try values.encode(weeks, forKey: "weeks")
    }
}

public struct ParticipationStats: Codable {
    public var all: [Int]
    public var owner: [Int]

    public init(all: [Int], owner: [Int]) {
        self.all = all
        self.owner = owner
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.all = try values.decode([Int].self, forKey: "all")
        self.owner = try values.decode([Int].self, forKey: "owner")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(all, forKey: "all")
        try values.encode(owner, forKey: "owner")
    }
}

/// Repository Invitation
///
/// Repository invitations let you manage who you collaborate with.
public struct RepositorySubscription: Codable {
    /// Determines if notifications should be received from this repository.
    ///
    /// Example: true
    public var isSubscribed: Bool
    /// Determines if all notifications should be blocked from this repository.
    public var isIgnored: Bool
    public var reason: String?
    /// Example: "2012-10-06T21:34:12Z"
    public var createdAt: Date
    /// Example: "https://api.github.com/repos/octocat/example/subscription"
    public var url: URL
    /// Example: "https://api.github.com/repos/octocat/example"
    public var repositoryURL: URL

    public init(isSubscribed: Bool, isIgnored: Bool, reason: String? = nil, createdAt: Date, url: URL, repositoryURL: URL) {
        self.isSubscribed = isSubscribed
        self.isIgnored = isIgnored
        self.reason = reason
        self.createdAt = createdAt
        self.url = url
        self.repositoryURL = repositoryURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isSubscribed = try values.decode(Bool.self, forKey: "subscribed")
        self.isIgnored = try values.decode(Bool.self, forKey: "ignored")
        self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.url = try values.decode(URL.self, forKey: "url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(isSubscribed, forKey: "subscribed")
        try values.encode(isIgnored, forKey: "ignored")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(url, forKey: "url")
        try values.encode(repositoryURL, forKey: "repository_url")
    }
}

public struct Tag: Codable {
    /// Example: "v0.1"
    public var name: String
    public var commit: Commit
    /// Example: "https://github.com/octocat/Hello-World/zipball/v0.1"
    public var zipballURL: URL
    /// Example: "https://github.com/octocat/Hello-World/tarball/v0.1"
    public var tarballURL: URL
    public var nodeID: String

    public struct Commit: Codable {
        public var sha: String
        public var url: URL

        public init(sha: String, url: URL) {
            self.sha = sha
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sha = try values.decode(String.self, forKey: "sha")
            self.url = try values.decode(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sha, forKey: "sha")
            try values.encode(url, forKey: "url")
        }
    }

    public init(name: String, commit: Commit, zipballURL: URL, tarballURL: URL, nodeID: String) {
        self.name = name
        self.commit = commit
        self.zipballURL = zipballURL
        self.tarballURL = tarballURL
        self.nodeID = nodeID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.zipballURL = try values.decode(URL.self, forKey: "zipball_url")
        self.tarballURL = try values.decode(URL.self, forKey: "tarball_url")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(commit, forKey: "commit")
        try values.encode(zipballURL, forKey: "zipball_url")
        try values.encode(tarballURL, forKey: "tarball_url")
        try values.encode(nodeID, forKey: "node_id")
    }
}

/// A topic aggregates entities that are related to a subject.
public struct Topic: Codable {
    public var names: [String]

    public init(names: [String]) {
        self.names = names
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.names = try values.decode([String].self, forKey: "names")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(names, forKey: "names")
    }
}

public struct Traffic: Codable {
    public var timestamp: Date
    public var uniques: Int
    public var count: Int

    public init(timestamp: Date, uniques: Int, count: Int) {
        self.timestamp = timestamp
        self.uniques = uniques
        self.count = count
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.uniques = try values.decode(Int.self, forKey: "uniques")
        self.count = try values.decode(Int.self, forKey: "count")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(uniques, forKey: "uniques")
        try values.encode(count, forKey: "count")
    }
}

public struct CloneTraffic: Codable {
    /// Example: 173
    public var count: Int
    /// Example: 128
    public var uniques: Int
    public var clones: [Traffic]

    public init(count: Int, uniques: Int, clones: [Traffic]) {
        self.count = count
        self.uniques = uniques
        self.clones = clones
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.count = try values.decode(Int.self, forKey: "count")
        self.uniques = try values.decode(Int.self, forKey: "uniques")
        self.clones = try values.decode([Traffic].self, forKey: "clones")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(count, forKey: "count")
        try values.encode(uniques, forKey: "uniques")
        try values.encode(clones, forKey: "clones")
    }
}

public struct ContentTraffic: Codable {
    /// Example: "/github/hubot"
    public var path: String
    /// Example: "github/hubot: A customizable life embetterment robot."
    public var title: String
    /// Example: 3542
    public var count: Int
    /// Example: 2225
    public var uniques: Int

    public init(path: String, title: String, count: Int, uniques: Int) {
        self.path = path
        self.title = title
        self.count = count
        self.uniques = uniques
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.path = try values.decode(String.self, forKey: "path")
        self.title = try values.decode(String.self, forKey: "title")
        self.count = try values.decode(Int.self, forKey: "count")
        self.uniques = try values.decode(Int.self, forKey: "uniques")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(path, forKey: "path")
        try values.encode(title, forKey: "title")
        try values.encode(count, forKey: "count")
        try values.encode(uniques, forKey: "uniques")
    }
}

public struct ReferrerTraffic: Codable {
    /// Example: "Google"
    public var referrer: String
    public var count: Int
    public var uniques: Int

    public init(referrer: String, count: Int, uniques: Int) {
        self.referrer = referrer
        self.count = count
        self.uniques = uniques
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.referrer = try values.decode(String.self, forKey: "referrer")
        self.count = try values.decode(Int.self, forKey: "count")
        self.uniques = try values.decode(Int.self, forKey: "uniques")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(referrer, forKey: "referrer")
        try values.encode(count, forKey: "count")
        try values.encode(uniques, forKey: "uniques")
    }
}

public struct ViewTraffic: Codable {
    /// Example: 14850
    public var count: Int
    /// Example: 3782
    public var uniques: Int
    public var views: [Traffic]

    public init(count: Int, uniques: Int, views: [Traffic]) {
        self.count = count
        self.uniques = uniques
        self.views = views
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.count = try values.decode(Int.self, forKey: "count")
        self.uniques = try values.decode(Int.self, forKey: "uniques")
        self.views = try values.decode([Traffic].self, forKey: "views")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(count, forKey: "count")
        try values.encode(uniques, forKey: "uniques")
        try values.encode(views, forKey: "views")
    }
}

public struct ScimGroupListEnterprise: Codable {
    public var schemas: [String]
    public var totalResults: Double
    public var itemsPerPage: Double
    public var startIndex: Double
    public var resources: [Resource]

    public struct Resource: Codable {
        public var schemas: [String]
        public var id: String
        public var externalID: String?
        public var displayName: String?
        public var members: [Member]?
        public var meta: Meta?

        public struct Member: Codable {
            public var value: String?
            public var ref: String?
            public var display: String?

            public init(value: String? = nil, ref: String? = nil, display: String? = nil) {
                self.value = value
                self.ref = ref
                self.display = display
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.value = try values.decodeIfPresent(String.self, forKey: "value")
                self.ref = try values.decodeIfPresent(String.self, forKey: "$ref")
                self.display = try values.decodeIfPresent(String.self, forKey: "display")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(value, forKey: "value")
                try values.encodeIfPresent(ref, forKey: "$ref")
                try values.encodeIfPresent(display, forKey: "display")
            }
        }

        public struct Meta: Codable {
            public var resourceType: String?
            public var created: String?
            public var lastModified: String?
            public var location: String?

            public init(resourceType: String? = nil, created: String? = nil, lastModified: String? = nil, location: String? = nil) {
                self.resourceType = resourceType
                self.created = created
                self.lastModified = lastModified
                self.location = location
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.resourceType = try values.decodeIfPresent(String.self, forKey: "resourceType")
                self.created = try values.decodeIfPresent(String.self, forKey: "created")
                self.lastModified = try values.decodeIfPresent(String.self, forKey: "lastModified")
                self.location = try values.decodeIfPresent(String.self, forKey: "location")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(resourceType, forKey: "resourceType")
                try values.encodeIfPresent(created, forKey: "created")
                try values.encodeIfPresent(lastModified, forKey: "lastModified")
                try values.encodeIfPresent(location, forKey: "location")
            }
        }

        public init(schemas: [String], id: String, externalID: String? = nil, displayName: String? = nil, members: [Member]? = nil, meta: Meta? = nil) {
            self.schemas = schemas
            self.id = id
            self.externalID = externalID
            self.displayName = displayName
            self.members = members
            self.meta = meta
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.schemas = try values.decode([String].self, forKey: "schemas")
            self.id = try values.decode(String.self, forKey: "id")
            self.externalID = try values.decodeIfPresent(String.self, forKey: "externalId")
            self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
            self.members = try values.decodeIfPresent([Member].self, forKey: "members")
            self.meta = try values.decodeIfPresent(Meta.self, forKey: "meta")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(schemas, forKey: "schemas")
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(externalID, forKey: "externalId")
            try values.encodeIfPresent(displayName, forKey: "displayName")
            try values.encodeIfPresent(members, forKey: "members")
            try values.encodeIfPresent(meta, forKey: "meta")
        }
    }

    public init(schemas: [String], totalResults: Double, itemsPerPage: Double, startIndex: Double, resources: [Resource]) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.itemsPerPage = itemsPerPage
        self.startIndex = startIndex
        self.resources = resources
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.totalResults = try values.decode(Double.self, forKey: "totalResults")
        self.itemsPerPage = try values.decode(Double.self, forKey: "itemsPerPage")
        self.startIndex = try values.decode(Double.self, forKey: "startIndex")
        self.resources = try values.decode([Resource].self, forKey: "Resources")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(totalResults, forKey: "totalResults")
        try values.encode(itemsPerPage, forKey: "itemsPerPage")
        try values.encode(startIndex, forKey: "startIndex")
        try values.encode(resources, forKey: "Resources")
    }
}

public struct ScimEnterpriseGroup: Codable {
    public var schemas: [String]
    public var id: String
    public var externalID: String?
    public var displayName: String?
    public var members: [Member]?
    public var meta: Meta?

    public struct Member: Codable {
        public var value: String?
        public var ref: String?
        public var display: String?

        public init(value: String? = nil, ref: String? = nil, display: String? = nil) {
            self.value = value
            self.ref = ref
            self.display = display
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.value = try values.decodeIfPresent(String.self, forKey: "value")
            self.ref = try values.decodeIfPresent(String.self, forKey: "$ref")
            self.display = try values.decodeIfPresent(String.self, forKey: "display")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(value, forKey: "value")
            try values.encodeIfPresent(ref, forKey: "$ref")
            try values.encodeIfPresent(display, forKey: "display")
        }
    }

    public struct Meta: Codable {
        public var resourceType: String?
        public var created: String?
        public var lastModified: String?
        public var location: String?

        public init(resourceType: String? = nil, created: String? = nil, lastModified: String? = nil, location: String? = nil) {
            self.resourceType = resourceType
            self.created = created
            self.lastModified = lastModified
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.resourceType = try values.decodeIfPresent(String.self, forKey: "resourceType")
            self.created = try values.decodeIfPresent(String.self, forKey: "created")
            self.lastModified = try values.decodeIfPresent(String.self, forKey: "lastModified")
            self.location = try values.decodeIfPresent(String.self, forKey: "location")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(resourceType, forKey: "resourceType")
            try values.encodeIfPresent(created, forKey: "created")
            try values.encodeIfPresent(lastModified, forKey: "lastModified")
            try values.encodeIfPresent(location, forKey: "location")
        }
    }

    public init(schemas: [String], id: String, externalID: String? = nil, displayName: String? = nil, members: [Member]? = nil, meta: Meta? = nil) {
        self.schemas = schemas
        self.id = id
        self.externalID = externalID
        self.displayName = displayName
        self.members = members
        self.meta = meta
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.id = try values.decode(String.self, forKey: "id")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "externalId")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.members = try values.decodeIfPresent([Member].self, forKey: "members")
        self.meta = try values.decodeIfPresent(Meta.self, forKey: "meta")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(externalID, forKey: "externalId")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encodeIfPresent(members, forKey: "members")
        try values.encodeIfPresent(meta, forKey: "meta")
    }
}

public struct ScimUserListEnterprise: Codable {
    public var schemas: [String]
    public var totalResults: Double
    public var itemsPerPage: Double
    public var startIndex: Double
    public var resources: [Resource]

    public struct Resource: Codable {
        public var schemas: [String]
        public var id: String
        public var externalID: String?
        public var userName: String?
        public var name: Name?
        public var emails: [Email]?
        public var groups: [Group]?
        public var isActive: Bool?
        public var meta: Meta?

        public struct Name: Codable {
            public var givenName: String?
            public var familyName: String?

            public init(givenName: String? = nil, familyName: String? = nil) {
                self.givenName = givenName
                self.familyName = familyName
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.givenName = try values.decodeIfPresent(String.self, forKey: "givenName")
                self.familyName = try values.decodeIfPresent(String.self, forKey: "familyName")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(givenName, forKey: "givenName")
                try values.encodeIfPresent(familyName, forKey: "familyName")
            }
        }

        public struct Email: Codable {
            public var value: String?
            public var isPrimary: Bool?
            public var type: String?

            public init(value: String? = nil, isPrimary: Bool? = nil, type: String? = nil) {
                self.value = value
                self.isPrimary = isPrimary
                self.type = type
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.value = try values.decodeIfPresent(String.self, forKey: "value")
                self.isPrimary = try values.decodeIfPresent(Bool.self, forKey: "primary")
                self.type = try values.decodeIfPresent(String.self, forKey: "type")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(value, forKey: "value")
                try values.encodeIfPresent(isPrimary, forKey: "primary")
                try values.encodeIfPresent(type, forKey: "type")
            }
        }

        public struct Group: Codable {
            public var value: String?

            public init(value: String? = nil) {
                self.value = value
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.value = try values.decodeIfPresent(String.self, forKey: "value")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(value, forKey: "value")
            }
        }

        public struct Meta: Codable {
            public var resourceType: String?
            public var created: String?
            public var lastModified: String?
            public var location: String?

            public init(resourceType: String? = nil, created: String? = nil, lastModified: String? = nil, location: String? = nil) {
                self.resourceType = resourceType
                self.created = created
                self.lastModified = lastModified
                self.location = location
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.resourceType = try values.decodeIfPresent(String.self, forKey: "resourceType")
                self.created = try values.decodeIfPresent(String.self, forKey: "created")
                self.lastModified = try values.decodeIfPresent(String.self, forKey: "lastModified")
                self.location = try values.decodeIfPresent(String.self, forKey: "location")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(resourceType, forKey: "resourceType")
                try values.encodeIfPresent(created, forKey: "created")
                try values.encodeIfPresent(lastModified, forKey: "lastModified")
                try values.encodeIfPresent(location, forKey: "location")
            }
        }

        public init(schemas: [String], id: String, externalID: String? = nil, userName: String? = nil, name: Name? = nil, emails: [Email]? = nil, groups: [Group]? = nil, isActive: Bool? = nil, meta: Meta? = nil) {
            self.schemas = schemas
            self.id = id
            self.externalID = externalID
            self.userName = userName
            self.name = name
            self.emails = emails
            self.groups = groups
            self.isActive = isActive
            self.meta = meta
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.schemas = try values.decode([String].self, forKey: "schemas")
            self.id = try values.decode(String.self, forKey: "id")
            self.externalID = try values.decodeIfPresent(String.self, forKey: "externalId")
            self.userName = try values.decodeIfPresent(String.self, forKey: "userName")
            self.name = try values.decodeIfPresent(Name.self, forKey: "name")
            self.emails = try values.decodeIfPresent([Email].self, forKey: "emails")
            self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
            self.isActive = try values.decodeIfPresent(Bool.self, forKey: "active")
            self.meta = try values.decodeIfPresent(Meta.self, forKey: "meta")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(schemas, forKey: "schemas")
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(externalID, forKey: "externalId")
            try values.encodeIfPresent(userName, forKey: "userName")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(emails, forKey: "emails")
            try values.encodeIfPresent(groups, forKey: "groups")
            try values.encodeIfPresent(isActive, forKey: "active")
            try values.encodeIfPresent(meta, forKey: "meta")
        }
    }

    public init(schemas: [String], totalResults: Double, itemsPerPage: Double, startIndex: Double, resources: [Resource]) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.itemsPerPage = itemsPerPage
        self.startIndex = startIndex
        self.resources = resources
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.totalResults = try values.decode(Double.self, forKey: "totalResults")
        self.itemsPerPage = try values.decode(Double.self, forKey: "itemsPerPage")
        self.startIndex = try values.decode(Double.self, forKey: "startIndex")
        self.resources = try values.decode([Resource].self, forKey: "Resources")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(totalResults, forKey: "totalResults")
        try values.encode(itemsPerPage, forKey: "itemsPerPage")
        try values.encode(startIndex, forKey: "startIndex")
        try values.encode(resources, forKey: "Resources")
    }
}

public struct ScimEnterpriseUser: Codable {
    public var schemas: [String]
    public var id: String
    public var externalID: String?
    public var userName: String?
    public var name: Name?
    public var emails: [Email]?
    public var groups: [Group]?
    public var isActive: Bool?
    public var meta: Meta?

    public struct Name: Codable {
        public var givenName: String?
        public var familyName: String?

        public init(givenName: String? = nil, familyName: String? = nil) {
            self.givenName = givenName
            self.familyName = familyName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.givenName = try values.decodeIfPresent(String.self, forKey: "givenName")
            self.familyName = try values.decodeIfPresent(String.self, forKey: "familyName")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(givenName, forKey: "givenName")
            try values.encodeIfPresent(familyName, forKey: "familyName")
        }
    }

    public struct Email: Codable {
        public var value: String?
        public var type: String?
        public var isPrimary: Bool?

        public init(value: String? = nil, type: String? = nil, isPrimary: Bool? = nil) {
            self.value = value
            self.type = type
            self.isPrimary = isPrimary
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.value = try values.decodeIfPresent(String.self, forKey: "value")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.isPrimary = try values.decodeIfPresent(Bool.self, forKey: "primary")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(value, forKey: "value")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(isPrimary, forKey: "primary")
        }
    }

    public struct Group: Codable {
        public var value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.value = try values.decodeIfPresent(String.self, forKey: "value")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(value, forKey: "value")
        }
    }

    public struct Meta: Codable {
        public var resourceType: String?
        public var created: String?
        public var lastModified: String?
        public var location: String?

        public init(resourceType: String? = nil, created: String? = nil, lastModified: String? = nil, location: String? = nil) {
            self.resourceType = resourceType
            self.created = created
            self.lastModified = lastModified
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.resourceType = try values.decodeIfPresent(String.self, forKey: "resourceType")
            self.created = try values.decodeIfPresent(String.self, forKey: "created")
            self.lastModified = try values.decodeIfPresent(String.self, forKey: "lastModified")
            self.location = try values.decodeIfPresent(String.self, forKey: "location")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(resourceType, forKey: "resourceType")
            try values.encodeIfPresent(created, forKey: "created")
            try values.encodeIfPresent(lastModified, forKey: "lastModified")
            try values.encodeIfPresent(location, forKey: "location")
        }
    }

    public init(schemas: [String], id: String, externalID: String? = nil, userName: String? = nil, name: Name? = nil, emails: [Email]? = nil, groups: [Group]? = nil, isActive: Bool? = nil, meta: Meta? = nil) {
        self.schemas = schemas
        self.id = id
        self.externalID = externalID
        self.userName = userName
        self.name = name
        self.emails = emails
        self.groups = groups
        self.isActive = isActive
        self.meta = meta
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.id = try values.decode(String.self, forKey: "id")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "externalId")
        self.userName = try values.decodeIfPresent(String.self, forKey: "userName")
        self.name = try values.decodeIfPresent(Name.self, forKey: "name")
        self.emails = try values.decodeIfPresent([Email].self, forKey: "emails")
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
        self.isActive = try values.decodeIfPresent(Bool.self, forKey: "active")
        self.meta = try values.decodeIfPresent(Meta.self, forKey: "meta")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(externalID, forKey: "externalId")
        try values.encodeIfPresent(userName, forKey: "userName")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(emails, forKey: "emails")
        try values.encodeIfPresent(groups, forKey: "groups")
        try values.encodeIfPresent(isActive, forKey: "active")
        try values.encodeIfPresent(meta, forKey: "meta")
    }
}

/// SCIM /Users
///
/// SCIM /Users provisioning endpoints
public struct ScimUser: Codable {
    /// SCIM schema used.
    public var schemas: [String]
    /// Unique identifier of an external identity
    ///
    /// Example: "1b78eada-9baa-11e6-9eb6-a431576d590e"
    public var id: String
    /// The ID of the User.
    ///
    /// Example: "a7b0f98395"
    public var externalID: String?
    /// Configured by the admin. Could be an email, login, or username
    ///
    /// Example: "someone@example.com"
    public var userName: String?
    /// The name of the user, suitable for display to end-users
    ///
    /// Example: "Jon Doe"
    public var displayName: String?
    /// Example:
    ///
    /// {
    ///   "familyName" : "User",
    ///   "givenName" : "Jane"
    /// }
    public var name: Name
    /// User emails
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "primary" : true,
    ///     "value" : "someone@example.com"
    ///   },
    ///   {
    ///     "primary" : false,
    ///     "value" : "another@example.com"
    ///   }
    /// ]
    public var emails: [Email]
    /// The active status of the User.
    ///
    /// Example: true
    public var isActive: Bool
    public var meta: Meta
    /// The ID of the organization.
    public var organizationID: Int?
    /// Set of operations to be performed
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "op" : "replace",
    ///     "value" : {
    ///       "active" : false
    ///     }
    ///   }
    /// ]
    public var operations: [Operation]?
    /// Associated groups
    public var groups: [Group]?

    /// Example:
    ///
    /// {
    ///   "familyName" : "User",
    ///   "givenName" : "Jane"
    /// }
    public struct Name: Codable {
        public var givenName: String?
        public var familyName: String?
        public var formatted: String?

        public init(givenName: String? = nil, familyName: String? = nil, formatted: String? = nil) {
            self.givenName = givenName
            self.familyName = familyName
            self.formatted = formatted
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.givenName = try values.decodeIfPresent(String.self, forKey: "givenName")
            self.familyName = try values.decodeIfPresent(String.self, forKey: "familyName")
            self.formatted = try values.decodeIfPresent(String.self, forKey: "formatted")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(givenName, forKey: "givenName")
            try values.encodeIfPresent(familyName, forKey: "familyName")
            try values.encodeIfPresent(formatted, forKey: "formatted")
        }
    }

    public struct Email: Codable {
        public var value: String
        public var isPrimary: Bool?

        public init(value: String, isPrimary: Bool? = nil) {
            self.value = value
            self.isPrimary = isPrimary
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.value = try values.decode(String.self, forKey: "value")
            self.isPrimary = try values.decodeIfPresent(Bool.self, forKey: "primary")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(value, forKey: "value")
            try values.encodeIfPresent(isPrimary, forKey: "primary")
        }
    }

    public struct Meta: Codable {
        /// Example: "User"
        public var resourceType: String?
        /// Example: "2019-01-24T22:45:36.000Z"
        public var created: Date?
        /// Example: "2019-01-24T22:45:36.000Z"
        public var lastModified: Date?
        /// Example: "https://api.github.com/scim/v2/organizations/myorg-123abc55141bfd8f/Users/c42772b5-2029-11e9-8543-9264a97dec8d"
        public var location: URL?

        public init(resourceType: String? = nil, created: Date? = nil, lastModified: Date? = nil, location: URL? = nil) {
            self.resourceType = resourceType
            self.created = created
            self.lastModified = lastModified
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.resourceType = try values.decodeIfPresent(String.self, forKey: "resourceType")
            self.created = try values.decodeIfPresent(Date.self, forKey: "created")
            self.lastModified = try values.decodeIfPresent(Date.self, forKey: "lastModified")
            self.location = try values.decodeIfPresent(URL.self, forKey: "location")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(resourceType, forKey: "resourceType")
            try values.encodeIfPresent(created, forKey: "created")
            try values.encodeIfPresent(lastModified, forKey: "lastModified")
            try values.encodeIfPresent(location, forKey: "location")
        }
    }

    public struct Operation: Codable {
        public var op: Op
        public var path: String?
        public var value: Value?

        public enum Op: String, Codable, CaseIterable {
            case add
            case remove
            case replace
        }

        public enum Value: Codable {
            case string(String)
            case object([String: AnyJSON])
            case anyJSONs([AnyJSON])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(String.self) {
                    self = .string(value)
                } else if let value = try? container.decode([String: AnyJSON].self) {
                    self = .object(value)
                } else if let value = try? container.decode([AnyJSON].self) {
                    self = .anyJSONs(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .string(let value): try container.encode(value)
                case .object(let value): try container.encode(value)
                case .anyJSONs(let value): try container.encode(value)
                }
            }
        }

        public init(op: Op, path: String? = nil, value: Value? = nil) {
            self.op = op
            self.path = path
            self.value = value
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.op = try values.decode(Op.self, forKey: "op")
            self.path = try values.decodeIfPresent(String.self, forKey: "path")
            self.value = try values.decodeIfPresent(Value.self, forKey: "value")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(op, forKey: "op")
            try values.encodeIfPresent(path, forKey: "path")
            try values.encodeIfPresent(value, forKey: "value")
        }
    }

    public struct Group: Codable {
        public var value: String?
        public var display: String?

        public init(value: String? = nil, display: String? = nil) {
            self.value = value
            self.display = display
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.value = try values.decodeIfPresent(String.self, forKey: "value")
            self.display = try values.decodeIfPresent(String.self, forKey: "display")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(value, forKey: "value")
            try values.encodeIfPresent(display, forKey: "display")
        }
    }

    public init(schemas: [String], id: String, externalID: String? = nil, userName: String? = nil, displayName: String? = nil, name: Name, emails: [Email], isActive: Bool, meta: Meta, organizationID: Int? = nil, operations: [Operation]? = nil, groups: [Group]? = nil) {
        self.schemas = schemas
        self.id = id
        self.externalID = externalID
        self.userName = userName
        self.displayName = displayName
        self.name = name
        self.emails = emails
        self.isActive = isActive
        self.meta = meta
        self.organizationID = organizationID
        self.operations = operations
        self.groups = groups
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.id = try values.decode(String.self, forKey: "id")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "externalId")
        self.userName = try values.decodeIfPresent(String.self, forKey: "userName")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.name = try values.decode(Name.self, forKey: "name")
        self.emails = try values.decode([Email].self, forKey: "emails")
        self.isActive = try values.decode(Bool.self, forKey: "active")
        self.meta = try values.decode(Meta.self, forKey: "meta")
        self.organizationID = try values.decodeIfPresent(Int.self, forKey: "organization_id")
        self.operations = try values.decodeIfPresent([Operation].self, forKey: "operations")
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(externalID, forKey: "externalId")
        try values.encodeIfPresent(userName, forKey: "userName")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(name, forKey: "name")
        try values.encode(emails, forKey: "emails")
        try values.encode(isActive, forKey: "active")
        try values.encode(meta, forKey: "meta")
        try values.encodeIfPresent(organizationID, forKey: "organization_id")
        try values.encodeIfPresent(operations, forKey: "operations")
        try values.encodeIfPresent(groups, forKey: "groups")
    }
}

public struct ScimUserList: Codable {
    /// SCIM schema used.
    public var schemas: [String]
    public var totalResults: Int
    /// Example: 10
    public var itemsPerPage: Int
    public var startIndex: Int
    public var resources: [ScimUser]

    public init(schemas: [String], totalResults: Int, itemsPerPage: Int, startIndex: Int, resources: [ScimUser]) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.itemsPerPage = itemsPerPage
        self.startIndex = startIndex
        self.resources = resources
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.schemas = try values.decode([String].self, forKey: "schemas")
        self.totalResults = try values.decode(Int.self, forKey: "totalResults")
        self.itemsPerPage = try values.decode(Int.self, forKey: "itemsPerPage")
        self.startIndex = try values.decode(Int.self, forKey: "startIndex")
        self.resources = try values.decode([ScimUser].self, forKey: "Resources")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(schemas, forKey: "schemas")
        try values.encode(totalResults, forKey: "totalResults")
        try values.encode(itemsPerPage, forKey: "itemsPerPage")
        try values.encode(startIndex, forKey: "startIndex")
        try values.encode(resources, forKey: "Resources")
    }
}

public struct SearchResultTextMatch: Codable {
    public var objectURL: String?
    public var objectType: String?
    public var property: String?
    public var fragment: String?
    public var matches: [Match]?

    public struct Match: Codable {
        public var text: String?
        public var indices: [Int]?

        public init(text: String? = nil, indices: [Int]? = nil) {
            self.text = text
            self.indices = indices
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.text = try values.decodeIfPresent(String.self, forKey: "text")
            self.indices = try values.decodeIfPresent([Int].self, forKey: "indices")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(text, forKey: "text")
            try values.encodeIfPresent(indices, forKey: "indices")
        }
    }

    public init(objectURL: String? = nil, objectType: String? = nil, property: String? = nil, fragment: String? = nil, matches: [Match]? = nil) {
        self.objectURL = objectURL
        self.objectType = objectType
        self.property = property
        self.fragment = fragment
        self.matches = matches
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.objectURL = try values.decodeIfPresent(String.self, forKey: "object_url")
        self.objectType = try values.decodeIfPresent(String.self, forKey: "object_type")
        self.property = try values.decodeIfPresent(String.self, forKey: "property")
        self.fragment = try values.decodeIfPresent(String.self, forKey: "fragment")
        self.matches = try values.decodeIfPresent([Match].self, forKey: "matches")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(objectURL, forKey: "object_url")
        try values.encodeIfPresent(objectType, forKey: "object_type")
        try values.encodeIfPresent(property, forKey: "property")
        try values.encodeIfPresent(fragment, forKey: "fragment")
        try values.encodeIfPresent(matches, forKey: "matches")
    }
}

public struct CodeSearchResultItem: Codable {
    public var name: String
    public var path: String
    public var sha: String
    public var url: URL
    public var gitURL: URL
    public var htmlURL: URL
    /// Minimal Repository
    public var repository: MinimalRepository
    public var score: Double
    public var fileSize: Int?
    public var language: String?
    public var lastModifiedAt: Date?
    /// Example: ["73..77", "77..78"]
    public var lineNumbers: [String]?
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?

    public init(name: String, path: String, sha: String, url: URL, gitURL: URL, htmlURL: URL, repository: MinimalRepository, score: Double, fileSize: Int? = nil, language: String? = nil, lastModifiedAt: Date? = nil, lineNumbers: [String]? = nil, textMatches: [SearchResultTextMatch]? = nil) {
        self.name = name
        self.path = path
        self.sha = sha
        self.url = url
        self.gitURL = gitURL
        self.htmlURL = htmlURL
        self.repository = repository
        self.score = score
        self.fileSize = fileSize
        self.language = language
        self.lastModifiedAt = lastModifiedAt
        self.lineNumbers = lineNumbers
        self.textMatches = textMatches
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.path = try values.decode(String.self, forKey: "path")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.url = try values.decode(URL.self, forKey: "url")
        self.gitURL = try values.decode(URL.self, forKey: "git_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.score = try values.decode(Double.self, forKey: "score")
        self.fileSize = try values.decodeIfPresent(Int.self, forKey: "file_size")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.lastModifiedAt = try values.decodeIfPresent(Date.self, forKey: "last_modified_at")
        self.lineNumbers = try values.decodeIfPresent([String].self, forKey: "line_numbers")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(path, forKey: "path")
        try values.encode(sha, forKey: "sha")
        try values.encode(url, forKey: "url")
        try values.encode(gitURL, forKey: "git_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(repository, forKey: "repository")
        try values.encode(score, forKey: "score")
        try values.encodeIfPresent(fileSize, forKey: "file_size")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(lastModifiedAt, forKey: "last_modified_at")
        try values.encodeIfPresent(lineNumbers, forKey: "line_numbers")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
    }
}

public struct CommitSearchResultItem: Codable {
    public var url: URL
    public var sha: String
    public var htmlURL: URL
    public var commentsURL: URL
    public var commit: Commit
    /// Simple User
    public var author: SimpleUser?
    /// Git User
    ///
    /// Metaproperties for Git author/committer information.
    public var committer: GitUser?
    public var parents: [Parent]
    /// Minimal Repository
    public var repository: MinimalRepository
    public var score: Double
    public var nodeID: String
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?

    public struct Commit: Codable {
        public var author: Author
        /// Git User
        ///
        /// Metaproperties for Git author/committer information.
        public var committer: GitUser?
        public var commentCount: Int
        public var message: String
        public var tree: Tree
        public var url: URL
        public var verification: Verification?

        public struct Author: Codable {
            public var name: String
            public var email: String
            public var date: Date

            public init(name: String, email: String, date: Date) {
                self.name = name
                self.email = email
                self.date = date
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.name = try values.decode(String.self, forKey: "name")
                self.email = try values.decode(String.self, forKey: "email")
                self.date = try values.decode(Date.self, forKey: "date")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(name, forKey: "name")
                try values.encode(email, forKey: "email")
                try values.encode(date, forKey: "date")
            }
        }

        public struct Tree: Codable {
            public var sha: String
            public var url: URL

            public init(sha: String, url: URL) {
                self.sha = sha
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.sha = try values.decode(String.self, forKey: "sha")
                self.url = try values.decode(URL.self, forKey: "url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(sha, forKey: "sha")
                try values.encode(url, forKey: "url")
            }
        }

        public init(author: Author, committer: GitUser? = nil, commentCount: Int, message: String, tree: Tree, url: URL, verification: Verification? = nil) {
            self.author = author
            self.committer = committer
            self.commentCount = commentCount
            self.message = message
            self.tree = tree
            self.url = url
            self.verification = verification
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.author = try values.decode(Author.self, forKey: "author")
            self.committer = try values.decodeIfPresent(GitUser.self, forKey: "committer")
            self.commentCount = try values.decode(Int.self, forKey: "comment_count")
            self.message = try values.decode(String.self, forKey: "message")
            self.tree = try values.decode(Tree.self, forKey: "tree")
            self.url = try values.decode(URL.self, forKey: "url")
            self.verification = try values.decodeIfPresent(Verification.self, forKey: "verification")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(author, forKey: "author")
            try values.encodeIfPresent(committer, forKey: "committer")
            try values.encode(commentCount, forKey: "comment_count")
            try values.encode(message, forKey: "message")
            try values.encode(tree, forKey: "tree")
            try values.encode(url, forKey: "url")
            try values.encodeIfPresent(verification, forKey: "verification")
        }
    }

    public struct Parent: Codable {
        public var url: String?
        public var htmlURL: String?
        public var sha: String?

        public init(url: String? = nil, htmlURL: String? = nil, sha: String? = nil) {
            self.url = url
            self.htmlURL = htmlURL
            self.sha = sha
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
            self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(sha, forKey: "sha")
        }
    }

    public init(url: URL, sha: String, htmlURL: URL, commentsURL: URL, commit: Commit, author: SimpleUser? = nil, committer: GitUser? = nil, parents: [Parent], repository: MinimalRepository, score: Double, nodeID: String, textMatches: [SearchResultTextMatch]? = nil) {
        self.url = url
        self.sha = sha
        self.htmlURL = htmlURL
        self.commentsURL = commentsURL
        self.commit = commit
        self.author = author
        self.committer = committer
        self.parents = parents
        self.repository = repository
        self.score = score
        self.nodeID = nodeID
        self.textMatches = textMatches
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.commit = try values.decode(Commit.self, forKey: "commit")
        self.author = try values.decodeIfPresent(SimpleUser.self, forKey: "author")
        self.committer = try values.decodeIfPresent(GitUser.self, forKey: "committer")
        self.parents = try values.decode([Parent].self, forKey: "parents")
        self.repository = try values.decode(MinimalRepository.self, forKey: "repository")
        self.score = try values.decode(Double.self, forKey: "score")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(sha, forKey: "sha")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(commit, forKey: "commit")
        try values.encodeIfPresent(author, forKey: "author")
        try values.encodeIfPresent(committer, forKey: "committer")
        try values.encode(parents, forKey: "parents")
        try values.encode(repository, forKey: "repository")
        try values.encode(score, forKey: "score")
        try values.encode(nodeID, forKey: "node_id")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
    }
}

public struct IssueSearchResultItem: Codable {
    public var url: URL
    public var repositoryURL: URL
    public var labelsURL: String
    public var commentsURL: URL
    public var eventsURL: URL
    public var htmlURL: URL
    public var id: Int
    public var nodeID: String
    public var number: Int
    public var title: String
    public var isLocked: Bool
    public var activeLockReason: String?
    public var assignees: [SimpleUser]?
    /// Simple User
    public var user: SimpleUser?
    public var labels: [Label]
    public var state: String
    /// Simple User
    public var assignee: SimpleUser?
    /// A collection of related issues and pull requests.
    public var milestone: Milestone?
    public var comments: Int
    public var createdAt: Date
    public var updatedAt: Date
    public var closedAt: Date?
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?
    public var pullRequest: PullRequest?
    public var body: String?
    public var score: Double
    /// Author_association
    ///
    /// How the author is associated with the repository.
    ///
    /// Example: "OWNER"
    public var authorAssociation: AuthorAssociation
    public var isDraft: Bool?
    /// A git repository
    public var repository: Repository?
    public var bodyHTML: String?
    public var bodyText: String?
    public var timelineURL: URL?
    /// GitHub app
    ///
    /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
    public var performedViaGithubApp: Integration?
    /// Reaction Rollup
    public var reactions: ReactionRollup?

    public struct Label: Codable {
        public var id: Int?
        public var nodeID: String?
        public var url: String?
        public var name: String?
        public var color: String?
        public var isDefault: Bool?
        public var description: String?

        public init(id: Int? = nil, nodeID: String? = nil, url: String? = nil, name: String? = nil, color: String? = nil, isDefault: Bool? = nil, description: String? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.url = url
            self.name = name
            self.color = color
            self.isDefault = isDefault
            self.description = description
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.color = try values.decodeIfPresent(String.self, forKey: "color")
            self.isDefault = try values.decodeIfPresent(Bool.self, forKey: "default")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(color, forKey: "color")
            try values.encodeIfPresent(isDefault, forKey: "default")
            try values.encodeIfPresent(description, forKey: "description")
        }
    }

    public struct PullRequest: Codable {
        public var mergedAt: Date?
        public var diffURL: URL?
        public var htmlURL: URL?
        public var patchURL: URL?
        public var url: URL?

        public init(mergedAt: Date? = nil, diffURL: URL? = nil, htmlURL: URL? = nil, patchURL: URL? = nil, url: URL? = nil) {
            self.mergedAt = mergedAt
            self.diffURL = diffURL
            self.htmlURL = htmlURL
            self.patchURL = patchURL
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.mergedAt = try values.decodeIfPresent(Date.self, forKey: "merged_at")
            self.diffURL = try values.decodeIfPresent(URL.self, forKey: "diff_url")
            self.htmlURL = try values.decodeIfPresent(URL.self, forKey: "html_url")
            self.patchURL = try values.decodeIfPresent(URL.self, forKey: "patch_url")
            self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(mergedAt, forKey: "merged_at")
            try values.encodeIfPresent(diffURL, forKey: "diff_url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
            try values.encodeIfPresent(patchURL, forKey: "patch_url")
            try values.encodeIfPresent(url, forKey: "url")
        }
    }

    public init(url: URL, repositoryURL: URL, labelsURL: String, commentsURL: URL, eventsURL: URL, htmlURL: URL, id: Int, nodeID: String, number: Int, title: String, isLocked: Bool, activeLockReason: String? = nil, assignees: [SimpleUser]? = nil, user: SimpleUser? = nil, labels: [Label], state: String, assignee: SimpleUser? = nil, milestone: Milestone? = nil, comments: Int, createdAt: Date, updatedAt: Date, closedAt: Date? = nil, textMatches: [SearchResultTextMatch]? = nil, pullRequest: PullRequest? = nil, body: String? = nil, score: Double, authorAssociation: AuthorAssociation, isDraft: Bool? = nil, repository: Repository? = nil, bodyHTML: String? = nil, bodyText: String? = nil, timelineURL: URL? = nil, performedViaGithubApp: Integration? = nil, reactions: ReactionRollup? = nil) {
        self.url = url
        self.repositoryURL = repositoryURL
        self.labelsURL = labelsURL
        self.commentsURL = commentsURL
        self.eventsURL = eventsURL
        self.htmlURL = htmlURL
        self.id = id
        self.nodeID = nodeID
        self.number = number
        self.title = title
        self.isLocked = isLocked
        self.activeLockReason = activeLockReason
        self.assignees = assignees
        self.user = user
        self.labels = labels
        self.state = state
        self.assignee = assignee
        self.milestone = milestone
        self.comments = comments
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.closedAt = closedAt
        self.textMatches = textMatches
        self.pullRequest = pullRequest
        self.body = body
        self.score = score
        self.authorAssociation = authorAssociation
        self.isDraft = isDraft
        self.repository = repository
        self.bodyHTML = bodyHTML
        self.bodyText = bodyText
        self.timelineURL = timelineURL
        self.performedViaGithubApp = performedViaGithubApp
        self.reactions = reactions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.repositoryURL = try values.decode(URL.self, forKey: "repository_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.commentsURL = try values.decode(URL.self, forKey: "comments_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.number = try values.decode(Int.self, forKey: "number")
        self.title = try values.decode(String.self, forKey: "title")
        self.isLocked = try values.decode(Bool.self, forKey: "locked")
        self.activeLockReason = try values.decodeIfPresent(String.self, forKey: "active_lock_reason")
        self.assignees = try values.decodeIfPresent([SimpleUser].self, forKey: "assignees")
        self.user = try values.decodeIfPresent(SimpleUser.self, forKey: "user")
        self.labels = try values.decode([Label].self, forKey: "labels")
        self.state = try values.decode(String.self, forKey: "state")
        self.assignee = try values.decodeIfPresent(SimpleUser.self, forKey: "assignee")
        self.milestone = try values.decodeIfPresent(Milestone.self, forKey: "milestone")
        self.comments = try values.decode(Int.self, forKey: "comments")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.closedAt = try values.decodeIfPresent(Date.self, forKey: "closed_at")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
        self.pullRequest = try values.decodeIfPresent(PullRequest.self, forKey: "pull_request")
        self.body = try values.decodeIfPresent(String.self, forKey: "body")
        self.score = try values.decode(Double.self, forKey: "score")
        self.authorAssociation = try values.decode(AuthorAssociation.self, forKey: "author_association")
        self.isDraft = try values.decodeIfPresent(Bool.self, forKey: "draft")
        self.repository = try values.decodeIfPresent(Repository.self, forKey: "repository")
        self.bodyHTML = try values.decodeIfPresent(String.self, forKey: "body_html")
        self.bodyText = try values.decodeIfPresent(String.self, forKey: "body_text")
        self.timelineURL = try values.decodeIfPresent(URL.self, forKey: "timeline_url")
        self.performedViaGithubApp = try values.decodeIfPresent(Integration.self, forKey: "performed_via_github_app")
        self.reactions = try values.decodeIfPresent(ReactionRollup.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(repositoryURL, forKey: "repository_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(number, forKey: "number")
        try values.encode(title, forKey: "title")
        try values.encode(isLocked, forKey: "locked")
        try values.encodeIfPresent(activeLockReason, forKey: "active_lock_reason")
        try values.encodeIfPresent(assignees, forKey: "assignees")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encode(labels, forKey: "labels")
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encode(comments, forKey: "comments")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(closedAt, forKey: "closed_at")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
        try values.encodeIfPresent(pullRequest, forKey: "pull_request")
        try values.encodeIfPresent(body, forKey: "body")
        try values.encode(score, forKey: "score")
        try values.encode(authorAssociation, forKey: "author_association")
        try values.encodeIfPresent(isDraft, forKey: "draft")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encodeIfPresent(bodyHTML, forKey: "body_html")
        try values.encodeIfPresent(bodyText, forKey: "body_text")
        try values.encodeIfPresent(timelineURL, forKey: "timeline_url")
        try values.encodeIfPresent(performedViaGithubApp, forKey: "performed_via_github_app")
        try values.encodeIfPresent(reactions, forKey: "reactions")
    }
}

public struct LabelSearchResultItem: Codable {
    public var id: Int
    public var nodeID: String
    public var url: URL
    public var name: String
    public var color: String
    public var isDefault: Bool
    public var description: String?
    public var score: Double
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?

    public init(id: Int, nodeID: String, url: URL, name: String, color: String, isDefault: Bool, description: String? = nil, score: Double, textMatches: [SearchResultTextMatch]? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.url = url
        self.name = name
        self.color = color
        self.isDefault = isDefault
        self.description = description
        self.score = score
        self.textMatches = textMatches
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.name = try values.decode(String.self, forKey: "name")
        self.color = try values.decode(String.self, forKey: "color")
        self.isDefault = try values.decode(Bool.self, forKey: "default")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.score = try values.decode(Double.self, forKey: "score")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(url, forKey: "url")
        try values.encode(name, forKey: "name")
        try values.encode(color, forKey: "color")
        try values.encode(isDefault, forKey: "default")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(score, forKey: "score")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
    }
}

public struct RepoSearchResultItem: Codable {
    public var id: Int
    public var nodeID: String
    public var name: String
    public var fullName: String
    /// Simple User
    public var owner: SimpleUser?
    public var isPrivate: Bool
    public var htmlURL: URL
    public var description: String?
    public var isFork: Bool
    public var url: URL
    public var createdAt: Date
    public var updatedAt: Date
    public var pushedAt: Date
    public var homepage: URL?
    public var size: Int
    public var stargazersCount: Int
    public var watchersCount: Int
    public var language: String?
    public var forksCount: Int
    public var openIssuesCount: Int
    public var masterBranch: String?
    public var defaultBranch: String
    public var score: Double
    public var forksURL: URL
    public var keysURL: String
    public var collaboratorsURL: String
    public var teamsURL: URL
    public var hooksURL: URL
    public var issueEventsURL: String
    public var eventsURL: URL
    public var assigneesURL: String
    public var branchesURL: String
    public var tagsURL: URL
    public var blobsURL: String
    public var gitTagsURL: String
    public var gitRefsURL: String
    public var treesURL: String
    public var statusesURL: String
    public var languagesURL: URL
    public var stargazersURL: URL
    public var contributorsURL: URL
    public var subscribersURL: URL
    public var subscriptionURL: URL
    public var commitsURL: String
    public var gitCommitsURL: String
    public var commentsURL: String
    public var issueCommentURL: String
    public var contentsURL: String
    public var compareURL: String
    public var mergesURL: URL
    public var archiveURL: String
    public var downloadsURL: URL
    public var issuesURL: String
    public var pullsURL: String
    public var milestonesURL: String
    public var notificationsURL: String
    public var labelsURL: String
    public var releasesURL: String
    public var deploymentsURL: URL
    public var gitURL: String
    public var sshURL: String
    public var cloneURL: String
    public var svnURL: URL
    public var forks: Int
    public var openIssues: Int
    public var watchers: Int
    public var topics: [String]?
    public var mirrorURL: URL?
    public var hasIssues: Bool
    public var hasProjects: Bool
    public var hasPages: Bool
    public var hasWiki: Bool
    public var hasDownloads: Bool
    public var isArchived: Bool
    /// Returns whether or not this repository disabled.
    public var isDisabled: Bool
    /// The repository visibility: public, private, or internal.
    public var visibility: String?
    /// License Simple
    public var license: LicenseSimple?
    public var permissions: Permissions?
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?
    public var tempCloneToken: String?
    public var allowMergeCommit: Bool?
    public var allowSquashMerge: Bool?
    public var allowRebaseMerge: Bool?
    public var allowAutoMerge: Bool?
    public var deleteBranchOnMerge: Bool?
    public var allowForking: Bool?
    public var isTemplate: Bool?

    public struct Permissions: Codable {
        public var isAdmin: Bool
        public var isMaintain: Bool?
        public var isPush: Bool
        public var isTriage: Bool?
        public var isPull: Bool

        public init(isAdmin: Bool, isMaintain: Bool? = nil, isPush: Bool, isTriage: Bool? = nil, isPull: Bool) {
            self.isAdmin = isAdmin
            self.isMaintain = isMaintain
            self.isPush = isPush
            self.isTriage = isTriage
            self.isPull = isPull
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isAdmin = try values.decode(Bool.self, forKey: "admin")
            self.isMaintain = try values.decodeIfPresent(Bool.self, forKey: "maintain")
            self.isPush = try values.decode(Bool.self, forKey: "push")
            self.isTriage = try values.decodeIfPresent(Bool.self, forKey: "triage")
            self.isPull = try values.decode(Bool.self, forKey: "pull")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isAdmin, forKey: "admin")
            try values.encodeIfPresent(isMaintain, forKey: "maintain")
            try values.encode(isPush, forKey: "push")
            try values.encodeIfPresent(isTriage, forKey: "triage")
            try values.encode(isPull, forKey: "pull")
        }
    }

    public init(id: Int, nodeID: String, name: String, fullName: String, owner: SimpleUser? = nil, isPrivate: Bool, htmlURL: URL, description: String? = nil, isFork: Bool, url: URL, createdAt: Date, updatedAt: Date, pushedAt: Date, homepage: URL? = nil, size: Int, stargazersCount: Int, watchersCount: Int, language: String? = nil, forksCount: Int, openIssuesCount: Int, masterBranch: String? = nil, defaultBranch: String, score: Double, forksURL: URL, keysURL: String, collaboratorsURL: String, teamsURL: URL, hooksURL: URL, issueEventsURL: String, eventsURL: URL, assigneesURL: String, branchesURL: String, tagsURL: URL, blobsURL: String, gitTagsURL: String, gitRefsURL: String, treesURL: String, statusesURL: String, languagesURL: URL, stargazersURL: URL, contributorsURL: URL, subscribersURL: URL, subscriptionURL: URL, commitsURL: String, gitCommitsURL: String, commentsURL: String, issueCommentURL: String, contentsURL: String, compareURL: String, mergesURL: URL, archiveURL: String, downloadsURL: URL, issuesURL: String, pullsURL: String, milestonesURL: String, notificationsURL: String, labelsURL: String, releasesURL: String, deploymentsURL: URL, gitURL: String, sshURL: String, cloneURL: String, svnURL: URL, forks: Int, openIssues: Int, watchers: Int, topics: [String]? = nil, mirrorURL: URL? = nil, hasIssues: Bool, hasProjects: Bool, hasPages: Bool, hasWiki: Bool, hasDownloads: Bool, isArchived: Bool, isDisabled: Bool, visibility: String? = nil, license: LicenseSimple? = nil, permissions: Permissions? = nil, textMatches: [SearchResultTextMatch]? = nil, tempCloneToken: String? = nil, allowMergeCommit: Bool? = nil, allowSquashMerge: Bool? = nil, allowRebaseMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, allowForking: Bool? = nil, isTemplate: Bool? = nil) {
        self.id = id
        self.nodeID = nodeID
        self.name = name
        self.fullName = fullName
        self.owner = owner
        self.isPrivate = isPrivate
        self.htmlURL = htmlURL
        self.description = description
        self.isFork = isFork
        self.url = url
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.pushedAt = pushedAt
        self.homepage = homepage
        self.size = size
        self.stargazersCount = stargazersCount
        self.watchersCount = watchersCount
        self.language = language
        self.forksCount = forksCount
        self.openIssuesCount = openIssuesCount
        self.masterBranch = masterBranch
        self.defaultBranch = defaultBranch
        self.score = score
        self.forksURL = forksURL
        self.keysURL = keysURL
        self.collaboratorsURL = collaboratorsURL
        self.teamsURL = teamsURL
        self.hooksURL = hooksURL
        self.issueEventsURL = issueEventsURL
        self.eventsURL = eventsURL
        self.assigneesURL = assigneesURL
        self.branchesURL = branchesURL
        self.tagsURL = tagsURL
        self.blobsURL = blobsURL
        self.gitTagsURL = gitTagsURL
        self.gitRefsURL = gitRefsURL
        self.treesURL = treesURL
        self.statusesURL = statusesURL
        self.languagesURL = languagesURL
        self.stargazersURL = stargazersURL
        self.contributorsURL = contributorsURL
        self.subscribersURL = subscribersURL
        self.subscriptionURL = subscriptionURL
        self.commitsURL = commitsURL
        self.gitCommitsURL = gitCommitsURL
        self.commentsURL = commentsURL
        self.issueCommentURL = issueCommentURL
        self.contentsURL = contentsURL
        self.compareURL = compareURL
        self.mergesURL = mergesURL
        self.archiveURL = archiveURL
        self.downloadsURL = downloadsURL
        self.issuesURL = issuesURL
        self.pullsURL = pullsURL
        self.milestonesURL = milestonesURL
        self.notificationsURL = notificationsURL
        self.labelsURL = labelsURL
        self.releasesURL = releasesURL
        self.deploymentsURL = deploymentsURL
        self.gitURL = gitURL
        self.sshURL = sshURL
        self.cloneURL = cloneURL
        self.svnURL = svnURL
        self.forks = forks
        self.openIssues = openIssues
        self.watchers = watchers
        self.topics = topics
        self.mirrorURL = mirrorURL
        self.hasIssues = hasIssues
        self.hasProjects = hasProjects
        self.hasPages = hasPages
        self.hasWiki = hasWiki
        self.hasDownloads = hasDownloads
        self.isArchived = isArchived
        self.isDisabled = isDisabled
        self.visibility = visibility
        self.license = license
        self.permissions = permissions
        self.textMatches = textMatches
        self.tempCloneToken = tempCloneToken
        self.allowMergeCommit = allowMergeCommit
        self.allowSquashMerge = allowSquashMerge
        self.allowRebaseMerge = allowRebaseMerge
        self.allowAutoMerge = allowAutoMerge
        self.deleteBranchOnMerge = deleteBranchOnMerge
        self.allowForking = allowForking
        self.isTemplate = isTemplate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.name = try values.decode(String.self, forKey: "name")
        self.fullName = try values.decode(String.self, forKey: "full_name")
        self.owner = try values.decodeIfPresent(SimpleUser.self, forKey: "owner")
        self.isPrivate = try values.decode(Bool.self, forKey: "private")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isFork = try values.decode(Bool.self, forKey: "fork")
        self.url = try values.decode(URL.self, forKey: "url")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.pushedAt = try values.decode(Date.self, forKey: "pushed_at")
        self.homepage = try values.decodeIfPresent(URL.self, forKey: "homepage")
        self.size = try values.decode(Int.self, forKey: "size")
        self.stargazersCount = try values.decode(Int.self, forKey: "stargazers_count")
        self.watchersCount = try values.decode(Int.self, forKey: "watchers_count")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.forksCount = try values.decode(Int.self, forKey: "forks_count")
        self.openIssuesCount = try values.decode(Int.self, forKey: "open_issues_count")
        self.masterBranch = try values.decodeIfPresent(String.self, forKey: "master_branch")
        self.defaultBranch = try values.decode(String.self, forKey: "default_branch")
        self.score = try values.decode(Double.self, forKey: "score")
        self.forksURL = try values.decode(URL.self, forKey: "forks_url")
        self.keysURL = try values.decode(String.self, forKey: "keys_url")
        self.collaboratorsURL = try values.decode(String.self, forKey: "collaborators_url")
        self.teamsURL = try values.decode(URL.self, forKey: "teams_url")
        self.hooksURL = try values.decode(URL.self, forKey: "hooks_url")
        self.issueEventsURL = try values.decode(String.self, forKey: "issue_events_url")
        self.eventsURL = try values.decode(URL.self, forKey: "events_url")
        self.assigneesURL = try values.decode(String.self, forKey: "assignees_url")
        self.branchesURL = try values.decode(String.self, forKey: "branches_url")
        self.tagsURL = try values.decode(URL.self, forKey: "tags_url")
        self.blobsURL = try values.decode(String.self, forKey: "blobs_url")
        self.gitTagsURL = try values.decode(String.self, forKey: "git_tags_url")
        self.gitRefsURL = try values.decode(String.self, forKey: "git_refs_url")
        self.treesURL = try values.decode(String.self, forKey: "trees_url")
        self.statusesURL = try values.decode(String.self, forKey: "statuses_url")
        self.languagesURL = try values.decode(URL.self, forKey: "languages_url")
        self.stargazersURL = try values.decode(URL.self, forKey: "stargazers_url")
        self.contributorsURL = try values.decode(URL.self, forKey: "contributors_url")
        self.subscribersURL = try values.decode(URL.self, forKey: "subscribers_url")
        self.subscriptionURL = try values.decode(URL.self, forKey: "subscription_url")
        self.commitsURL = try values.decode(String.self, forKey: "commits_url")
        self.gitCommitsURL = try values.decode(String.self, forKey: "git_commits_url")
        self.commentsURL = try values.decode(String.self, forKey: "comments_url")
        self.issueCommentURL = try values.decode(String.self, forKey: "issue_comment_url")
        self.contentsURL = try values.decode(String.self, forKey: "contents_url")
        self.compareURL = try values.decode(String.self, forKey: "compare_url")
        self.mergesURL = try values.decode(URL.self, forKey: "merges_url")
        self.archiveURL = try values.decode(String.self, forKey: "archive_url")
        self.downloadsURL = try values.decode(URL.self, forKey: "downloads_url")
        self.issuesURL = try values.decode(String.self, forKey: "issues_url")
        self.pullsURL = try values.decode(String.self, forKey: "pulls_url")
        self.milestonesURL = try values.decode(String.self, forKey: "milestones_url")
        self.notificationsURL = try values.decode(String.self, forKey: "notifications_url")
        self.labelsURL = try values.decode(String.self, forKey: "labels_url")
        self.releasesURL = try values.decode(String.self, forKey: "releases_url")
        self.deploymentsURL = try values.decode(URL.self, forKey: "deployments_url")
        self.gitURL = try values.decode(String.self, forKey: "git_url")
        self.sshURL = try values.decode(String.self, forKey: "ssh_url")
        self.cloneURL = try values.decode(String.self, forKey: "clone_url")
        self.svnURL = try values.decode(URL.self, forKey: "svn_url")
        self.forks = try values.decode(Int.self, forKey: "forks")
        self.openIssues = try values.decode(Int.self, forKey: "open_issues")
        self.watchers = try values.decode(Int.self, forKey: "watchers")
        self.topics = try values.decodeIfPresent([String].self, forKey: "topics")
        self.mirrorURL = try values.decodeIfPresent(URL.self, forKey: "mirror_url")
        self.hasIssues = try values.decode(Bool.self, forKey: "has_issues")
        self.hasProjects = try values.decode(Bool.self, forKey: "has_projects")
        self.hasPages = try values.decode(Bool.self, forKey: "has_pages")
        self.hasWiki = try values.decode(Bool.self, forKey: "has_wiki")
        self.hasDownloads = try values.decode(Bool.self, forKey: "has_downloads")
        self.isArchived = try values.decode(Bool.self, forKey: "archived")
        self.isDisabled = try values.decode(Bool.self, forKey: "disabled")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
        self.license = try values.decodeIfPresent(LicenseSimple.self, forKey: "license")
        self.permissions = try values.decodeIfPresent(Permissions.self, forKey: "permissions")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
        self.tempCloneToken = try values.decodeIfPresent(String.self, forKey: "temp_clone_token")
        self.allowMergeCommit = try values.decodeIfPresent(Bool.self, forKey: "allow_merge_commit")
        self.allowSquashMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_squash_merge")
        self.allowRebaseMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_rebase_merge")
        self.allowAutoMerge = try values.decodeIfPresent(Bool.self, forKey: "allow_auto_merge")
        self.deleteBranchOnMerge = try values.decodeIfPresent(Bool.self, forKey: "delete_branch_on_merge")
        self.allowForking = try values.decodeIfPresent(Bool.self, forKey: "allow_forking")
        self.isTemplate = try values.decodeIfPresent(Bool.self, forKey: "is_template")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(name, forKey: "name")
        try values.encode(fullName, forKey: "full_name")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encode(isPrivate, forKey: "private")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(isFork, forKey: "fork")
        try values.encode(url, forKey: "url")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(pushedAt, forKey: "pushed_at")
        try values.encodeIfPresent(homepage, forKey: "homepage")
        try values.encode(size, forKey: "size")
        try values.encode(stargazersCount, forKey: "stargazers_count")
        try values.encode(watchersCount, forKey: "watchers_count")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encode(forksCount, forKey: "forks_count")
        try values.encode(openIssuesCount, forKey: "open_issues_count")
        try values.encodeIfPresent(masterBranch, forKey: "master_branch")
        try values.encode(defaultBranch, forKey: "default_branch")
        try values.encode(score, forKey: "score")
        try values.encode(forksURL, forKey: "forks_url")
        try values.encode(keysURL, forKey: "keys_url")
        try values.encode(collaboratorsURL, forKey: "collaborators_url")
        try values.encode(teamsURL, forKey: "teams_url")
        try values.encode(hooksURL, forKey: "hooks_url")
        try values.encode(issueEventsURL, forKey: "issue_events_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(assigneesURL, forKey: "assignees_url")
        try values.encode(branchesURL, forKey: "branches_url")
        try values.encode(tagsURL, forKey: "tags_url")
        try values.encode(blobsURL, forKey: "blobs_url")
        try values.encode(gitTagsURL, forKey: "git_tags_url")
        try values.encode(gitRefsURL, forKey: "git_refs_url")
        try values.encode(treesURL, forKey: "trees_url")
        try values.encode(statusesURL, forKey: "statuses_url")
        try values.encode(languagesURL, forKey: "languages_url")
        try values.encode(stargazersURL, forKey: "stargazers_url")
        try values.encode(contributorsURL, forKey: "contributors_url")
        try values.encode(subscribersURL, forKey: "subscribers_url")
        try values.encode(subscriptionURL, forKey: "subscription_url")
        try values.encode(commitsURL, forKey: "commits_url")
        try values.encode(gitCommitsURL, forKey: "git_commits_url")
        try values.encode(commentsURL, forKey: "comments_url")
        try values.encode(issueCommentURL, forKey: "issue_comment_url")
        try values.encode(contentsURL, forKey: "contents_url")
        try values.encode(compareURL, forKey: "compare_url")
        try values.encode(mergesURL, forKey: "merges_url")
        try values.encode(archiveURL, forKey: "archive_url")
        try values.encode(downloadsURL, forKey: "downloads_url")
        try values.encode(issuesURL, forKey: "issues_url")
        try values.encode(pullsURL, forKey: "pulls_url")
        try values.encode(milestonesURL, forKey: "milestones_url")
        try values.encode(notificationsURL, forKey: "notifications_url")
        try values.encode(labelsURL, forKey: "labels_url")
        try values.encode(releasesURL, forKey: "releases_url")
        try values.encode(deploymentsURL, forKey: "deployments_url")
        try values.encode(gitURL, forKey: "git_url")
        try values.encode(sshURL, forKey: "ssh_url")
        try values.encode(cloneURL, forKey: "clone_url")
        try values.encode(svnURL, forKey: "svn_url")
        try values.encode(forks, forKey: "forks")
        try values.encode(openIssues, forKey: "open_issues")
        try values.encode(watchers, forKey: "watchers")
        try values.encodeIfPresent(topics, forKey: "topics")
        try values.encodeIfPresent(mirrorURL, forKey: "mirror_url")
        try values.encode(hasIssues, forKey: "has_issues")
        try values.encode(hasProjects, forKey: "has_projects")
        try values.encode(hasPages, forKey: "has_pages")
        try values.encode(hasWiki, forKey: "has_wiki")
        try values.encode(hasDownloads, forKey: "has_downloads")
        try values.encode(isArchived, forKey: "archived")
        try values.encode(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(visibility, forKey: "visibility")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
        try values.encodeIfPresent(tempCloneToken, forKey: "temp_clone_token")
        try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
        try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
        try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
        try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
        try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
        try values.encodeIfPresent(allowForking, forKey: "allow_forking")
        try values.encodeIfPresent(isTemplate, forKey: "is_template")
    }
}

public struct TopicSearchResultItem: Codable {
    public var name: String
    public var displayName: String?
    public var shortDescription: String?
    public var description: String?
    public var createdBy: String?
    public var released: String?
    public var createdAt: Date
    public var updatedAt: Date
    public var isFeatured: Bool
    public var isCurated: Bool
    public var score: Double
    public var repositoryCount: Int?
    public var logoURL: URL?
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?
    public var related: [RelatedItem]?
    public var aliases: [Alias]?

    public struct RelatedItem: Codable {
        public var topicRelation: TopicRelation?

        public struct TopicRelation: Codable {
            public var id: Int?
            public var name: String?
            public var topicID: Int?
            public var relationType: String?

            public init(id: Int? = nil, name: String? = nil, topicID: Int? = nil, relationType: String? = nil) {
                self.id = id
                self.name = name
                self.topicID = topicID
                self.relationType = relationType
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decodeIfPresent(Int.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.topicID = try values.decodeIfPresent(Int.self, forKey: "topic_id")
                self.relationType = try values.decodeIfPresent(String.self, forKey: "relation_type")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(topicID, forKey: "topic_id")
                try values.encodeIfPresent(relationType, forKey: "relation_type")
            }
        }

        public init(topicRelation: TopicRelation? = nil) {
            self.topicRelation = topicRelation
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.topicRelation = try values.decodeIfPresent(TopicRelation.self, forKey: "topic_relation")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(topicRelation, forKey: "topic_relation")
        }
    }

    public struct Alias: Codable {
        public var topicRelation: TopicRelation?

        public struct TopicRelation: Codable {
            public var id: Int?
            public var name: String?
            public var topicID: Int?
            public var relationType: String?

            public init(id: Int? = nil, name: String? = nil, topicID: Int? = nil, relationType: String? = nil) {
                self.id = id
                self.name = name
                self.topicID = topicID
                self.relationType = relationType
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decodeIfPresent(Int.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.topicID = try values.decodeIfPresent(Int.self, forKey: "topic_id")
                self.relationType = try values.decodeIfPresent(String.self, forKey: "relation_type")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(topicID, forKey: "topic_id")
                try values.encodeIfPresent(relationType, forKey: "relation_type")
            }
        }

        public init(topicRelation: TopicRelation? = nil) {
            self.topicRelation = topicRelation
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.topicRelation = try values.decodeIfPresent(TopicRelation.self, forKey: "topic_relation")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(topicRelation, forKey: "topic_relation")
        }
    }

    public init(name: String, displayName: String? = nil, shortDescription: String? = nil, description: String? = nil, createdBy: String? = nil, released: String? = nil, createdAt: Date, updatedAt: Date, isFeatured: Bool, isCurated: Bool, score: Double, repositoryCount: Int? = nil, logoURL: URL? = nil, textMatches: [SearchResultTextMatch]? = nil, related: [RelatedItem]? = nil, aliases: [Alias]? = nil) {
        self.name = name
        self.displayName = displayName
        self.shortDescription = shortDescription
        self.description = description
        self.createdBy = createdBy
        self.released = released
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.isFeatured = isFeatured
        self.isCurated = isCurated
        self.score = score
        self.repositoryCount = repositoryCount
        self.logoURL = logoURL
        self.textMatches = textMatches
        self.related = related
        self.aliases = aliases
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.shortDescription = try values.decodeIfPresent(String.self, forKey: "short_description")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.createdBy = try values.decodeIfPresent(String.self, forKey: "created_by")
        self.released = try values.decodeIfPresent(String.self, forKey: "released")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.isFeatured = try values.decode(Bool.self, forKey: "featured")
        self.isCurated = try values.decode(Bool.self, forKey: "curated")
        self.score = try values.decode(Double.self, forKey: "score")
        self.repositoryCount = try values.decodeIfPresent(Int.self, forKey: "repository_count")
        self.logoURL = try values.decodeIfPresent(URL.self, forKey: "logo_url")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
        self.related = try values.decodeIfPresent([RelatedItem].self, forKey: "related")
        self.aliases = try values.decodeIfPresent([Alias].self, forKey: "aliases")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encodeIfPresent(shortDescription, forKey: "short_description")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(released, forKey: "released")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(isFeatured, forKey: "featured")
        try values.encode(isCurated, forKey: "curated")
        try values.encode(score, forKey: "score")
        try values.encodeIfPresent(repositoryCount, forKey: "repository_count")
        try values.encodeIfPresent(logoURL, forKey: "logo_url")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
        try values.encodeIfPresent(related, forKey: "related")
        try values.encodeIfPresent(aliases, forKey: "aliases")
    }
}

public struct UserSearchResultItem: Codable {
    public var login: String
    public var id: Int
    public var nodeID: String
    public var avatarURL: URL
    public var gravatarID: String?
    public var url: URL
    public var htmlURL: URL
    public var followersURL: URL
    public var subscriptionsURL: URL
    public var organizationsURL: URL
    public var reposURL: URL
    public var receivedEventsURL: URL
    public var type: String
    public var score: Double
    public var followingURL: String
    public var gistsURL: String
    public var starredURL: String
    public var eventsURL: String
    public var publicRepos: Int?
    public var publicGists: Int?
    public var followers: Int?
    public var following: Int?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var name: String?
    public var bio: String?
    public var email: String?
    public var location: String?
    public var isSiteAdmin: Bool
    public var isHireable: Bool?
    /// Search Result Text Matches
    public var textMatches: [SearchResultTextMatch]?
    public var blog: String?
    public var company: String?
    public var suspendedAt: Date?

    public init(login: String, id: Int, nodeID: String, avatarURL: URL, gravatarID: String? = nil, url: URL, htmlURL: URL, followersURL: URL, subscriptionsURL: URL, organizationsURL: URL, reposURL: URL, receivedEventsURL: URL, type: String, score: Double, followingURL: String, gistsURL: String, starredURL: String, eventsURL: String, publicRepos: Int? = nil, publicGists: Int? = nil, followers: Int? = nil, following: Int? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, name: String? = nil, bio: String? = nil, email: String? = nil, location: String? = nil, isSiteAdmin: Bool, isHireable: Bool? = nil, textMatches: [SearchResultTextMatch]? = nil, blog: String? = nil, company: String? = nil, suspendedAt: Date? = nil) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.score = score
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.eventsURL = eventsURL
        self.publicRepos = publicRepos
        self.publicGists = publicGists
        self.followers = followers
        self.following = following
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.name = name
        self.bio = bio
        self.email = email
        self.location = location
        self.isSiteAdmin = isSiteAdmin
        self.isHireable = isHireable
        self.textMatches = textMatches
        self.blog = blog
        self.company = company
        self.suspendedAt = suspendedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.followersURL = try values.decode(URL.self, forKey: "followers_url")
        self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.score = try values.decode(Double.self, forKey: "score")
        self.followingURL = try values.decode(String.self, forKey: "following_url")
        self.gistsURL = try values.decode(String.self, forKey: "gists_url")
        self.starredURL = try values.decode(String.self, forKey: "starred_url")
        self.eventsURL = try values.decode(String.self, forKey: "events_url")
        self.publicRepos = try values.decodeIfPresent(Int.self, forKey: "public_repos")
        self.publicGists = try values.decodeIfPresent(Int.self, forKey: "public_gists")
        self.followers = try values.decodeIfPresent(Int.self, forKey: "followers")
        self.following = try values.decodeIfPresent(Int.self, forKey: "following")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.bio = try values.decodeIfPresent(String.self, forKey: "bio")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.location = try values.decodeIfPresent(String.self, forKey: "location")
        self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
        self.isHireable = try values.decodeIfPresent(Bool.self, forKey: "hireable")
        self.textMatches = try values.decodeIfPresent([SearchResultTextMatch].self, forKey: "text_matches")
        self.blog = try values.decodeIfPresent(String.self, forKey: "blog")
        self.company = try values.decodeIfPresent(String.self, forKey: "company")
        self.suspendedAt = try values.decodeIfPresent(Date.self, forKey: "suspended_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(followersURL, forKey: "followers_url")
        try values.encode(subscriptionsURL, forKey: "subscriptions_url")
        try values.encode(organizationsURL, forKey: "organizations_url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encode(score, forKey: "score")
        try values.encode(followingURL, forKey: "following_url")
        try values.encode(gistsURL, forKey: "gists_url")
        try values.encode(starredURL, forKey: "starred_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encodeIfPresent(publicRepos, forKey: "public_repos")
        try values.encodeIfPresent(publicGists, forKey: "public_gists")
        try values.encodeIfPresent(followers, forKey: "followers")
        try values.encodeIfPresent(following, forKey: "following")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(bio, forKey: "bio")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encode(isSiteAdmin, forKey: "site_admin")
        try values.encodeIfPresent(isHireable, forKey: "hireable")
        try values.encodeIfPresent(textMatches, forKey: "text_matches")
        try values.encodeIfPresent(blog, forKey: "blog")
        try values.encodeIfPresent(company, forKey: "company")
        try values.encodeIfPresent(suspendedAt, forKey: "suspended_at")
    }
}

public struct PrivateUser: Codable {
    /// Example: "octocat"
    public var login: String
    public var id: Int
    /// Example: "MDQ6VXNlcjE="
    public var nodeID: String
    /// Example: "https://github.com/images/error/octocat_happy.gif"
    public var avatarURL: URL
    /// Example: "41d064eb2195891e12d0413f63227ea7"
    public var gravatarID: String?
    /// Example: "https://api.github.com/users/octocat"
    public var url: URL
    /// Example: "https://github.com/octocat"
    public var htmlURL: URL
    /// Example: "https://api.github.com/users/octocat/followers"
    public var followersURL: URL
    /// Example: "https://api.github.com/users/octocat/following{/other_user}"
    public var followingURL: String
    /// Example: "https://api.github.com/users/octocat/gists{/gist_id}"
    public var gistsURL: String
    /// Example: "https://api.github.com/users/octocat/starred{/owner}{/repo}"
    public var starredURL: String
    /// Example: "https://api.github.com/users/octocat/subscriptions"
    public var subscriptionsURL: URL
    /// Example: "https://api.github.com/users/octocat/orgs"
    public var organizationsURL: URL
    /// Example: "https://api.github.com/users/octocat/repos"
    public var reposURL: URL
    /// Example: "https://api.github.com/users/octocat/events{/privacy}"
    public var eventsURL: String
    /// Example: "https://api.github.com/users/octocat/received_events"
    public var receivedEventsURL: URL
    /// Example: "User"
    public var type: String
    public var isSiteAdmin: Bool
    /// Example: "monalisa octocat"
    public var name: String?
    /// Example: "GitHub"
    public var company: String?
    /// Example: "https://github.com/blog"
    public var blog: String?
    /// Example: "San Francisco"
    public var location: String?
    /// Example: "octocat@github.com"
    public var email: String?
    public var isHireable: Bool?
    /// Example: "There once was..."
    public var bio: String?
    /// Example: "monalisa"
    public var twitterUsername: String?
    public var publicRepos: Int
    public var publicGists: Int
    /// Example: 20
    public var followers: Int
    public var following: Int
    /// Example: "2008-01-14T04:33:35Z"
    public var createdAt: Date
    /// Example: "2008-01-14T04:33:35Z"
    public var updatedAt: Date
    /// Example: 81
    public var privateGists: Int
    /// Example: 100
    public var totalPrivateRepos: Int
    /// Example: 100
    public var ownedPrivateRepos: Int
    /// Example: 10000
    public var diskUsage: Int
    public var collaborators: Int
    /// Example: true
    public var isTwoFactorAuthentication: Bool
    public var plan: Plan?
    public var suspendedAt: Date?
    public var isBusinessPlus: Bool?
    public var ldapDn: String?

    public struct Plan: Codable {
        public var collaborators: Int
        public var name: String
        public var space: Int
        public var privateRepos: Int

        public init(collaborators: Int, name: String, space: Int, privateRepos: Int) {
            self.collaborators = collaborators
            self.name = name
            self.space = space
            self.privateRepos = privateRepos
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.collaborators = try values.decode(Int.self, forKey: "collaborators")
            self.name = try values.decode(String.self, forKey: "name")
            self.space = try values.decode(Int.self, forKey: "space")
            self.privateRepos = try values.decode(Int.self, forKey: "private_repos")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(collaborators, forKey: "collaborators")
            try values.encode(name, forKey: "name")
            try values.encode(space, forKey: "space")
            try values.encode(privateRepos, forKey: "private_repos")
        }
    }

    public init(login: String, id: Int, nodeID: String, avatarURL: URL, gravatarID: String? = nil, url: URL, htmlURL: URL, followersURL: URL, followingURL: String, gistsURL: String, starredURL: String, subscriptionsURL: URL, organizationsURL: URL, reposURL: URL, eventsURL: String, receivedEventsURL: URL, type: String, isSiteAdmin: Bool, name: String? = nil, company: String? = nil, blog: String? = nil, location: String? = nil, email: String? = nil, isHireable: Bool? = nil, bio: String? = nil, twitterUsername: String? = nil, publicRepos: Int, publicGists: Int, followers: Int, following: Int, createdAt: Date, updatedAt: Date, privateGists: Int, totalPrivateRepos: Int, ownedPrivateRepos: Int, diskUsage: Int, collaborators: Int, isTwoFactorAuthentication: Bool, plan: Plan? = nil, suspendedAt: Date? = nil, isBusinessPlus: Bool? = nil, ldapDn: String? = nil) {
        self.login = login
        self.id = id
        self.nodeID = nodeID
        self.avatarURL = avatarURL
        self.gravatarID = gravatarID
        self.url = url
        self.htmlURL = htmlURL
        self.followersURL = followersURL
        self.followingURL = followingURL
        self.gistsURL = gistsURL
        self.starredURL = starredURL
        self.subscriptionsURL = subscriptionsURL
        self.organizationsURL = organizationsURL
        self.reposURL = reposURL
        self.eventsURL = eventsURL
        self.receivedEventsURL = receivedEventsURL
        self.type = type
        self.isSiteAdmin = isSiteAdmin
        self.name = name
        self.company = company
        self.blog = blog
        self.location = location
        self.email = email
        self.isHireable = isHireable
        self.bio = bio
        self.twitterUsername = twitterUsername
        self.publicRepos = publicRepos
        self.publicGists = publicGists
        self.followers = followers
        self.following = following
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.privateGists = privateGists
        self.totalPrivateRepos = totalPrivateRepos
        self.ownedPrivateRepos = ownedPrivateRepos
        self.diskUsage = diskUsage
        self.collaborators = collaborators
        self.isTwoFactorAuthentication = isTwoFactorAuthentication
        self.plan = plan
        self.suspendedAt = suspendedAt
        self.isBusinessPlus = isBusinessPlus
        self.ldapDn = ldapDn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.login = try values.decode(String.self, forKey: "login")
        self.id = try values.decode(Int.self, forKey: "id")
        self.nodeID = try values.decode(String.self, forKey: "node_id")
        self.avatarURL = try values.decode(URL.self, forKey: "avatar_url")
        self.gravatarID = try values.decodeIfPresent(String.self, forKey: "gravatar_id")
        self.url = try values.decode(URL.self, forKey: "url")
        self.htmlURL = try values.decode(URL.self, forKey: "html_url")
        self.followersURL = try values.decode(URL.self, forKey: "followers_url")
        self.followingURL = try values.decode(String.self, forKey: "following_url")
        self.gistsURL = try values.decode(String.self, forKey: "gists_url")
        self.starredURL = try values.decode(String.self, forKey: "starred_url")
        self.subscriptionsURL = try values.decode(URL.self, forKey: "subscriptions_url")
        self.organizationsURL = try values.decode(URL.self, forKey: "organizations_url")
        self.reposURL = try values.decode(URL.self, forKey: "repos_url")
        self.eventsURL = try values.decode(String.self, forKey: "events_url")
        self.receivedEventsURL = try values.decode(URL.self, forKey: "received_events_url")
        self.type = try values.decode(String.self, forKey: "type")
        self.isSiteAdmin = try values.decode(Bool.self, forKey: "site_admin")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.company = try values.decodeIfPresent(String.self, forKey: "company")
        self.blog = try values.decodeIfPresent(String.self, forKey: "blog")
        self.location = try values.decodeIfPresent(String.self, forKey: "location")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.isHireable = try values.decodeIfPresent(Bool.self, forKey: "hireable")
        self.bio = try values.decodeIfPresent(String.self, forKey: "bio")
        self.twitterUsername = try values.decodeIfPresent(String.self, forKey: "twitter_username")
        self.publicRepos = try values.decode(Int.self, forKey: "public_repos")
        self.publicGists = try values.decode(Int.self, forKey: "public_gists")
        self.followers = try values.decode(Int.self, forKey: "followers")
        self.following = try values.decode(Int.self, forKey: "following")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.privateGists = try values.decode(Int.self, forKey: "private_gists")
        self.totalPrivateRepos = try values.decode(Int.self, forKey: "total_private_repos")
        self.ownedPrivateRepos = try values.decode(Int.self, forKey: "owned_private_repos")
        self.diskUsage = try values.decode(Int.self, forKey: "disk_usage")
        self.collaborators = try values.decode(Int.self, forKey: "collaborators")
        self.isTwoFactorAuthentication = try values.decode(Bool.self, forKey: "two_factor_authentication")
        self.plan = try values.decodeIfPresent(Plan.self, forKey: "plan")
        self.suspendedAt = try values.decodeIfPresent(Date.self, forKey: "suspended_at")
        self.isBusinessPlus = try values.decodeIfPresent(Bool.self, forKey: "business_plus")
        self.ldapDn = try values.decodeIfPresent(String.self, forKey: "ldap_dn")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(login, forKey: "login")
        try values.encode(id, forKey: "id")
        try values.encode(nodeID, forKey: "node_id")
        try values.encode(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(gravatarID, forKey: "gravatar_id")
        try values.encode(url, forKey: "url")
        try values.encode(htmlURL, forKey: "html_url")
        try values.encode(followersURL, forKey: "followers_url")
        try values.encode(followingURL, forKey: "following_url")
        try values.encode(gistsURL, forKey: "gists_url")
        try values.encode(starredURL, forKey: "starred_url")
        try values.encode(subscriptionsURL, forKey: "subscriptions_url")
        try values.encode(organizationsURL, forKey: "organizations_url")
        try values.encode(reposURL, forKey: "repos_url")
        try values.encode(eventsURL, forKey: "events_url")
        try values.encode(receivedEventsURL, forKey: "received_events_url")
        try values.encode(type, forKey: "type")
        try values.encode(isSiteAdmin, forKey: "site_admin")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(company, forKey: "company")
        try values.encodeIfPresent(blog, forKey: "blog")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(isHireable, forKey: "hireable")
        try values.encodeIfPresent(bio, forKey: "bio")
        try values.encodeIfPresent(twitterUsername, forKey: "twitter_username")
        try values.encode(publicRepos, forKey: "public_repos")
        try values.encode(publicGists, forKey: "public_gists")
        try values.encode(followers, forKey: "followers")
        try values.encode(following, forKey: "following")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(privateGists, forKey: "private_gists")
        try values.encode(totalPrivateRepos, forKey: "total_private_repos")
        try values.encode(ownedPrivateRepos, forKey: "owned_private_repos")
        try values.encode(diskUsage, forKey: "disk_usage")
        try values.encode(collaborators, forKey: "collaborators")
        try values.encode(isTwoFactorAuthentication, forKey: "two_factor_authentication")
        try values.encodeIfPresent(plan, forKey: "plan")
        try values.encodeIfPresent(suspendedAt, forKey: "suspended_at")
        try values.encodeIfPresent(isBusinessPlus, forKey: "business_plus")
        try values.encodeIfPresent(ldapDn, forKey: "ldap_dn")
    }
}

/// Secrets for a GitHub Codespace.
public struct CodespacesSecret: Codable {
    /// The name of the secret.
    ///
    /// Example: "SECRET_NAME"
    public var name: String
    public var createdAt: Date
    public var updatedAt: Date
    /// Visibility of a secret
    public var visibility: Visibility
    /// Example: "https://api.github.com/user/secrets/SECRET_NAME/repositories"
    public var selectedRepositoriesURL: URL

    /// Visibility of a secret
    public enum Visibility: String, Codable, CaseIterable {
        case all
        case `private`
        case selected
    }

    public init(name: String, createdAt: Date, updatedAt: Date, visibility: Visibility, selectedRepositoriesURL: URL) {
        self.name = name
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.visibility = visibility
        self.selectedRepositoriesURL = selectedRepositoriesURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decode(String.self, forKey: "name")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.visibility = try values.decode(Visibility.self, forKey: "visibility")
        self.selectedRepositoriesURL = try values.decode(URL.self, forKey: "selected_repositories_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(name, forKey: "name")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encode(visibility, forKey: "visibility")
        try values.encode(selectedRepositoriesURL, forKey: "selected_repositories_url")
    }
}

/// The public key used for setting user Codespaces' Secrets.
public struct CodespacesUserPublicKey: Codable {
    /// The identifier for the key.
    ///
    /// Example: "1234567"
    public var keyID: String
    /// The Base64 encoded public key.
    ///
    /// Example: "hBT5WZEj8ZoOv6TYJsfWq7MxTEQopZO5/IT3ZCVQPzs="
    public var key: String

    public init(keyID: String, key: String) {
        self.keyID = keyID
        self.key = key
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.keyID = try values.decode(String.self, forKey: "key_id")
        self.key = try values.decode(String.self, forKey: "key")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(keyID, forKey: "key_id")
        try values.encode(key, forKey: "key")
    }
}

public struct Email: Codable {
    /// Example: "octocat@github.com"
    public var email: String
    /// Example: true
    public var isPrimary: Bool
    /// Example: true
    public var isVerified: Bool
    /// Example: "public"
    public var visibility: String?

    public init(email: String, isPrimary: Bool, isVerified: Bool, visibility: String? = nil) {
        self.email = email
        self.isPrimary = isPrimary
        self.isVerified = isVerified
        self.visibility = visibility
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.email = try values.decode(String.self, forKey: "email")
        self.isPrimary = try values.decode(Bool.self, forKey: "primary")
        self.isVerified = try values.decode(Bool.self, forKey: "verified")
        self.visibility = try values.decodeIfPresent(String.self, forKey: "visibility")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(email, forKey: "email")
        try values.encode(isPrimary, forKey: "primary")
        try values.encode(isVerified, forKey: "verified")
        try values.encodeIfPresent(visibility, forKey: "visibility")
    }
}

/// A unique encryption key
public struct GpgKey: Codable {
    public var id: Int
    public var primaryKeyID: Int?
    /// Example: "3262EFF25BA0D270"
    public var keyID: String
    /// Example: "xsBNBFayYZ..."
    public var publicKey: String
    /// Example:
    ///
    /// [
    ///   {
    ///     "email" : "mastahyeti@users.noreply.github.com",
    ///     "verified" : true
    ///   }
    /// ]
    public var emails: [Email]
    /// Example:
    ///
    /// [
    ///   {
    ///     "can_certify" : false,
    ///     "can_encrypt_comms" : true,
    ///     "can_encrypt_storage" : true,
    ///     "can_sign" : false,
    ///     "created_at" : "2016-03-24T11:31:04-06:00",
    ///     "emails" : [
    /// 
    ///     ],
    ///     "expires_at" : null,
    ///     "id" : 4,
    ///     "key_id" : "4A595D4C72EE49C7",
    ///     "primary_key_id" : 3,
    ///     "public_key" : "zsBNBFayYZ...",
    ///     "subkeys" : [
    /// 
    ///     ]
    ///   }
    /// ]
    public var subkeys: [Subkey]
    /// Example: true
    public var canSign: Bool
    public var canEncryptComms: Bool
    public var canEncryptStorage: Bool
    /// Example: true
    public var canCertify: Bool
    /// Example: "2016-03-24T11:31:04-06:00"
    public var createdAt: Date
    public var expiresAt: Date?
    public var rawKey: String?

    public struct Email: Codable {
        public var email: String?
        public var isVerified: Bool?

        public init(email: String? = nil, isVerified: Bool? = nil) {
            self.email = email
            self.isVerified = isVerified
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
            self.isVerified = try values.decodeIfPresent(Bool.self, forKey: "verified")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(email, forKey: "email")
            try values.encodeIfPresent(isVerified, forKey: "verified")
        }
    }

    public struct Subkey: Codable {
        public var id: Int?
        public var primaryKeyID: Int?
        public var keyID: String?
        public var publicKey: String?
        public var emails: [AnyJSON]?
        public var subkeys: [AnyJSON]?
        public var canSign: Bool?
        public var canEncryptComms: Bool?
        public var canEncryptStorage: Bool?
        public var canCertify: Bool?
        public var createdAt: String?
        public var expiresAt: String?
        public var rawKey: String?

        public init(id: Int? = nil, primaryKeyID: Int? = nil, keyID: String? = nil, publicKey: String? = nil, emails: [AnyJSON]? = nil, subkeys: [AnyJSON]? = nil, canSign: Bool? = nil, canEncryptComms: Bool? = nil, canEncryptStorage: Bool? = nil, canCertify: Bool? = nil, createdAt: String? = nil, expiresAt: String? = nil, rawKey: String? = nil) {
            self.id = id
            self.primaryKeyID = primaryKeyID
            self.keyID = keyID
            self.publicKey = publicKey
            self.emails = emails
            self.subkeys = subkeys
            self.canSign = canSign
            self.canEncryptComms = canEncryptComms
            self.canEncryptStorage = canEncryptStorage
            self.canCertify = canCertify
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.rawKey = rawKey
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.primaryKeyID = try values.decodeIfPresent(Int.self, forKey: "primary_key_id")
            self.keyID = try values.decodeIfPresent(String.self, forKey: "key_id")
            self.publicKey = try values.decodeIfPresent(String.self, forKey: "public_key")
            self.emails = try values.decodeIfPresent([AnyJSON].self, forKey: "emails")
            self.subkeys = try values.decodeIfPresent([AnyJSON].self, forKey: "subkeys")
            self.canSign = try values.decodeIfPresent(Bool.self, forKey: "can_sign")
            self.canEncryptComms = try values.decodeIfPresent(Bool.self, forKey: "can_encrypt_comms")
            self.canEncryptStorage = try values.decodeIfPresent(Bool.self, forKey: "can_encrypt_storage")
            self.canCertify = try values.decodeIfPresent(Bool.self, forKey: "can_certify")
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.expiresAt = try values.decodeIfPresent(String.self, forKey: "expires_at")
            self.rawKey = try values.decodeIfPresent(String.self, forKey: "raw_key")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(primaryKeyID, forKey: "primary_key_id")
            try values.encodeIfPresent(keyID, forKey: "key_id")
            try values.encodeIfPresent(publicKey, forKey: "public_key")
            try values.encodeIfPresent(emails, forKey: "emails")
            try values.encodeIfPresent(subkeys, forKey: "subkeys")
            try values.encodeIfPresent(canSign, forKey: "can_sign")
            try values.encodeIfPresent(canEncryptComms, forKey: "can_encrypt_comms")
            try values.encodeIfPresent(canEncryptStorage, forKey: "can_encrypt_storage")
            try values.encodeIfPresent(canCertify, forKey: "can_certify")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(expiresAt, forKey: "expires_at")
            try values.encodeIfPresent(rawKey, forKey: "raw_key")
        }
    }

    public init(id: Int, primaryKeyID: Int? = nil, keyID: String, publicKey: String, emails: [Email], subkeys: [Subkey], canSign: Bool, canEncryptComms: Bool, canEncryptStorage: Bool, canCertify: Bool, createdAt: Date, expiresAt: Date? = nil, rawKey: String? = nil) {
        self.id = id
        self.primaryKeyID = primaryKeyID
        self.keyID = keyID
        self.publicKey = publicKey
        self.emails = emails
        self.subkeys = subkeys
        self.canSign = canSign
        self.canEncryptComms = canEncryptComms
        self.canEncryptStorage = canEncryptStorage
        self.canCertify = canCertify
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.rawKey = rawKey
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.primaryKeyID = try values.decodeIfPresent(Int.self, forKey: "primary_key_id")
        self.keyID = try values.decode(String.self, forKey: "key_id")
        self.publicKey = try values.decode(String.self, forKey: "public_key")
        self.emails = try values.decode([Email].self, forKey: "emails")
        self.subkeys = try values.decode([Subkey].self, forKey: "subkeys")
        self.canSign = try values.decode(Bool.self, forKey: "can_sign")
        self.canEncryptComms = try values.decode(Bool.self, forKey: "can_encrypt_comms")
        self.canEncryptStorage = try values.decode(Bool.self, forKey: "can_encrypt_storage")
        self.canCertify = try values.decode(Bool.self, forKey: "can_certify")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.expiresAt = try values.decodeIfPresent(Date.self, forKey: "expires_at")
        self.rawKey = try values.decodeIfPresent(String.self, forKey: "raw_key")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(primaryKeyID, forKey: "primary_key_id")
        try values.encode(keyID, forKey: "key_id")
        try values.encode(publicKey, forKey: "public_key")
        try values.encode(emails, forKey: "emails")
        try values.encode(subkeys, forKey: "subkeys")
        try values.encode(canSign, forKey: "can_sign")
        try values.encode(canEncryptComms, forKey: "can_encrypt_comms")
        try values.encode(canEncryptStorage, forKey: "can_encrypt_storage")
        try values.encode(canCertify, forKey: "can_certify")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(rawKey, forKey: "raw_key")
    }
}

public struct Key: Codable {
    public var key: String
    public var id: Int
    public var url: String
    public var title: String
    public var createdAt: Date
    public var isVerified: Bool
    public var isReadOnly: Bool

    public init(key: String, id: Int, url: String, title: String, createdAt: Date, isVerified: Bool, isReadOnly: Bool) {
        self.key = key
        self.id = id
        self.url = url
        self.title = title
        self.createdAt = createdAt
        self.isVerified = isVerified
        self.isReadOnly = isReadOnly
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.key = try values.decode(String.self, forKey: "key")
        self.id = try values.decode(Int.self, forKey: "id")
        self.url = try values.decode(String.self, forKey: "url")
        self.title = try values.decode(String.self, forKey: "title")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.isVerified = try values.decode(Bool.self, forKey: "verified")
        self.isReadOnly = try values.decode(Bool.self, forKey: "read_only")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(key, forKey: "key")
        try values.encode(id, forKey: "id")
        try values.encode(url, forKey: "url")
        try values.encode(title, forKey: "title")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(isVerified, forKey: "verified")
        try values.encode(isReadOnly, forKey: "read_only")
    }
}

public struct MarketplaceAccount: Codable {
    public var url: URL
    public var id: Int
    public var type: String
    public var nodeID: String?
    public var login: String
    public var email: String?
    public var organizationBillingEmail: String?

    public init(url: URL, id: Int, type: String, nodeID: String? = nil, login: String, email: String? = nil, organizationBillingEmail: String? = nil) {
        self.url = url
        self.id = id
        self.type = type
        self.nodeID = nodeID
        self.login = login
        self.email = email
        self.organizationBillingEmail = organizationBillingEmail
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.url = try values.decode(URL.self, forKey: "url")
        self.id = try values.decode(Int.self, forKey: "id")
        self.type = try values.decode(String.self, forKey: "type")
        self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
        self.login = try values.decode(String.self, forKey: "login")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.organizationBillingEmail = try values.decodeIfPresent(String.self, forKey: "organization_billing_email")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(url, forKey: "url")
        try values.encode(id, forKey: "id")
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(nodeID, forKey: "node_id")
        try values.encode(login, forKey: "login")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(organizationBillingEmail, forKey: "organization_billing_email")
    }
}

public struct UserMarketplacePurchase: Codable {
    /// Example: "monthly"
    public var billingCycle: String
    /// Example: "2017-11-11T00:00:00Z"
    public var nextBillingDate: Date?
    public var unitCount: Int?
    /// Example: true
    public var isOnFreeTrial: Bool
    /// Example: "2017-11-11T00:00:00Z"
    public var freeTrialEndsOn: Date?
    /// Example: "2017-11-02T01:12:12Z"
    public var updatedAt: Date?
    /// Marketplace Account
    public var account: MarketplaceAccount
    /// Marketplace Listing Plan
    public var plan: MarketplaceListingPlan

    public init(billingCycle: String, nextBillingDate: Date? = nil, unitCount: Int? = nil, isOnFreeTrial: Bool, freeTrialEndsOn: Date? = nil, updatedAt: Date? = nil, account: MarketplaceAccount, plan: MarketplaceListingPlan) {
        self.billingCycle = billingCycle
        self.nextBillingDate = nextBillingDate
        self.unitCount = unitCount
        self.isOnFreeTrial = isOnFreeTrial
        self.freeTrialEndsOn = freeTrialEndsOn
        self.updatedAt = updatedAt
        self.account = account
        self.plan = plan
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.billingCycle = try values.decode(String.self, forKey: "billing_cycle")
        self.nextBillingDate = try values.decodeIfPresent(Date.self, forKey: "next_billing_date")
        self.unitCount = try values.decodeIfPresent(Int.self, forKey: "unit_count")
        self.isOnFreeTrial = try values.decode(Bool.self, forKey: "on_free_trial")
        self.freeTrialEndsOn = try values.decodeIfPresent(Date.self, forKey: "free_trial_ends_on")
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: "updated_at")
        self.account = try values.decode(MarketplaceAccount.self, forKey: "account")
        self.plan = try values.decode(MarketplaceListingPlan.self, forKey: "plan")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(billingCycle, forKey: "billing_cycle")
        try values.encodeIfPresent(nextBillingDate, forKey: "next_billing_date")
        try values.encodeIfPresent(unitCount, forKey: "unit_count")
        try values.encode(isOnFreeTrial, forKey: "on_free_trial")
        try values.encodeIfPresent(freeTrialEndsOn, forKey: "free_trial_ends_on")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encode(account, forKey: "account")
        try values.encode(plan, forKey: "plan")
    }
}

public struct StarredRepository: Codable {
    public var starredAt: Date
    /// Repository
    ///
    /// A git repository
    public var repo: Repository

    public init(starredAt: Date, repo: Repository) {
        self.starredAt = starredAt
        self.repo = repo
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.starredAt = try values.decode(Date.self, forKey: "starred_at")
        self.repo = try values.decode(Repository.self, forKey: "repo")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(starredAt, forKey: "starred_at")
        try values.encode(repo, forKey: "repo")
    }
}

public struct Hovercard: Codable {
    public var contexts: [Context]

    public struct Context: Codable {
        public var message: String
        public var octicon: String

        public init(message: String, octicon: String) {
            self.message = message
            self.octicon = octicon
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.message = try values.decode(String.self, forKey: "message")
            self.octicon = try values.decode(String.self, forKey: "octicon")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(message, forKey: "message")
            try values.encode(octicon, forKey: "octicon")
        }
    }

    public init(contexts: [Context]) {
        self.contexts = contexts
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.contexts = try values.decode([Context].self, forKey: "contexts")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(contexts, forKey: "contexts")
    }
}

public struct KeySimple: Codable {
    public var id: Int
    public var key: String

    public init(id: Int, key: String) {
        self.id = id
        self.key = key
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.key = try values.decode(String.self, forKey: "key")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(key, forKey: "key")
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
